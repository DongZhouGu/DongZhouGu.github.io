<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>一、如何用Netty实现高性能网络通信？ | 欢迎来到，TWOTO 的博客</title><meta name="keywords" content="XPRC,Netty"><meta name="author" content="DongZhou"><meta name="copyright" content="DongZhou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从零实现一个轻量级 RPC 框架-系列文章Github: https:&#x2F;&#x2F;github.com&#x2F;DongZhouGu&#x2F;XRpc  前言既然要调用远程方法，必然需要网络通信，通过网络来传递要调用的目标类信息及相关方法参数，和返回的调用结果。网络传输具体实现可以使用 Socket 、NIO、Netty：  Socket：Java 中最原始、最基础的网络通信方式。但是 Socket 是阻塞 IO、">
<meta property="og:type" content="article">
<meta property="og:title" content="一、如何用Netty实现高性能网络通信？">
<meta property="og:url" content="https://dongzhougu.github.io/2022/05/12/yuque/yi-ru-he-yong-netty-shi-xian-gao-xing-neng-wang-luo-tong-xin/index.html">
<meta property="og:site_name" content="欢迎来到，TWOTO 的博客">
<meta property="og:description" content="从零实现一个轻量级 RPC 框架-系列文章Github: https:&#x2F;&#x2F;github.com&#x2F;DongZhouGu&#x2F;XRpc  前言既然要调用远程方法，必然需要网络通信，通过网络来传递要调用的目标类信息及相关方法参数，和返回的调用结果。网络传输具体实现可以使用 Socket 、NIO、Netty：  Socket：Java 中最原始、最基础的网络通信方式。但是 Socket 是阻塞 IO、">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dongzhougu.github.io/img/avatar.png">
<meta property="article:published_time" content="2022-05-12T06:42:07.000Z">
<meta property="article:modified_time" content="2022-05-12T07:52:07.520Z">
<meta property="article:author" content="DongZhou">
<meta property="article:tag" content="XPRC">
<meta property="article:tag" content="Netty">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dongzhougu.github.io/img/avatar.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://dongzhougu.github.io/2022/05/12/yuque/yi-ru-he-yong-netty-shi-xian-gao-xing-neng-wang-luo-tong-xin/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="NdIUXAOVyGnnBhcrip0ksCawbdAzT0hlBZDE9u4jx6k"/><meta name="msvalidate.01" content="567E47D75E8DCF1282B9623AD914701E"/><meta name="baidu-site-verification" content="code-pE5rnuxcfD"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: DongZhou","link":"链接: ","source":"来源: 欢迎来到，TWOTO 的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '一、如何用Netty实现高性能网络通信？',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-12 15:52:07'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const fontSizeVal = saveToLocal.get('global-font-size')
    if (fontSizeVal !== undefined) {
      document.documentElement.style.setProperty('--global-font-size', fontSizeVal + 'px')
    }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    document.addEventListener('pjax:complete', detectApple)})(window)</script><style type="text/css">.card-announcement .social-button{margin: .6rem 0 0 0; text-align: center;}.card-announcement .social-button a{display: block; margin: 0.2rem 0;background-color: var(--btn-bg); color: var(--btn-color); line-height: 1.6rem; transition: all .3s; position: relative; z-index: 1;}</style><style type="text/css" lang="css">
    #loading-container{
        position: fixed;
        top: 0;
        left: 0;
        min-height: 100vh;
        width: 100vw;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: #FFF;
        text-align: center;
        /* loader页面消失采用渐隐的方式*/
        -webkit-transition: opacity 1s ease;
        -moz-transition: opacity 1s ease;
        -o-transition: opacity 1s ease;
        transition: opacity 1s ease;
    }
    .loading-image{
        width: 120px;
        height: 50px;
        transform: translate(-50%);
    }
    
    .loading-image div:nth-child(2) {
        -webkit-animation: pacman-balls 1s linear 0s infinite;
        animation: pacman-balls 1s linear 0s infinite
    }

    .loading-image div:nth-child(3) {
        -webkit-animation: pacman-balls 1s linear .33s infinite;
        animation: pacman-balls 1s linear .33s infinite
    }

    .loading-image div:nth-child(4) {
        -webkit-animation: pacman-balls 1s linear .66s infinite;
        animation: pacman-balls 1s linear .66s infinite
    }

    .loading-image div:nth-child(5) {
        -webkit-animation: pacman-balls 1s linear .99s infinite;
        animation: pacman-balls 1s linear .99s infinite
    }
    
   .loading-image div:first-of-type {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_up .5s 0s infinite;
        animation: rotate_pacman_half_up .5s 0s infinite;
    }
    .loading-image div:nth-child(2) {
        width: 0;
        height: 0;
        border: 25px solid #49b1f5;
        border-right-color: transparent;
        border-radius: 25px;
        -webkit-animation: rotate_pacman_half_down .5s 0s infinite;
        animation: rotate_pacman_half_down .5s 0s infinite;
        margin-top: -50px;
    }
    @-webkit-keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @keyframes rotate_pacman_half_up {0% {transform: rotate(270deg)}50% {transform: rotate(1turn)}to {transform: rotate(270deg)}}

    @-webkit-keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}

    @keyframes rotate_pacman_half_down {0% {transform: rotate(90deg)}50% {transform: rotate(0deg)}to {transform: rotate(90deg)}}
    
    @-webkit-keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}

    @keyframes pacman-balls {75% {opacity: .7}to {transform: translate(-100px, -6.25px)}}
    
   
    .loading-image div:nth-child(3),
    .loading-image div:nth-child(4),
    .loading-image div:nth-child(5),
    .loading-image div:nth-child(6){
        background-color: #49b1f5;
        width: 15px;
        height: 15px;
        border-radius: 100%;
        margin: 2px;
        width: 10px;
        height: 10px;
        position: absolute;
        transform: translateY(-6.25px);
        top: 25px;
        left: 100px;
    }
    .loading-text{
        margin-bottom: 20vh;
        text-align: center;
        color: #2c3e50;
        font-size: 2rem;
        box-sizing: border-box;
        padding: 0 10px;
        text-shadow: 0 2px 10px rgba(0,0,0,0.2);
    }
    @media only screen and (max-width: 500px) {
         .loading-text{
            font-size: 1.5rem;
         }
    }
    .fadeout {
        opacity: 0;
        filter: alpha(opacity=0);
    }
    /* logo出现动画 */
    @-webkit-keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);transform:translate3d(0,-100%,0)}100%{opacity:1;-webkit-transform:none;transform:none}}
    @keyframes fadeInDown{0%{opacity:0;-webkit-transform:translate3d(0,-100%,0);}}
 </style>
 <script>
(function () {
    const loaded = function(){
       setTimeout(function(){
            const loader = document.getElementById("loading-container");
            loader.className="fadeout" ;//使用渐隐的方法淡出loading page
            // document.getElementById("body-wrap").style.display="flex";
            setTimeout(function(){
                loader.style.display="none";
            },1000); 
        },1000);//强制显示loading page 1s  
    };
    loaded();
})()
 </script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="欢迎来到，TWOTO 的博客" type="application/atom+xml">
</head>
 <div id="loading-container">
     <p class="loading-text">玩命加载中 . . . </p> 
     <div class="loading-image">
         <div></div>
         <div></div>
         <div></div>
         <div></div> 
         <div></div>
     </div>
 </div><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/DongZhouGu/DongZhouGu.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">欢迎来到，TWOTO 的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><i class="fa-fw fas fa-compass"></i><span> 目录</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fas fa-comment-dots"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">一、如何用Netty实现高性能网络通信？<a class="post-edit-link" href="https://github.com/DongZhouGu/Blog-backup/edit/master/source/_posts/yuque/一、如何用Netty实现高性能网络通信？.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2022-05-12T06:42:07.000Z" title="undefined 2022-05-12 14:42:07">2022-05-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%A1%B9%E7%9B%AE/">项目</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="一、如何用Netty实现高性能网络通信？"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><span id="more"></span>

<blockquote>
<p>从零实现一个轻量级 RPC 框架-系列文章<br>Github: <a target="_blank" rel="noopener" href="https://github.com/DongZhouGu/XRpc">https://github.com/DongZhouGu/XRpc</a></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>既然要调用远程方法，必然需要网络通信，通过网络来传递要调用的目标类信息及相关方法参数，和返回的调用结果。<br>网络传输具体实现可以使用 Socket 、NIO、Netty：</p>
<ul>
<li>Socket：Java 中最原始、最基础的网络通信方式。但是 Socket 是阻塞 IO、性能低并且功能单一</li>
<li>NIO：同步非阻塞的 I/O 模型，Java 原生实现，但是用它来进行网络编程太过繁琐</li>
<li>Netty：基于 NIO 的 client-server(客户端服务器)框架，设计了一套优秀的 Reactor 反应器模式使用它可以快速简单地开发网络应用程序。极大地简化并简化了 TCP 和 UDP 套接字服务器等网络编程, 并且性能以及安全性等很多方面甚至都要更好。支持多种协议如 FTP，SMTP，HTTP 以及各种二进制和基于文本的传统协议。</li>
</ul>
<h2 id="Reactor-反应器模式"><a href="#Reactor-反应器模式" class="headerlink" title="Reactor 反应器模式"></a>Reactor 反应器模式</h2><p>Reactor 就是基于 NIO 中实现多路复用的一种模式，</p>
<h3 id="单-Reactor-单线程模型"><a href="#单-Reactor-单线程模型" class="headerlink" title="单 Reactor 单线程模型"></a>单 Reactor 单线程模型</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/1164521/1651239494041-429b359b-3ebf-4043-88f4-d4f043c98ac9.png#clientId=u094a13e3-2a73-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uf1c9ab7e&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=479&amp;originWidth=743&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=32668&amp;status=done&amp;style=none&amp;taskId=u8086378d-4da0-45b8-946d-333c8f1a9b0&amp;title=" alt="image.png"></p>
<ul>
<li>服务端的 Reactor 是一个线程，该线程会启动事件循环，并使用 Selector 实现 IO 多路复用，通过 acceptor 来获取并注册新的连接</li>
<li>客户端发起连接请求，Reactor 监听到了这个时间，并分发给对应的 acceptor 去处理，acceptor 负责建立到这个客户端的 SocketChannel，Reactor 使用 Selector 系统调用进行事件监听</li>
<li>当客户端有 IO 读写事件时，则分发给对应的 handler 进行处理</li>
</ul>
<p>单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor 线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O 请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 Reactor 线程上卸载，以此来加速 Reactor 线程对 I/O 请求的响应。</p>
<h3 id="单-Reactor-多线程模型"><a href="#单-Reactor-多线程模型" class="headerlink" title="单 Reactor 多线程模型"></a>单 Reactor 多线程模型</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/1164521/1651239500254-92694874-1d18-43a8-9501-a4f49aede460.png#clientId=u094a13e3-2a73-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc14ceb57&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=459&amp;originWidth=687&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=33868&amp;status=done&amp;style=none&amp;taskId=u4f1f3f5b-4efc-4916-80f5-289f3db5d2f&amp;title=" alt="image.png"><br>与单线程 Reactor 模式不同的是，添加了一个工作者线程池，并将非 I/O 操作从 Reactor 线程中移出转交给工作者线程池来执行。这样能够提高 Reactor 线程的 I/O 响应，不至于因为一些耗时的业务逻辑而延迟对后面 I/O 请求的处理。</p>
<h3 id="多-Reactor-多线程模型"><a href="#多-Reactor-多线程模型" class="headerlink" title="多 Reactor 多线程模型"></a>多 Reactor 多线程模型</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/1164521/1651239513042-abc8057a-d22b-41d8-83c7-0cea76d96cb2.png#clientId=u094a13e3-2a73-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc09103b5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=479&amp;originWidth=827&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=43560&amp;status=done&amp;style=none&amp;taskId=ueff1da0b-f2bc-4a60-a8a3-874a57218a7&amp;title=" alt="image.png"><br>多 Reactor 线程模式将“接受客户端的连接请求”和“与该客户端的通信”分在了两个 Reactor 线程来完成。mainReactor 完成接收客户端连接请求的操作，它不负责与客户端的通信，而是将建立好的连接转交给 subReactor 线程来完成与客户端的通信，这样一来就不会因为 read()数据量太大而导致后面的客户端连接请求得不到即时处理的情况。并且多 Reactor 线程模式在海量的客户端并发请求的情况下，还可以通过实现 subReactor 线程池来将海量的连接分发给多个 subReactor 线程，在多核的操作系统中这能大大提升应用的负载和吞吐量。</p>
<h2 id="使用-Netty-来实现-XPRC-服务端"><a href="#使用-Netty-来实现-XPRC-服务端" class="headerlink" title="使用 Netty 来实现 XPRC 服务端"></a>使用 Netty 来实现 XPRC 服务端</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">private</span> InetSocketAddress serverAddress = getServerAddress();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>{</span><br><span class="line">        thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            DefaultEventExecutorGroup serviceHandlerGroup = <span class="keyword">new</span> DefaultEventExecutorGroup(</span><br><span class="line">                    RuntimeUtil.cpus() * <span class="number">2</span>,</span><br><span class="line">                    ThreadPoolFactoryUtil.createThreadFactory(<span class="string">"service-handler-group"</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                <span class="comment">// 负责服务器通道新连接的IO事件的监听</span></span><br><span class="line">                NioEventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">                <span class="comment">// 负责传输通道的IO事件的处理, 无参数的构造函数默认最大可用的CPU处理器数量 的2倍</span></span><br><span class="line">                NioEventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">                    bootstrap.group(bossGroup, workerGroup)</span><br><span class="line">                            .channel(NioServerSocketChannel.class)</span><br><span class="line">                            <span class="comment">// TCP默认开启了 Nagle 算法，该算法的作用是尽可能的发送大数据快，减少网络传输。TCP_NODELAY 参数的作用就是控制是否启用 Nagle 算法。</span></span><br><span class="line">                            .childOption(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                            <span class="comment">// 是否开启 TCP 底层心跳机制</span></span><br><span class="line">                            .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                            <span class="comment">//表示系统用于临时存放已完成三次握手的请求的队列的最大长度,如果连接建立频繁，服务器处理创建新连接较慢，可以适当调大这个参数</span></span><br><span class="line">                            .option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                            .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() {</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                                    <span class="comment">// 心跳,空闲检测</span></span><br><span class="line">                                    ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">                                    <span class="comment">// 处理粘包半包</span></span><br><span class="line">                                    ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                                    ch.pipeline().addLast(<span class="keyword">new</span> RpcDecoder());</span><br><span class="line">                                    ch.pipeline().addLast(<span class="keyword">new</span> RpcEncoder());</span><br><span class="line">                                    ch.pipeline().addLast(serviceHandlerGroup, <span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">                                }</span><br><span class="line">                            });</span><br><span class="line">                    <span class="comment">// 绑定端口，同步等待绑定成功</span></span><br><span class="line">                    <span class="comment">//bind操作(对应初始化)是异步的，通过sync改为同步等待初始化的完成，否则立即操作对象(未初始完全)可能会报错</span></span><br><span class="line">                    ChannelFuture f = bootstrap.bind(serverAddress.getAddress(), serverAddress.getPort()).sync();</span><br><span class="line">                    log.info(<span class="string">"Netty Server started on address {}"</span>, serverAddress);</span><br><span class="line">                    <span class="comment">// 不会立即执行 finally，而阻塞在这里，等待服务端监听端口关闭</span></span><br><span class="line">                    f.channel().closeFuture().sync();</span><br><span class="line">                } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                    <span class="keyword">if</span> (e <span class="keyword">instanceof</span> InterruptedException) {</span><br><span class="line">                        log.info(<span class="string">"Rpc server remoting server stop"</span>);</span><br><span class="line">                    } <span class="keyword">else</span> {</span><br><span class="line">                        log.error(<span class="string">"Rpc server remoting server error"</span>, e);</span><br><span class="line">                    }</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        serviceRegistry.unregisterService(serverAddress);</span><br><span class="line">                        workerGroup.shutdownGracefully();</span><br><span class="line">                        bossGroup.shutdownGracefully();</span><br><span class="line">                    } <span class="keyword">catch</span> (Exception ex) {</span><br><span class="line">                        log.error(ex.getMessage(), ex);</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        thread.start();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="comment">// destroy server thread</span></span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span> &amp;&amp; thread.isAlive()) {</span><br><span class="line">            thread.interrupt();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="NioEventLoop"><a href="#NioEventLoop" class="headerlink" title="NioEventLoop"></a>NioEventLoop</h3><p>Netty 的反应器类为：NioEventLoop，首先看到，我们创建了两个 NioEventLoopGroup，第一个通 常被称为“包工头”，负责服务器通道新连接的 IO 事件的监听。第二个 通常被称为“工人”，主要负责传输通道的 IO 事件的处理。具体来说，一种类型的 reactor 线程是 boss 线程组，专门用来接受新的连接，然后封装成 channel 对象扔给 worker 线程组；还有一种类型的 reactor 线程是 worker 线程组，专门用来处理连接的读写。不管是 boos 线程还是 worker 线程，所做的事情均分为以下三个步骤</p>
<ol>
<li>轮询注册在 selector 上的 IO 事件</li>
<li>处理 IO 事件</li>
<li>执行异步 task</li>
</ol>
<p>对于 boos 线程来说，第一步轮询出来的基本都是 accept 事件，表示有新的连接，而 worker 线程轮询出来的基本都是 read/write 事件，表示网络的读写事件。<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/webp/1164521/1651202492097-1e6d73cc-91fb-4dbe-b509-80543853cd2e.webp#clientId=u38b5cafb-8dd3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2ca7f28d&amp;margin=%5Bobject%20Object%5D&amp;originHeight=714&amp;originWidth=1304&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ub8c17781-9fb6-43c3-b227-316b201a444&amp;title=" alt=""></p>
<h3 id="ServerBootstrap-服务启动类"><a href="#ServerBootstrap-服务启动类" class="headerlink" title="ServerBootstrap 服务启动类"></a>ServerBootstrap 服务启动类</h3><p>Bootstrap 类是 Netty 提供的一个便利的工厂类，可以通过它来完成 Netty 的客户端或服务器端的 Netty 组件的组装，以及 Netty 程序的初始 化。当然，Netty 的官方解释是，完全可以不用这个 Bootstrap 启动器。 但是，一点点去手动创建通道、完成各种设置和启动、并且注册到 EventLoop，这个过程会非常麻烦。通常情况下，还是使用这个便利的 Bootstrap 工具类会效率更高。</p>
<ol>
<li><strong>创建反应器线程组，并赋值给 ServerBootstrap 启动器实例</strong></li>
</ol>
<p>在服务器端，建议设置成两个线程组的工作模式。</p>
<ol start="2">
<li><strong>设置通道的 IO 类型</strong></li>
</ol>
<p>Netty 不止支持 Java NIO，也支持阻塞式的 OIO（也叫 BIO，BlockIO，即阻塞式 IO）由于 NIO 的优势巨大，通 常不会在 Netty 中使用 BIO。<br>在 Netty 中，将有接收关系的 NioServerSocketChannel 和 NioSocketChannel，叫作父子通道。其中，NioServerSocketChannel 负 责服务器连接监听和接收，也叫父通道（Parent Channel）。对应于每 一个接收到的 NioSocketChannel 传输类通道，也叫子通道（Child Channel）。服务端使用 b.channel(NioServerSocketChannel.class)来监听</p>
<ol start="3">
<li><strong>设置传输通道的配置选项</strong></li>
</ol>
<p>调用了 Bootstrap 的 option()选项设置方法。对于服务器的 Bootstrap 而言，这个方法的作用是：给父通道（Parent Channel）设置一些与传输协议相关的选项。如果要给子通道（Child Channel）设置一些通道选项，则需要调用 childOption()设置方法。具体的 channelOption(): <a target="_blank" rel="noopener" href="https://juejin.cn/post/6982470261811445791">https://juejin.cn/post/6982470261811445791</a></p>
<ol start="4">
<li><strong>装配子通道的 Pipeline 流水线</strong></li>
</ol>
<p>每一个通道的子通道，都用一条 ChannelPipeline 流水线。它的内部有一个双向的链表。装配流水线的方式是：将业务 处理器 ChannelHandler 实例加入双向链表中。 装配子通道的 Handler 流水线调用 childHandler()方法，传递一个 ChannelInitializer 通道初始化类的实例。<br>在父通道成功接收一个连接， 并创建成功一个子通道后，就会初始化子通道，这里配置的 ChannelInitializer 实例就会被调用。 在 ChannelInitializer 通道初始化类的实例中，有一个 initChannel 初 始化方法，在子通道创建后会被执行到，向子通道流水线增加业务处理器。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="comment">// 心跳,空闲检测</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">15</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">        <span class="comment">// 处理粘包半包</span></span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> RpcDecoder());</span><br><span class="line">        ch.pipeline().addLast(<span class="keyword">new</span> RpcEncoder());</span><br><span class="line">        ch.pipeline().addLast(serviceHandlerGroup, <span class="keyword">new</span> NettyServerHandler());</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure>

<p>为什么仅装配子通道的流水线，而不需要装配父通道的流水线 呢？原因是：父通道也就是 NioServerSocketChannel 连接接受通道，它 的内部业务处理是固定的：接受新连接后，创建子通道，然后初始化 子通道，所以不需要特别的配置。</p>
<ol start="5">
<li><strong>开始绑定服务器新连接的监听端口</strong></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绑定端口，同步等待绑定成功</span></span><br><span class="line"><span class="comment">//bind操作(对应初始化)是异步的，通过sync改为同步等待初始化的完成，否则立即操作对象(未初始完全)可能会报错</span></span><br><span class="line">ChannelFuture f = bootstrap.bind(serverAddress.getAddress(), serverAddress.getPort()).sync();</span><br><span class="line">log.info(<span class="string">"Netty Server started on address {}"</span>, serverAddress);</span><br></pre></td></tr></tbody></table></figure>

<p>bootstrap.bind()方法的功能：返回一个端口绑定 Netty 的异 步任务 channelFuture。在这里，并没有给 channelFuture 异步任务增加回 调监听器，而是阻塞 channelFuture 异步任务，直到端口绑定任务执行 完成。</p>
<ol start="6">
<li><strong>自我阻塞，直到通道关闭</strong></li>
</ol>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不会立即执行 finally，而阻塞在这里，等待服务端监听端口关闭</span></span><br><span class="line">f.channel().closeFuture().sync();</span><br></pre></td></tr></tbody></table></figure>

<ol start="7">
<li><strong>关闭 EventLoopGroup</strong></li>
</ol>
<p>关闭 Reactor 反应器线程组，同时会关闭内部的 subReactor 子反应 器线程，也会关闭内部的 Selector 选择器、内部的轮询线程以及负责查 询的所有的子通道。在子通道关闭后，会释放掉底层的资源，如 TCP Socket 文件描述符等。</p>
<p>至此，Netty 服务端已搭建完成，其中，最为重要的是装配到<strong>Pipeline 流水线中 handler,下面我们具体介绍。</strong></p>
<h3 id="Pipline-流水线"><a href="#Pipline-流水线" class="headerlink" title="Pipline 流水线"></a>Pipline 流水线</h3><p>每条通道内部都有一条流水线 pipline 来讲 Handler 装配起来来处理业务。Netty 的业务处理器流水线 ChannelPipeline 是基于*<em>责任链设计模式 *</em>来设计的，内部是一个双向链表结构，能够 支持动态地添加和删除 Handler 业务处理器。<br>Handler 涉及的环节有：数据包解码、业务处理、目标数据编码、数据包写入通道这几个部分，那么他们在 pipline 中的添加顺序是怎样的呢？<br>首先，Handler 有入站和出 站两种类型操作</p>
<ul>
<li>入站处理，触发的方向为：自底向上，Netty 的内部（如通道）到 ChannelInboundHandler 入站处理器。</li>
<li>出站处理，触发的方向为：自顶向下，从 ChannelOutboundHandler 出站处理器到 Netty 的内部（如通道）。</li>
</ul>
<p>按照这种方向来分，前面数据包解码、业务处理两个环节——属 于入站处理器的工作；后面目标数据编码、把数据包写到通道中两个 环节——属于出站处理器的工作。<br>入站处理器的流动次序是：从前到后。加在前面的， 执行也在前面；出站流水处理次序为从后向前，最后加入的出 站处理器，反而执行在最前面。这一点和 Inbound 入站处理次序是相反的。<br><strong>需要注意的点</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerA());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> OutboundHandlerA());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerB());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> OutboundHandlerB());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> InBoundHandlerC());</span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> OutboundHandlerC());</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/1164521/1651216115227-f9defdc5-886d-44a1-a50e-61e0c61a7966.png#clientId=u094a13e3-2a73-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u614b5f98&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=724&amp;originWidth=3828&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=191372&amp;status=done&amp;style=none&amp;taskId=ue0472cfa-7581-4cbc-bbd7-2f6ec5502b7&amp;title=" alt="image.png"><br>针对 InBoundHandlerC，处理完消息发送时，</p>
<ul>
<li>当调用 ctx.writeAndFlush(new Object())时代表 Object 从当前的 handler 流向 head 节点</li>
<li>当调用 ctx.channel().writeAndFlush(new Object())时代表 Object 从 tail 节点流向 head 节点。</li>
</ul>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/1164521/1651216412456-197b6ad3-8008-4654-b305-6d511d1a51f4.png#clientId=u094a13e3-2a73-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u6c21b4c0&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1444&amp;originWidth=3112&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=317106&amp;status=done&amp;style=none&amp;taskId=u222e7442-78c1-4ec5-b014-ce3aaefbff5&amp;title=" alt="image.png"><br>针对 RPC 框架的 Netty Server 的 pipline 来说，执行顺序为<br><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/1164521/1651226155922-921d33a5-63a7-43cc-955b-5161497538e5.png#clientId=u765db17b-2c3b-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u2502c4fb&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=844&amp;originWidth=3168&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=247573&amp;status=done&amp;style=none&amp;taskId=u0076bb5d-9e65-4ff7-b3fa-d4f3fff651e&amp;title=" alt="image.png"></p>
<h3 id="心跳-空闲检测"><a href="#心跳-空闲检测" class="headerlink" title="心跳-空闲检测"></a>心跳-空闲检测</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/webp/1164521/1651214594531-e9023b15-12cd-4279-9d69-b223ebbf9ee7.webp#clientId=u094a13e3-2a73-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=ua0ee798b&amp;margin=%5Bobject%20Object%5D&amp;originHeight=1218&amp;originWidth=1240&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u08fc06b3-877c-4492-a611-6c560c34852&amp;title=" alt=""><br>网络应用程序普遍会出现连接假死，连接假死的现象是：在某一端（服务端或者客户端）看来，底层的 TCP 连接已经断开了，但是应用程序并没有捕获到，因此会认为这条连接仍然是存在的，从 TCP 层面来说，只有收到四次握手数据包或者一个 RST 数据包，连接的状态才表示已断开。<br>连接假死会带来以下两大问题</p>
<ol>
<li>对于服务端来说，因为每条连接都会耗费 cpu 和内存资源，大量假死的连接会逐渐耗光服务器的资源，最终导致性能逐渐下降，程序奔溃。</li>
<li>对于客户端来说，连接假死会造成发送数据超时，影响用户体验。</li>
</ol>
<p>通常，连接假死由以下几个原因造成的</p>
<ol>
<li>应用程序出现线程堵塞，无法进行数据的读写。</li>
<li>客户端或者服务端网络相关的设备出现故障，比如网卡，机房故障。</li>
<li>公网丢包。公网环境相对内网而言，非常容易出现丢包，网络抖动等现象，如果在一段时间内用户接入的网络连续出现丢包现象，那么对客户端来说数据一直发送不出去，而服务端也是一直收不到客户端来的数据，连接就一直耗着。</li>
</ol>
<p>我们分别从客户端和服务端来解决这个问题<br><strong>服务端</strong><br>利用 Netty 自带的 IdleStateHandler 实现空闲检测，服务端只需要检测一段时间内，是否收到过客户端发来的数据即可，</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">IdleStateHandler</span><span class="params">(<span class="keyword">long</span> readerIdleTime, <span class="keyword">long</span> writerIdleTime,</span></span></span><br><span class="line"><span class="params"><span class="function">                        <span class="keyword">long</span> allIdleTime,TimeUnit unit)</span></span>{</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<ul>
<li>第一个参数是隔多久检查一下读事件是否发生，如果* channelRead() <em>方法超过 readerIdleTime 时间未被调用则会触发一个</em> READER_IDLE *的 <em>IdleStateEvent</em> 事件；</li>
<li>第二个参数是隔多久检查一下写事件是否发生，<em>writerIdleTime</em> 写空闲超时时间设定，如果 write() 方法超过 writerIdleTime 时间未被调用则会<em>WRITER_IDLE</em> 的* IdleStateEvent* 事件；</li>
<li>第三个参数是全能型参数，隔多久检查读写事件；</li>
<li>第四个参数表示当前的时间单位。</li>
</ul>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) {</span><br><span class="line">        IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">        <span class="keyword">if</span> (state == IdleState.READER_IDLE) {</span><br><span class="line">            log.info(<span class="string">"idle check happen, so close the connection"</span>);</span><br><span class="line">            ctx.close();</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>服务端当 15 秒内没有读到数据（客户端发来的心跳），则出发 userEventTriggered 事件，关闭假死的<br>channel 连接。</p>
<p><strong>客户端</strong><br>客户端同样添加 IdleStateHandler</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">当<span class="number">5</span>秒内没有主动远程调用，也就是没有写事件发生时候，触发userEventTriggered主动写并发送心跳数据包</span><br><span class="line"> <span class="comment">// 心跳发送</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent) {</span><br><span class="line">        IdleState state = ((IdleStateEvent) evt).state();</span><br><span class="line">        <span class="keyword">if</span> (state == IdleState.WRITER_IDLE) {</span><br><span class="line">            log.info(<span class="string">"write idle happen [{}]"</span>, ctx.channel().remoteAddress());</span><br><span class="line">            Channel channel = nettyClient.getChannel((InetSocketAddress) ctx.channel().remoteAddress());</span><br><span class="line">            RpcMessage rpcMessage = <span class="keyword">new</span> RpcMessage();</span><br><span class="line">            rpcMessage.setCodec(SerializerTypeEnum.PROTOSTUFF.getCode());</span><br><span class="line">            rpcMessage.setCompress(CompressTypeEnum.GZIP.getCode());</span><br><span class="line">            rpcMessage.setMessageType(RpcConstants.HEARTBEAT_REQUEST_TYPE);</span><br><span class="line">            rpcMessage.setData(RpcConstants.PING);</span><br><span class="line">            channel.writeAndFlush(rpcMessage).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>###</p>
<h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><p>无论是使用 Netty 还是原始的 Socket 编程，基于 TCP 通信的数据包格式均为二进制，协议指的就是客户端与服务端事先商量好的，每一个二进制数据包中每一段字节分别代表什么含义的规则。对于 XRPC 来说，使用了消息头+消息体 的方式制定私有协议。其格式如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>     <span class="number">1</span>     <span class="number">2</span>     <span class="number">3</span>     <span class="number">4</span>        <span class="number">5</span>     <span class="number">6</span>     <span class="number">7</span>     <span class="number">8</span>    <span class="number">9</span>          <span class="number">10</span>      <span class="number">11</span>     <span class="number">12</span>     <span class="number">13</span>    <span class="number">14</span>   <span class="number">15</span>   <span class="number">16</span></span><br><span class="line">+-----+-----+-----+-----+--------+----+----+----+------+-----------+-------+----- --+-----+-----+----+---+</span><br><span class="line">|   magic   code        |version |      full length    | messageType| codec|compress|    RequestId       |</span><br><span class="line">+-----------------------+--------+---------------------+-----------+-----------+-----------+------------+</span><br><span class="line">|                                                                                                       |</span><br><span class="line">|                                         body                                                          |</span><br><span class="line">|                                                                                                       |</span><br><span class="line">|                                        ... ...                                                        |</span><br><span class="line">+-------------------------------------------------------------------------------------------------------+</span><br><span class="line">4B  magic code（魔法数）</span><br><span class="line">1B version（版本）</span><br><span class="line">4B full length（消息长度）</span><br><span class="line">1B messageType（消息类型）</span><br><span class="line">1B compress（压缩类型）</span><br><span class="line">1B codec（序列化类型）</span><br><span class="line">4B  requestId（请求的Id）</span><br><span class="line">body（object类型数据）</span><br></pre></td></tr></tbody></table></figure>

<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/1164521/1651231638890-31866612-2803-4951-a68f-d2ce5d0414c1.png#clientId=u094a13e3-2a73-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=uc778bce2&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=744&amp;originWidth=4044&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=292662&amp;status=done&amp;style=none&amp;taskId=u852bc693-9d4c-410c-a238-3480158f8a9&amp;title=" alt="image.png"><br><strong>字段解释</strong><br><strong>1. magic（魔数)</strong><br>是通信双方协商的一个暗号，4 个字节，定义在 RpcConstants._MAGIC_NUMBER_。<br>魔数的作用是用于服务端在接收数据时先解析出魔数做正确性对比。如果和协议中的魔数不匹配，则认为是非法数据，可以直接关闭连接或采取其他措施增强系统安全性。<br>注意：这只是一个简单的校验，如果有安全性方面的需求，需要使用其他手段，例如 SSL/TLS。<br>魔数的思想在很多场景中都有体现，如 Java Class 文件开头就存储了魔数 OxCAFEBABE，在 JVM 加载 Class 文件时首先就会验证魔数对的正确性。<br><strong>2. version（版本)</strong><br>为了应对业务需求的变化，可能需要对自定义协议的结构或字段进行改动。不同版本的协议对应的解析方法也是不同的。所以在生产级项目中强烈建议预留协议版本这个字段。<br><strong>3. full length（消息长度)</strong><br>记录了整个消息的长度，这个字段是报文拆包的关键。<br><strong>4. messageType（消息类型)</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  消息类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">byte</span> REQUEST_TYPE = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">byte</span> RESPONSE_TYPE = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">byte</span> HEARTBEAT_REQUEST_TYPE = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">byte</span> HEARTBEAT_RESPONSE_TYPE = <span class="number">4</span>;</span><br></pre></td></tr></tbody></table></figure>

<p><strong>5. compress（压缩类型）</strong><br>序列化的字节流，还可以进行压缩，使得体积更小，在网络传输更快，但是同时会消耗 CPU 资源。<br>如果使用压缩效果好的序列化器，可以考虑不使用压缩</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 伪压缩器，等于不使用压缩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">DUMMY((<span class="keyword">byte</span>) <span class="number">0</span>, <span class="string">"dummy"</span>),</span><br><span class="line">GZIP((<span class="keyword">byte</span>) <span class="number">1</span>, <span class="string">"gzip"</span>),</span><br><span class="line">UNZIP((<span class="keyword">byte</span>) <span class="number">2</span>, <span class="string">"unzip"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>7. serialize（序列化类型）</strong><br>通过这个类型来确定使用哪种序列化方式，将字节流序列化成对应的对象。<br>序列化类型定义如下：</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HESSIAN((<span class="keyword">byte</span>) <span class="number">1</span>, <span class="string">"hessian"</span>),</span><br><span class="line">KRYO((<span class="keyword">byte</span>) <span class="number">2</span>, <span class="string">"kryo"</span>),</span><br><span class="line">PROTOSTUFF((<span class="keyword">byte</span>) <span class="number">3</span>, <span class="string">"protostuff"</span>);</span><br></pre></td></tr></tbody></table></figure>

<p><strong>8. requestId（请求的 Id）</strong><br>每个请求分配好请求 Id，这样响应数据的时候，才能对的上。使用 4 字节的 int 类型<br><strong>9. body</strong><br>body 里面放具体的数据，通常来说是请求的参数 request、响应的结果 response，再经过序列化、压缩后的字节数组。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcMessage</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * rpc message type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> messageType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * serialization type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> codec;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * compress type</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span> compress;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * request id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * request data</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcRequest</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">2176648719840392878L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt;[] parameterTypes;</span><br><span class="line">    <span class="keyword">private</span> Object[] parameters;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@Builder</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcResponse</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Serializable</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">715745410605631233L</span>;</span><br><span class="line">    <span class="keyword">private</span> String requestId;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * response code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * response message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * response body</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="编解码与粘包拆包"><a href="#编解码与粘包拆包" class="headerlink" title="编解码与粘包拆包"></a>编解码与粘包拆包</h3><blockquote>
<p>TCP/IP 协议，在用户数据量非常小的情况下，极端情况下，一个字节，该 TCP 数据包的有效载荷非常低，传递 100 字节的数据，需要 100 次 TCP 传送，100 次 ACK，在应用及时性要求不高的情况下，将这 100 个有效数据拼接成一个数据包，那会缩短到一个 TCP 数据包，以及一个 ack，有效载荷提高了，带宽也节省了<br>非极端情况，有可能两个数据包拼接成一个数据包，也有可能一个半的数据包拼接成一个数据包，也有可能两个半的数据包拼接成一个数据包<br>拆包和粘包是相对的，一端粘了包，另外一端就需要将粘过的包拆开，举个栗子，发送端将三个数据包粘成两个 TCP 数据包发送到接收端，接收端就需要根据应用协议将两个数据包重新组装成三个数据包，还有一种情况就是用户数据包超过了 mss(最大报文长度)，那么这个数据包在发送的时候必须拆分成几个数据包，接收端收到之后需要将这些数据包粘合起来之后，再拆开</p>
</blockquote>
<h4 id="编码-Encode"><a href="#编码-Encode" class="headerlink" title="编码 Encode"></a>编码 Encode</h4><p>编码器相对比较简单，按照协议定义的长度和值进行设置</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ByteBuf <span class="title">encode</span><span class="params">(RpcMessage rpcMessage, ByteBuf out)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        <span class="comment">// 4B magic code（魔数）</span></span><br><span class="line">        out.writeBytes(RpcConstants.MAGIC_NUMBER);</span><br><span class="line">        <span class="comment">// 1B version（版本）</span></span><br><span class="line">        out.writeByte(RpcConstants.VERSION);</span><br><span class="line">        <span class="comment">// 4B full length（消息长度）. 先空着，后面填。</span></span><br><span class="line">        out.writerIndex(out.writerIndex() + <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 1B messageType（消息类型）</span></span><br><span class="line">        <span class="keyword">byte</span> messageType = rpcMessage.getMessageType();</span><br><span class="line">        out.writeByte(messageType);</span><br><span class="line">        <span class="comment">// 1B codec（序列化类型）</span></span><br><span class="line">        out.writeByte(rpcMessage.getCodec());</span><br><span class="line">        <span class="comment">// 1B compress（压缩类型）</span></span><br><span class="line">        out.writeByte(CompressTypeEnum.GZIP.getCode());</span><br><span class="line">        <span class="comment">// 4B requestId（请求的Id）</span></span><br><span class="line">        out.writeInt(rpcMessage.getRequestId());</span><br><span class="line">        <span class="comment">// 写body，并获取数据长度</span></span><br><span class="line">        <span class="keyword">byte</span>[] bodyBytes = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> fullLength = RpcConstants.HEAD_LENGTH;</span><br><span class="line">        <span class="keyword">if</span> (messageType != RpcConstants.HEARTBEAT_REQUEST_TYPE</span><br><span class="line">                &amp;&amp; messageType != RpcConstants.HEARTBEAT_RESPONSE_TYPE) {</span><br><span class="line">            <span class="comment">// 序列化</span></span><br><span class="line">            String codecName = SerializerTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">            log.info(<span class="string">"encode name: [{}] "</span>, codecName);</span><br><span class="line">            Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span><br><span class="line">                    .getExtension(codecName);</span><br><span class="line">            bodyBytes = serializer.serialize(rpcMessage.getData());</span><br><span class="line">            <span class="comment">// 压缩</span></span><br><span class="line">            String compressName = CompressTypeEnum.getName(rpcMessage.getCompress());</span><br><span class="line">            Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span><br><span class="line">                    .getExtension(compressName);</span><br><span class="line">            bodyBytes = compress.compress(bodyBytes);</span><br><span class="line">            <span class="comment">// 总长度=消息头长度+body</span></span><br><span class="line">            fullLength += bodyBytes.length;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bodyBytes != <span class="keyword">null</span>) {</span><br><span class="line">            out.writeBytes(bodyBytes);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 记录当前写指针</span></span><br><span class="line">        <span class="keyword">int</span> writeIndex = out.writerIndex();</span><br><span class="line">        <span class="comment">// 写空出的4B full length（消息长度）</span></span><br><span class="line">        out.writerIndex(MAGIC_LENGTH + VERSION_LENGTH);</span><br><span class="line">        out.writeInt(fullLength);</span><br><span class="line">        <span class="comment">// 写指针复原</span></span><br><span class="line">        out.writerIndex(writeIndex);</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        log.error(<span class="string">"Encode request error!"</span>, e);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="解码-decode"><a href="#解码-decode" class="headerlink" title="解码 decode"></a>解码 decode</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ByteBuf 解码为RpcMessage</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(ByteBuf in)</span> </span>{</span><br><span class="line">    <span class="keyword">int</span> fullLength = in.readInt();</span><br><span class="line">    <span class="keyword">byte</span> messageType = in.readByte();</span><br><span class="line">    <span class="keyword">byte</span> codecType = in.readByte();</span><br><span class="line">    <span class="keyword">byte</span> compressType = in.readByte();</span><br><span class="line">    <span class="keyword">int</span> requestId = in.readInt();</span><br><span class="line">    RpcMessage rpcMessage = RpcMessage.builder()</span><br><span class="line">            .codec(codecType)</span><br><span class="line">            .requestId(requestId)</span><br><span class="line">            .compress(compressType)</span><br><span class="line">            .messageType(messageType).build();</span><br><span class="line">    <span class="comment">//心跳类型的请求、body 长度 0，不需要decode数据体</span></span><br><span class="line">    <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_REQUEST_TYPE) {</span><br><span class="line">        rpcMessage.setData(RpcConstants.PING);</span><br><span class="line">        <span class="keyword">return</span> rpcMessage;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_RESPONSE_TYPE) {</span><br><span class="line">        rpcMessage.setData(RpcConstants.PONG);</span><br><span class="line">        <span class="keyword">return</span> rpcMessage;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 获取数据体body的长度</span></span><br><span class="line">    <span class="keyword">int</span> bodyLength = fullLength - RpcConstants.HEAD_LENGTH;</span><br><span class="line">    <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[bodyLength];</span><br><span class="line">    in.readBytes(bs);</span><br><span class="line">    <span class="comment">// 反压缩</span></span><br><span class="line">    String compressName = CompressTypeEnum.getName(compressType);</span><br><span class="line">    Compress compress = ExtensionLoader.getExtensionLoader(Compress.class)</span><br><span class="line">            .getExtension(compressName);</span><br><span class="line">    bs = compress.decompress(bs);</span><br><span class="line">    <span class="comment">// 反序列化</span></span><br><span class="line">    String codecName = SerializerTypeEnum.getName(rpcMessage.getCodec());</span><br><span class="line">    Serializer serializer = ExtensionLoader.getExtensionLoader(Serializer.class)</span><br><span class="line">            .getExtension(codecName);</span><br><span class="line">    <span class="comment">// 设置decode后的消息体</span></span><br><span class="line">    Object object = serializer.deserialize(messageTypeMap.get(messageType), bs);</span><br><span class="line">    rpcMessage.setData(object);</span><br><span class="line">    <span class="keyword">return</span> rpcMessage;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="Netty-拆包器"><a href="#Netty-拆包器" class="headerlink" title="Netty 拆包器"></a>Netty 拆包器</h4><p>使用最为常用的<strong>基于长度域拆包器 LengthFieldBasedFrameDecoder</strong><br>只要自定义协议中包含长度域字段，均可以使用这个拆包器来实现应用层拆包。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> LengthFieldBasedFrameDecoder(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);</span><br></pre></td></tr></tbody></table></figure>

<p>maxFrameLength：指定包的最大长度，如果超过，直接丢弃<br>lengthFieldOffset： 描述长度的字段在第几个字节<br>lengthFieldLength：length 字段本身的长度(几个字节)<br>lengthAdjustment：包的总长度调整，去掉 lengthFieldOffset+lengthFieldLength<br>initialBytesToStrip： 跳过的字节数，之前的几个参数，已经足够识别出整个数据包了。但是很多时候，调用者只关心包的内容，包的头部完全可以丢弃掉，initialBytesToStrip 就是用来告诉 Netty，识别出整个数据包之后，截掉 initialBytesToStrip 之前的数据<br>因此，这里我们的拆包参数为</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> LengthFieldBasedFrameDecoder(RpcConstants.MAX_FRAME_LENGTH, <span class="number">5</span>, <span class="number">4</span>, -<span class="number">9</span>, <span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>

<p>因为我们还需要检测 魔数 和 版本号，所以 initialBytesToStrip=0，不能去除，当 魔数 和 版本号不符合规定时，拒绝非本协议连接。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Spliter</span> <span class="keyword">extends</span> <span class="title">LengthFieldBasedFrameDecoder</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spliter</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>(MAX_FRAME_LENGTH, MAGIC_LENGTH + VERSION_LENGTH, FULL_LENGTH_LENGTH,</span><br><span class="line">                -(MAGIC_LENGTH + VERSION_LENGTH + FULL_LENGTH_LENGTH), <span class="number">0</span>);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> maxFrameLength      指定包的最大长度，如果超过，直接丢弃</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldOffset   描述长度的字段在第几个字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthFieldLength   length 字段本身的长度(几个字节)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lengthAdjustment    包的总长度调整，去掉lengthFieldOffset+lengthFieldLength</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBytesToStrip 跳过的字节数，识别出整个数据包之后，截掉 initialBytesToStrip之前的数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Spliter</span><span class="params">(<span class="keyword">int</span> maxFrameLength, <span class="keyword">int</span> lengthFieldOffset, <span class="keyword">int</span> lengthFieldLength, <span class="keyword">int</span> lengthAdjustment, <span class="keyword">int</span> initialBytesToStrip)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(maxFrameLength, lengthFieldOffset, lengthFieldLength, lengthAdjustment, initialBytesToStrip);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        Object decoded = <span class="keyword">super</span>.decode(ctx, in);</span><br><span class="line">        ByteBuf frame = (ByteBuf) decoded;</span><br><span class="line">        <span class="keyword">if</span> (frame.readableBytes() &gt;= RpcConstants.HEAD_LENGTH) {</span><br><span class="line">            <span class="comment">//拒绝非本协议连接</span></span><br><span class="line">            <span class="keyword">if</span>(!checkMagicNumberAndVersion(in)){</span><br><span class="line">                ctx.channel().close();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> decoded;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取并检查魔数和版本是否符合规定</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMagicNumberAndVersion</span><span class="params">(ByteBuf in)</span> </span>{</span><br><span class="line">        <span class="comment">// 读取魔数</span></span><br><span class="line">        <span class="keyword">int</span> len = RpcConstants.MAGIC_NUMBER.length;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        in.readBytes(bytes);</span><br><span class="line">        <span class="comment">// 比较魔数是否符合规定，不符合抛出异常</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) {</span><br><span class="line">            <span class="keyword">if</span> (bytes[i] != RpcConstants.MAGIC_NUMBER[i]) {</span><br><span class="line">                log.error(<span class="string">"Unknown magic code: "</span> + Arrays.toString(bytes));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// 读取版本号</span></span><br><span class="line">        <span class="keyword">byte</span> version = in.readByte();</span><br><span class="line">        <span class="comment">// 比较版本号是否符合规定，不符合抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (version != RpcConstants.VERSION) {</span><br><span class="line">            log.error(<span class="string">"version isn't compatible"</span> + version);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="服务端业务-Handler"><a href="#服务端业务-Handler" class="headerlink" title="服务端业务 Handler"></a>服务端业务 Handler</h3><p>服务器端需要隔离 EventLoop（Reactor）线程和业务 线程。所以需要使用独立的、异步的线程任务去执行用户验证 的逻辑；而不在 EventLoop 线程中去执行用户验证的逻辑。<br>在默认情况下，Netty 的一个 EventLoop 实例会开启 2 倍 CPU 核数的内部线程。通常情况下，一个 Netty 服务器端会有几万或者 几十万的连接通道。也就是说，一个 EventLoop 内部线程会负责处理着 几万个或者上十万个通道连接的 IO 处理，而耗时的入站/出站处理越 多，就越会拖慢整个线程的其他 IO 处理，最终导致严重的性能问题。<br>因此这里我们是用一个独立的异步任务处理队列去处理业务逻辑。</p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DefaultEventExecutorGroup serviceHandlerGroup = <span class="keyword">new</span> DefaultEventExecutorGroup(</span><br><span class="line">            RuntimeUtil.getProcessorCount() * <span class="number">2</span>,</span><br><span class="line">            ThreadUtil.newNamedThreadFactory(<span class="string">"service-handler-group"</span>, <span class="keyword">false</span>)</span><br><span class="line">);</span><br><span class="line">ch.pipeline().addLast(serviceHandlerGroup, <span class="keyword">new</span> NettyServerHandler());</span><br></pre></td></tr></tbody></table></figure>

<p><strong>具体的 handler 业务逻辑</strong></p>
<figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">RpcMessage</span>&gt; </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceProvider serviceProvider;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServerHandler</span><span class="params">()</span> </span>{</span><br><span class="line">        serviceProvider = SingletonFactory.getInstance(ServiceProvider.class);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcMessage rpcMessage)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        log.info(<span class="string">"server receive msg: [{}] "</span>, rpcMessage);</span><br><span class="line">        <span class="keyword">byte</span> messageType = rpcMessage.getMessageType();</span><br><span class="line">        <span class="comment">// 如果是心跳消息，回复pong</span></span><br><span class="line">        <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_REQUEST_TYPE) {</span><br><span class="line">            rpcMessage.setMessageType(RpcConstants.HEARTBEAT_RESPONSE_TYPE);</span><br><span class="line">            rpcMessage.setData(RpcConstants.PONG);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            RpcRequest rpcRequest = (RpcRequest) rpcMessage.getData();</span><br><span class="line">            <span class="comment">// 根据请求的参数，找到对应的服务，反射执行方法</span></span><br><span class="line">            Object result = handle(rpcRequest);</span><br><span class="line">            log.info(String.format(<span class="string">"server get result: %s"</span>, result.toString()));</span><br><span class="line">            rpcMessage.setMessageType(RpcConstants.RESPONSE_TYPE);</span><br><span class="line">            <span class="keyword">if</span> (ctx.channel().isActive() &amp;&amp; ctx.channel().isWritable()) {</span><br><span class="line">                RpcResponse&lt;Object&gt; rpcResponse = RpcResponse.success(result, rpcRequest.getRequestId());</span><br><span class="line">                rpcMessage.setData(rpcResponse);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                RpcResponse&lt;Object&gt; rpcResponse = RpcResponse.fail(RpcResponseCodeEnum.FAIL);</span><br><span class="line">                rpcMessage.setData(rpcResponse);</span><br><span class="line">                log.error(<span class="string">"not writable now, message dropped"</span>);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ctx.writeAndFlush(rpcMessage).addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) {</span><br><span class="line">                    future.channel().close();</span><br><span class="line">                    log.error(<span class="string">"Fail!! Send response for request "</span> + rpcMessage.getRequestId());</span><br><span class="line"></span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    log.info(<span class="string">"Send response for request "</span> + rpcMessage.getRequestId());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"> <span class="function"><span class="keyword">private</span> Object <span class="title">handle</span><span class="params">(RpcRequest request)</span> </span>{</span><br><span class="line">    String className = request.getClassName();</span><br><span class="line">    String version = request.getVersion();</span><br><span class="line">    String serviceKey = ServiceUtil.makeServiceKey(className, version);</span><br><span class="line">    Object serviceBean = serviceProvider.getService(serviceKey);</span><br><span class="line">    <span class="keyword">if</span> (serviceBean == <span class="keyword">null</span>) {</span><br><span class="line">        log.error(<span class="string">"Can not find service implement with interface name: {} and version: {}"</span>, className, version);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> invokeCglib(request, serviceBean);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>解析 request 请求服务，在服务端注册服务的时候本地缓存一个服务 Map，从 Map 中找到服务，使用反射调用，并将结果返回，构造 response，并写入到 channal,最后 encode 发送</p>
<h2 id="使用-Netty-来实现-XPRC-客户端"><a href="#使用-Netty-来实现-XPRC-客户端" class="headerlink" title="使用 Netty 来实现 XPRC 客户端"></a>使用 Netty 来实现 XPRC 客户端</h2><h3 id="整体架构逻辑"><a href="#整体架构逻辑" class="headerlink" title="整体架构逻辑"></a>整体架构逻辑</h3><p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/1164521/1651244325781-e8658c69-83a8-4a8c-a4f9-9e57b44820fd.png#clientId=u094a13e3-2a73-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u56eeab43&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1252&amp;originWidth=4184&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=548410&amp;status=done&amp;style=none&amp;taskId=ue69f9fea-00be-48a5-8979-5f64a502d04&amp;title=" alt="image.png"><br>当用户要调用一个远程服务时，给该服务添加@RpcAutowired 注解，那么该服务将自动被替换为其动态代理类，代理中包含从调用-构造 RPC request- 获取连接 channel-编码-发送， 收到回复-拆包-解码-与发送的 request 关联 response-返回调用结果</p>
<h3 id="动态代理逻辑"><a href="#动态代理逻辑" class="headerlink" title="动态代理逻辑"></a>动态代理逻辑</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line">    <span class="keyword">private</span> String version;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectProxy</span><span class="params">(Class&lt;T&gt; clazz, String version)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">        <span class="keyword">this</span>.version = version;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取被调用服务的动态代理类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">createService</span><span class="params">(Class&lt;T&gt; interfaceClass, String version)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(</span><br><span class="line">                interfaceClass.getClassLoader(),</span><br><span class="line">                <span class="keyword">new</span> Class&lt;?&gt;[]{interfaceClass},</span><br><span class="line">                <span class="keyword">new</span> ObjectProxy&lt;T&gt;(interfaceClass, version)</span><br><span class="line">        );</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  客户端主要逻辑，包括发送请求，相应结果与请求的绑定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SneakyThrows</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>{</span><br><span class="line">        log.info(<span class="string">"client invoked method: [{}]"</span>, method.getName());</span><br><span class="line">        RpcRequest rpcRequest = RpcRequest.builder()</span><br><span class="line">                .methodName(method.getName())</span><br><span class="line">                .parameters(args)</span><br><span class="line">                .parameterTypes(method.getParameterTypes())</span><br><span class="line">                .className(method.getDeclaringClass().getName())</span><br><span class="line">                .requestId(UUID.randomUUID().toString())</span><br><span class="line">                .version(version)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">// 向服务端发送请求</span></span><br><span class="line">        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; completableFuture = (CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;) NettyClient.getInstance().sendRequest(rpcRequest);</span><br><span class="line">        <span class="comment">// 阻塞等待调用请求的结果，当 Netty Client 收到对应请求的回复时，future.complete（response）,完成相应</span></span><br><span class="line">        RpcResponse&lt;Object&gt; rpcResponse = completableFuture.get();</span><br><span class="line">        <span class="keyword">this</span>.check(rpcResponse, rpcRequest);</span><br><span class="line">        <span class="keyword">return</span> rpcResponse.getData();</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(RpcResponse&lt;Object&gt; rpcResponse, RpcRequest rpcRequest)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (rpcResponse == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcErrorMessageEnum.SERVICE_INVOCATION_FAILURE, <span class="string">"interfaceName"</span> + <span class="string">":"</span> + rpcRequest.getMethodName());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!rpcRequest.getRequestId().equals(rpcResponse.getRequestId())) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcErrorMessageEnum.REQUEST_NOT_MATCH_RESPONSE, <span class="string">"interfaceName"</span> + <span class="string">":"</span> + rpcRequest.getMethodName());</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rpcResponse.getCode() == <span class="keyword">null</span> || !rpcResponse.getCode().equals(RpcResponseCodeEnum.SUCCESS.getCode())) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RpcException(RpcErrorMessageEnum.SERVICE_INVOCATION_FAILURE, <span class="string">"interfaceName"</span> + <span class="string">":"</span> + rpcRequest.getMethodName());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">sendRequest</span><span class="params">(RpcRequest rpcRequest)</span> </span>{</span><br><span class="line">    <span class="comment">// 构造返回Future</span></span><br><span class="line">    CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="comment">// 通过负载均衡获取服务端地址</span></span><br><span class="line">    InetSocketAddress inetSocketAddress = serviceDiscovery.lookupService(rpcRequest);</span><br><span class="line">    <span class="comment">// Channel复用，获取之前连接过的或者断线重连得Netty Channel</span></span><br><span class="line">    Channel channel = getChannel(inetSocketAddress);</span><br><span class="line">    <span class="keyword">if</span> (channel.isActive()) {</span><br><span class="line">        <span class="comment">// 将请求放入未完成请求的Map缓存中,key为请求的唯一ID, value存放异步回调Future</span></span><br><span class="line">        pendingRpcRequests.put(rpcRequest.getRequestId(), resultFuture);</span><br><span class="line">        RpcMessage rpcMessage = RpcMessage.builder().data(rpcRequest)</span><br><span class="line">                .codec(SerializerTypeEnum.HESSIAN.getCode())</span><br><span class="line">                .compress(CompressTypeEnum.GZIP.getCode())</span><br><span class="line">                .requestId(REQUEST_ID.getAndIncrement())</span><br><span class="line">                .messageType(RpcConstants.REQUEST_TYPE).build();</span><br><span class="line">        <span class="comment">// 发送请求</span></span><br><span class="line">        channel.writeAndFlush(rpcMessage).addListener(<span class="keyword">new</span> ChannelFutureListener() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                <span class="keyword">if</span> (future.isSuccess()) {</span><br><span class="line">                    log.info(<span class="string">"client send message: [{}]"</span>, rpcMessage);</span><br><span class="line">                } <span class="keyword">else</span> {</span><br><span class="line">                    future.channel().close();</span><br><span class="line">                    resultFuture.completeExceptionally(future.cause());</span><br><span class="line">                    log.error(<span class="string">"Send failed:"</span>, future.cause());</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line"></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> resultFuture;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure>

<h3 id="Channel-复用与重连"><a href="#Channel-复用与重连" class="headerlink" title="Channel 复用与重连"></a>Channel 复用与重连</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取和指定地址连接的 channel，Channel复用，不用每次请求都重新连接</span></span><br><span class="line"><span class="comment"> * 如果获取不到，则新建连接（重连）</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inetSocketAddress 待连接scoket地址</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>: {<span class="doctag">@link</span> Channel} 获取到的连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Channel <span class="title">getChannel</span><span class="params">(InetSocketAddress inetSocketAddress)</span> </span>{</span><br><span class="line">    Channel channel = channelProvider.get(inetSocketAddress);</span><br><span class="line">    <span class="keyword">if</span> (channel == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="comment">// 阻塞等待，获取连接成功的channel</span></span><br><span class="line">        CompletableFuture&lt;Channel&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">        channel = doConnect(completableFuture,inetSocketAddress, MAX_RETRY).get();</span><br><span class="line">        channelProvider.set(inetSocketAddress, channel);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> channel;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 与服务端建立连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@SneakyThrows</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CompletableFuture&lt;Channel&gt; <span class="title">doConnect</span><span class="params">(CompletableFuture&lt;Channel&gt; completableFuture,InetSocketAddress inetSocketAddress, <span class="keyword">int</span> retry)</span> </span>{</span><br><span class="line">    bootstrap.connect(inetSocketAddress).addListener(future -&gt; {</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) {</span><br><span class="line">            log.info(<span class="string">"The client has connected [{}] successful!"</span>, inetSocketAddress.toString());</span><br><span class="line">            completableFuture.complete(((ChannelFuture) future).channel());</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (retry == <span class="number">0</span>) {</span><br><span class="line">            log.error(<span class="string">"the number of retries expired, connect fail. address:"</span>, inetSocketAddress);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="comment">// 当前是第几次重连</span></span><br><span class="line">            <span class="keyword">int</span> now = MAX_RETRY - retry + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 本次重连的时间间隔</span></span><br><span class="line">            <span class="keyword">int</span> delay = <span class="number">1</span> &lt;&lt; now;</span><br><span class="line">            log.warn(<span class="string">"connect fail, attempt to reconnect. retry:"</span> + now);</span><br><span class="line">            bootstrap.config().group().schedule(() -&gt;</span><br><span class="line">                    doConnect(completableFuture,inetSocketAddress, retry - <span class="number">1</span>), delay, TimeUnit.SECONDS);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> completableFuture;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Client-的-Pipline-流水线"><a href="#Client-的-Pipline-流水线" class="headerlink" title="Client 的 Pipline 流水线"></a>Client 的 Pipline 流水线</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ServiceDiscovery serviceDiscovery;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ChannelProvider channelProvider;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Bootstrap bootstrap;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> EventLoopGroup eventLoopGroup;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PendingRpcRequests pendingRpcRequests;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> NettyClient instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 线程安全的懒汉单例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NettyClient <span class="title">getInstance</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">synchronized</span> (NettyClient.class) {</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) {</span><br><span class="line">                    instance = <span class="keyword">new</span> NettyClient();</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">()</span> </span>{</span><br><span class="line">        eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        bootstrap.group(eventLoopGroup)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> LoggingHandler(LogLevel.INFO))</span><br><span class="line">                <span class="comment">// 连接超时时间</span></span><br><span class="line">                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">5000</span>)</span><br><span class="line">                <span class="comment">// TCP 底层心跳机制</span></span><br><span class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//要求高实时性，有数据发送时就马上发送，就设置为 true 关闭，如果需要减少发送次数减少网络交互，就设置为 false 开启</span></span><br><span class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</span><br><span class="line">                .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() {</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">5</span>, <span class="number">0</span>, TimeUnit.SECONDS));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> RpcEncoder());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> Spliter());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> RpcDecoder());</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> NettyClientHandler());</span><br><span class="line">                    }</span><br><span class="line">                });</span><br><span class="line">        <span class="keyword">this</span>.channelProvider = SingletonFactory.getInstance(ChannelProvider.class);</span><br><span class="line">        <span class="keyword">this</span>.serviceDiscovery = ExtensionLoader.getExtensionLoader(ServiceDiscovery.class).getExtension(<span class="string">"zk"</span>);</span><br><span class="line">        <span class="keyword">this</span>.pendingRpcRequests = SingletonFactory.getInstance(PendingRpcRequests.class);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h3 id="Client-接受响应的逻辑处理"><a href="#Client-接受响应的逻辑处理" class="headerlink" title="Client 接受响应的逻辑处理"></a>Client 接受响应的逻辑处理</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从服务端读到消息时的业务逻辑</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext channelHandlerContext, RpcMessage rpcMessage)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    log.info(<span class="string">"client receive msg: [{}]"</span>, rpcMessage);</span><br><span class="line">    <span class="keyword">byte</span> messageType = rpcMessage.getMessageType();</span><br><span class="line">    <span class="keyword">if</span> (messageType == RpcConstants.HEARTBEAT_RESPONSE_TYPE) {</span><br><span class="line">        log.info(<span class="string">"heart receive[{}]"</span>, rpcMessage.getData());</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (messageType == RpcConstants.RESPONSE_TYPE) {</span><br><span class="line">        RpcResponse&lt;Object&gt; rpcResponse = (RpcResponse&lt;Object&gt;) rpcMessage.getData();</span><br><span class="line">        <span class="comment">// 调用结果相应 绑定到对应的请求</span></span><br><span class="line">        pendingRpcRequests.complete(rpcResponse);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 未收到回复的请求</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>： dzgu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span>： 2022/4/25 22:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PendingRpcRequests</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt;&gt; PENDING_RESPONSE_FUTURES = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String requestId, CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; future)</span> </span>{</span><br><span class="line">        PENDING_RESPONSE_FUTURES.put(requestId, future);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将请求与调用结果响应绑定</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rpcResponse 收到服务端发来的调用结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">(RpcResponse&lt;Object&gt; rpcResponse)</span> </span>{</span><br><span class="line">        CompletableFuture&lt;RpcResponse&lt;Object&gt;&gt; future = PENDING_RESPONSE_FUTURES.remove(rpcResponse.getRequestId());</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != future) {</span><br><span class="line">            future.complete(rpcResponse);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<h4 id="如何将调用的结果-response-和请求-request-绑定呢？"><a href="#如何将调用的结果-response-和请求-request-绑定呢？" class="headerlink" title="如何将调用的结果 response 和请求 request 绑定呢？"></a>如何将调用的结果 response 和请求 request 绑定呢？</h4><p>1、 通过 channel 的 Attributekey 绑定</p>
<ol start="2">
<li>通 CompletableFuture 包装返回结，使用 request 和 response 统一的 ID 作为 key，服务端收到请求之后，将 RequestId 原封不动写到响应结果中。客户端收到响应结果后，拿出 RequestId 找到对应的 Future 并写入结果。</li>
</ol>
<p><img src= "/img/loading.gif" data-lazy-src="https://cdn.nlark.com/yuque/0/2022/png/1164521/1651247120029-4999acb6-a108-4367-b27b-7e91713e8139.png#clientId=u094a13e3-2a73-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=paste&amp;id=u3f547007&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=1764&amp;originWidth=3168&amp;originalType=url%E2%88%B6=1&amp;rotation=0&amp;showTitle=false&amp;size=566555&amp;status=done&amp;style=none&amp;taskId=u2d03d89b-e2a9-479b-bc3f-99dceb92cfe&amp;title=" alt="image.png"></p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a target="_blank" rel="noopener" href="https://juejin.cn/book/6844733738119593991">Netty 入门与实战：仿写微信 IM 即时通讯系统</a><br>Netty、Redis、Zookeeper 高并发实战</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">DongZhou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://dongzhougu.github.io/2022/05/12/yuque/yi-ru-he-yong-netty-shi-xian-gao-xing-neng-wang-luo-tong-xin/">https://dongzhougu.github.io/2022/05/12/yuque/yi-ru-he-yong-netty-shi-xian-gao-xing-neng-wang-luo-tong-xin/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://dongzhougu.github.io" target="_blank">欢迎来到，TWOTO 的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/XPRC/">XPRC</a><a class="post-meta__tags" href="/tags/Netty/">Netty</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button button--animated"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/DongZhouGu/DongZhouGu.github.io/img/wechat.png" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DongZhouGu/DongZhouGu.github.io/img/wechat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/DongZhouGu/DongZhouGu.github.io/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/DongZhouGu/DongZhouGu.github.io/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><meta name="referrer" content="no-referrer" /><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/12/yuque/er-wang-luo-chuan-shu-gao-xiao-xu-lie-hua-xie-yi-yu-shi-xian/"><img class="prev-cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-3.png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/DongZhouGu/DongZhouGu.github.io/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">二、网络传输高效序列化协议与实现</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/12/yuque/ling-ru-he-shi-xian-yi-ge-qing-liang-ji-rpc-kuang-jia/"><img class="next-cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-3.png" onerror="onerror=null;src='https://cdn.jsdelivr.net/gh/DongZhouGu/DongZhouGu.github.io/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">零、如何实现一个轻量级RPC框架？</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/12/yuque/xrpc-xiang-mu-fang-dubbo-readme/" title="XRPC项目(仿Dubbo)-README"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-2.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-12</div><div class="title">XRPC项目(仿Dubbo)-README</div></div></a></div><div><a href="/2022/05/12/yuque/qi-ji-cheng-spring-yu-springboot/" title="七、集成Spring与SpringBoot"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-12</div><div class="title">七、集成Spring与SpringBoot</div></div></a></div><div><a href="/2022/05/12/yuque/er-wang-luo-chuan-shu-gao-xiao-xu-lie-hua-xie-yi-yu-shi-xian/" title="二、网络传输高效序列化协议与实现"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-12</div><div class="title">二、网络传输高效序列化协议与实现</div></div></a></div><div><a href="/2022/05/12/yuque/wu-shi-yong-spi-shi-xian-ke-cha-ba-kuo-zhan-she-ji/" title="五、使用SPI实现可插拔扩展设计"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-12</div><div class="title">五、使用SPI实现可插拔扩展设计</div></div></a></div><div><a href="/2022/05/12/yuque/liu-qu-diao-yong-na-ge-fu-wu-qi-ni-fu-zai-jun-heng-ce-lue/" title="六、去调用哪个服务器呢？负载均衡策略"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-7.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-12</div><div class="title">六、去调用哪个服务器呢？负载均衡策略</div></div></a></div><div><a href="/2022/05/12/yuque/ling-ru-he-shi-xian-yi-ge-qing-liang-ji-rpc-kuang-jia/" title="零、如何实现一个轻量级RPC框架？"><img class="cover" src= "/img/loading.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-12</div><div class="title">零、如何实现一个轻量级RPC框架？</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "/img/loading.gif" data-lazy-src="/img/avatar.png" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/gh/DongZhouGu/DongZhouGu.github.io/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">DongZhou</div><div class="author-info__description">技术、效率、摄影</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">59</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/DongZhouGu"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="tencent://AddContact/?fromId=45&amp;fromSubId=1&amp;subcmd=all&amp;uin=1596586942&amp;website=www.oicqzone.com" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://github.com/DongZhouGu" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:gdz678@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Reactor-%E5%8F%8D%E5%BA%94%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">2.</span> <span class="toc-text">Reactor 反应器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95-Reactor-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">单 Reactor 单线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">单 Reactor 多线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A-Reactor-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">多 Reactor 多线程模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Netty-%E6%9D%A5%E5%AE%9E%E7%8E%B0-XPRC-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">3.</span> <span class="toc-text">使用 Netty 来实现 XPRC 服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NioEventLoop"><span class="toc-number">3.1.</span> <span class="toc-text">NioEventLoop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ServerBootstrap-%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E7%B1%BB"><span class="toc-number">3.2.</span> <span class="toc-text">ServerBootstrap 服务启动类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pipline-%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">3.3.</span> <span class="toc-text">Pipline 流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%83%E8%B7%B3-%E7%A9%BA%E9%97%B2%E6%A3%80%E6%B5%8B"><span class="toc-number">3.4.</span> <span class="toc-text">心跳-空闲检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.5.</span> <span class="toc-text">自定义协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%A7%A3%E7%A0%81%E4%B8%8E%E7%B2%98%E5%8C%85%E6%8B%86%E5%8C%85"><span class="toc-number">3.6.</span> <span class="toc-text">编解码与粘包拆包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A0%81-Encode"><span class="toc-number">3.6.1.</span> <span class="toc-text">编码 Encode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E7%A0%81-decode"><span class="toc-number">3.6.2.</span> <span class="toc-text">解码 decode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Netty-%E6%8B%86%E5%8C%85%E5%99%A8"><span class="toc-number">3.6.3.</span> <span class="toc-text">Netty 拆包器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%9A%E5%8A%A1-Handler"><span class="toc-number">3.7.</span> <span class="toc-text">服务端业务 Handler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Netty-%E6%9D%A5%E5%AE%9E%E7%8E%B0-XPRC-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">4.</span> <span class="toc-text">使用 Netty 来实现 XPRC 客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E9%80%BB%E8%BE%91"><span class="toc-number">4.1.</span> <span class="toc-text">整体架构逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%80%BB%E8%BE%91"><span class="toc-number">4.2.</span> <span class="toc-text">动态代理逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E8%AF%B7%E6%B1%82"><span class="toc-number">4.3.</span> <span class="toc-text">发送请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Channel-%E5%A4%8D%E7%94%A8%E4%B8%8E%E9%87%8D%E8%BF%9E"><span class="toc-number">4.4.</span> <span class="toc-text">Channel 复用与重连</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client-%E7%9A%84-Pipline-%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">4.5.</span> <span class="toc-text">Client 的 Pipline 流水线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client-%E6%8E%A5%E5%8F%97%E5%93%8D%E5%BA%94%E7%9A%84%E9%80%BB%E8%BE%91%E5%A4%84%E7%90%86"><span class="toc-number">4.6.</span> <span class="toc-text">Client 接受响应的逻辑处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86%E8%B0%83%E7%94%A8%E7%9A%84%E7%BB%93%E6%9E%9C-response-%E5%92%8C%E8%AF%B7%E6%B1%82-request-%E7%BB%91%E5%AE%9A%E5%91%A2%EF%BC%9F"><span class="toc-number">4.6.1.</span> <span class="toc-text">如何将调用的结果 response 和请求 request 绑定呢？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%EF%BC%9A"><span class="toc-number">5.</span> <span class="toc-text">参考：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/12/yuque/ba-xiang-mu-xing-neng-ce-shi/" title="八，项目性能测试">八，项目性能测试</a><time datetime="2022-05-12T06:42:22.000Z" title="发表于 2022-05-12 14:42:22">2022-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/12/yuque/qi-ji-cheng-spring-yu-springboot/" title="七、集成Spring与SpringBoot">七、集成Spring与SpringBoot</a><time datetime="2022-05-12T06:42:19.000Z" title="发表于 2022-05-12 14:42:19">2022-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/12/yuque/xrpc-xiang-mu-fang-dubbo-readme/" title="XRPC项目(仿Dubbo)-README">XRPC项目(仿Dubbo)-README</a><time datetime="2022-05-12T06:42:18.000Z" title="发表于 2022-05-12 14:42:18">2022-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/12/yuque/liu-qu-diao-yong-na-ge-fu-wu-qi-ni-fu-zai-jun-heng-ce-lue/" title="六、去调用哪个服务器呢？负载均衡策略">六、去调用哪个服务器呢？负载均衡策略</a><time datetime="2022-05-12T06:42:15.000Z" title="发表于 2022-05-12 14:42:15">2022-05-12</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/05/12/yuque/wu-shi-yong-spi-shi-xian-ke-cha-ba-kuo-zhan-she-ji/" title="五、使用SPI实现可插拔扩展设计">五、使用SPI实现可插拔扩展设计</a><time datetime="2022-05-12T06:42:14.000Z" title="发表于 2022-05-12 14:42:14">2022-05-12</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/material-4.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By DongZhou</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font-plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font-minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="chat_btn" type="button" title="rightside.chat_btn"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@3.8.4/source/js/utils.min.js"></script><script src="https://cdn.jsdelivr.net/npm/hexo-theme-butterfly@3.8.4/source/js/main.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly.js.org/source/selfjs/tw_cn.min.js?ver=3.8.4"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly.js.org/source/selfjs/localsearch.min.js?ver=3.8.4"></script><div class="js-pjax"><script>if (document.getElementsByClassName('mermaid').length) {
  if (window.mermaidJsLoad) mermaid.init()
  else {
    getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(() => {
      window.mermaidJsLoad = true
      mermaid.initialize({
        theme: 'default',
      })
      true && mermaid.init()
    })
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="true" data-click="true"></script><script>(function(d, w, c) {
    w.ChatraID = 'ZjXyfadNfHZ8yJGFm';
    var s = d.createElement('script');
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments);
    };
    s.async = true;
    s.src = 'https://call.chatra.io/chatra.js';
    if (d.head) d.head.appendChild(s);
})(document, window, 'Chatra');

if (true) {
  var chatBtnFn = () => {
    var chatBtn = document.getElementById("chat_btn")
    chatBtn.addEventListener("click", function(){
      Chatra('openChat')
    });
  }
  chatBtnFn()
} else {
  if (true) {
    function chatBtnHide () {
      Chatra('hide')
    }
    function chatBtnShow () {
      Chatra('show')
    }
  }
}</script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = [
  'title',
  '#config-diff',
  '#body-wrap',
  '#rightside-config-hide',
  '#rightside-config-show',
  '.js-pjax'
]

if (false) {
  pjaxSelectors.unshift('meta[property="og:image"]', 'meta[property="og:title"]', 'meta[property="og:url"]')
}

var pjax = new Pjax({
  elements: 'a:not([target="_blank"]):not([href="/talking/"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.removeEventListener('scroll', window.tocScrollFn)
  window.removeEventListener('scroll', scrollCollect)

  typeof preloader === 'object' && preloader.initLoading()
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // Analytics
  if (false) {
    MtaH5.pgv()
  }

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()

  typeof preloader === 'object' && preloader.endLoading()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>