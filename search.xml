<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>抢学术章的的辛酸泪</title>
      <link href="/2021/10/13/qiang-xue-zhu-zhang-de-xin-suan-lei/"/>
      <url>/2021/10/13/qiang-xue-zhu-zhang-de-xin-suan-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ul><li>2021-10-10更新，增加对人工认证的处理，重构代码</li></ul><p>由于问卷星更新了，里面加了阿里云智能验证的接口，所以之前的方法使用 selnium 不行了。</p><p>前端通过简单的判断就可以知道是不是 webdriver，解决的办法可以使用中间代理过滤掉 webdrvier 中的指纹信息，太过繁琐且不太好移植</p><p><strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span> 因此使用puppeteer的V2.0来了！</strong></p><p>项目地址： <a href="https://github.com/DongZhouGu/wjx-academic">https://github.com/DongZhouGu/wjx-academic</a></p><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><h3 id="新建python工程"><a href="#新建python工程" class="headerlink" title="新建python工程"></a>新建python工程</h3><p>建议使用 IDE Pycharm ， 工程目录如下</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201130161359.png" alt="image-20201130155501104"></p><h2 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h2><h3 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h3><ul><li>Python 3.5+</li><li>time</li><li>pyyaml</li><li>pypuppter(<a href="https://github.com/miyakogi/pyppeteer">https://github.com/miyakogi/pyppeteer</a>)</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install pyppeteer -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br></pre></td></tr></tbody></table></figure><p>也可以直接在 Pycharm 中安装此包</p><p>安装包完成后，接着，修改下图所示的</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201130161357.png" alt="image-20201130160506924"></p><p>的  <code>pyppeteer/_init_.py</code> 的文件，修改第14行代码为 </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__chromium_revision__ = '818858'</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201130161355.png" alt="image-20201130160601402"></p><p>😥 我就是因为这里的坑停滞了许久许久……………………,因为低版本的不支持Input.insertText 这个函数，没有这个函数 所有的中文字段都不能输入。</p><h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>第一次运行，会下载chromium，如果慢的话百度 <code>pyppeteer下载chromium慢</code></p><p>也可以下载我下载好的 放在下面的路径，<code>local-chromium</code> 文件夹没有的话请自己新建</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201130180242.png" alt="image-20201130175842517"></p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1SAkLTAnOjwo1Eg9_oIJ6fQ">https://pan.baidu.com/s/1SAkLTAnOjwo1Eg9_oIJ6fQ</a><br>提取码：s64h<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote><p>其他的设置和之前一样，在 <code>setting_config_yaml</code> 里设置，同样需要抓包软件，之前的chromdriver不需要了</p><p>详情见 <code>setting_config_yaml</code>中的解释</p><h2 id="附：Fiddler抓包软件"><a href="#附：Fiddler抓包软件" class="headerlink" title="附：Fiddler抓包软件"></a>附：Fiddler抓包软件</h2><p><a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a> 官网下载，也可以去垃圾网站下载快点<a href="http://www.downza.cn/soft/234727.html">http://www.downza.cn/soft/234727.html</a></p><p>下载完成一路安装完成，第一次打开 需要设置一下，以后就不用了</p><p>在Tools-Options里按如下勾选</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201111214924296.png" alt="image-20201111214924296"></p><p>设置完成，下面看一下怎么抓取授权</p><h3 id="抓取授权信息"><a href="#抓取授权信息" class="headerlink" title="抓取授权信息"></a>抓取授权信息</h3><p>首先在电脑微信上打开 抓取授权用的连链接（不要填写该问卷，否则失效），如下，先不要点击“一键登录”</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201111215813440.png" alt="image-20201111215137304"></p><p>先在Fidder软件内使用<code>Ctrl+X</code>快捷键清空页面，再在微信点击“<code>一键登录</code>”</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201111215137304.png" alt="image-20201111215720738"></p><p>在Fiddler中找到如下open.weixin.qq.com的这条记录，一般选择在<a href="http://www.wjx.cn下面这条">www.wjx.cn下面这条</a></p><p>在右边的Inspectors窗口内就有我们要的授权</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201111215720738.png" alt="image-20201111215813440"></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201111215950139.png" alt="image-20201111215950139"></p><p>复制好授权信息，替换<code>setting_config.yaml</code>中的url即可，其他设置见<code>setting_config.yaml</code>中的注释</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动化 </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注意力机制-Attention</title>
      <link href="/2021/01/14/zhu-yi-li-ji-zhi/"/>
      <url>/2021/01/14/zhu-yi-li-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="注意力机制-Attention"><a href="#注意力机制-Attention" class="headerlink" title="注意力机制-Attention"></a>注意力机制-Attention</h1><p>今天从四个方面来介绍注意力机制。首先是我们为什么要引入注意力机制，深度学习对于特征提取近年来取得了巨大的成功，但是他还有什么不足呢? 其次，我将从Encoder-Decoder框架（一种深度学习领域的研究模式，应用场景异常广泛）来介绍注意力机制；接着，总结一下目前注意力机制研究的的分类与应用；最后，切入到计算机视觉CV领域来介绍注意力机制。</p><h2 id="为什么要引入注意力机制？"><a href="#为什么要引入注意力机制？" class="headerlink" title="为什么要引入注意力机制？"></a>为什么要引入注意力机制？</h2><p>我们知道深度学习近年来在计算机视觉，自然语言处理等领域取得了巨大的成功，使用多层的深度神经网络逐层进行特征提取，获取更加高级的语义特征。但这样，伴随着两个缺陷</p><p>• <strong>计算能力的限制：</strong>当要记住很多“信息“，模型就要变得更复杂，然而目前计算能力依然是限制神经网络发展的瓶颈</p><p>• <strong>优化算法的限制：</strong>虽然局部连接、权重共享以及pooling等优化操作可以让神经网络变得简单一些，有效缓解模型复杂度和表达能力之间的矛盾；但是，如循环神经网络中的长距离以来问题，信息“记忆”能力并不高。卷积神经网络中，虽然能通过堆叠卷积层来获得更大的感受野，但不断地池化也会丢失长距离依赖的语义信息。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112090446506.png" alt="image-20210112090446506"></p><p>因此，注意力机制的出现就是为了解决这些问题。上图是一个图片描述系统，描述中画横线的描述就是主要通过图片中的白色光斑圈出区域进行特征提取得到的语义信息。深度学习从关注<strong>输入的全部</strong>，变成关注输入中<strong>的重点部分</strong>，从众多信息中选择出<strong>对当前任务目标更关键的信息</strong>。</p><h2 id="无注意力机制的Encoder-Decoder框架"><a href="#无注意力机制的Encoder-Decoder框架" class="headerlink" title="无注意力机制的Encoder-Decoder框架"></a>无注意力机制的Encoder-Decoder框架</h2><p>下图就是一个文本处理领域的Encoder-Decoder框架，它能够应用在许多任务中，如机器翻译文本摘要、问答系统、语音识别和图像描述等。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112091944854.png" alt="image-20210112091944854"></p><p>拿机器翻译来说，框架的目标是给定输入句子Source，期待通过Encoder-Decoder框架来生成目标句子Target。</p><p>拿中英文翻译来说</p><ul><li><p>编码器Encoder对输入的中文句子进行编码，通过非线性变换转化为中间语义表示C</p></li><li><p>解码器Decoder，其任务是根据句子Source的中间语义表示C和之前已经生成的历史信息</p><p>来生成 i 时刻要生成的单词</p></li></ul><p>但这样的框架其实是没有体现出“注意力模型”地，因为在生成目标句子的单词时，不论生成哪个单词，它们使用的输入句子Source的语义编码C都是一样的，没有任何区别。这意味着不论是生成哪个单词，y1,y2还是y3，其实句子Source中任意单词对生成某个目标单词 yi 来说影响力都是相同的，这很明显是没有注意力焦点的。</p><h2 id="增加注意力机制的Encoder-Decoder框架"><a href="#增加注意力机制的Encoder-Decoder框架" class="headerlink" title="增加注意力机制的Encoder-Decoder框架"></a>增加注意力机制的Encoder-Decoder框架</h2><p>下图是增加注意力机制的Encoder-Decoder框架，Attention模型的关键就是这里，即由固定的中间语义表示C换成了根据当前输出单词来调整的变化的Ci。</p><p>对于英汉翻译，如果输入是Tom chase Jerry，那么在生成中文单词汤姆时，其对应的语义表示C1，则对应着不同的 源句单词 的注意力分配概率分布。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112094554302.png" alt="image-20210112094554302"></p><p><strong>那么问题就来了，</strong>在生成目标句子某个单词，比如“汤姆”的时候，如何知道Attention模型所需要的输入句子单词注意力分配概率分布值呢？就是说“汤姆”对应的输入句子Source中各个单词的概率分布：(Tom,0.6)(Chase,0.2) (Jerry,0.2) 是如何得到的呢？</p><h2 id="如何获得注意力分配的概率分布？"><a href="#如何获得注意力分配的概率分布？" class="headerlink" title="如何获得注意力分配的概率分布？"></a>如何获得注意力分配的概率分布？</h2><p>这里拿RNN举例，Encoder采用RNN模型，Decoder也采用RNN模型，如下图所示</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112101206485.png" alt="image-20210112101206485"></p><p>下图可以较为便捷地说明注意力分配概率分布值的通用计算过程</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112101705623.png" alt="image-20210112101705623"></p><p>对于采用RNN的Decoder来说，在时刻 i，如果要生成yi单词，我们是可以知道在生成Yi之前的时刻 i-1时，隐层节点i-1时刻的输出值Hi-1的，而我们的目的是要计算生成Yi时输入句子中的单词“Tom”、“Chase”、“Jerry”对Yi来说的注意力分配概率分布，那么可以用Target输出句子i-1时刻的隐层节点状态Hi-1去一一和输入句子Source中每个单词对应的RNN隐层节点状态hj进行对比，即通过一些相似度计算方法来获得目标单词yi和每个输入单词对应的对齐可能性，然后函数F的输出经过 Softmax 进行归一化就得到了注意力的权重系数</p><h2 id="注意力机制的本质思想"><a href="#注意力机制的本质思想" class="headerlink" title="注意力机制的本质思想"></a>注意力机制的本质思想</h2><p>刚才，我们在说的注意力思想都是依附于Encoder-Decoder框架中，其实，注意力机制是一种思想，本质思想就是找到注意力分配的概率分布也就是注意力权重系数，可以用在很多模型框架中。现在我们将注意力机制抽象出来。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112102736028.png" alt="image-20210112110425144"></p><p>将Source中的构成元素想象成是由一系列的&lt;Key,Value&gt;数据对构成，此时给定Target中的某个元素Query，通过计算Query和各个Key的相似性或者相关性，得到每个Key对应Value的权重系数，然后对Value进行加权求和，即得到了最终的Attention数值。所以本质上Attention机制是对Source中元素的Value值进行加权求和，而Query和Key用来计算对应Value的权重系数。即可以将其本质思想改写为如下公式：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112102608815.png" alt="image-20210112110629123"></p><p>Attention机制的具体计算过程，如果对目前大多数方法进行抽象的话，可以将其归纳为三个过程：第一个阶段根据Query和Key计算两者的相似性或者相关性；第二个阶段对第一阶段的原始分值进行归一化处理； 第三个过程根据权重系数对Value进行加权求和。如下图所示</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112102728299.png" alt="image-20210112102736028"></p><h2 id="注意力机制的分类与应用"><a href="#注意力机制的分类与应用" class="headerlink" title="注意力机制的分类与应用"></a>注意力机制的分类与应用</h2><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112110425144.png" alt="image-20210112102608815"></p><h2 id="计算机视觉中的自注意力机制"><a href="#计算机视觉中的自注意力机制" class="headerlink" title="计算机视觉中的自注意力机制"></a>计算机视觉中的自注意力机制</h2><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112110629123.png" alt="image-20210112111248613"></p><p>之前讲的都是针对Source和Target的注意力机制，近年来计算视觉领域用的多的还是自注意力机制，也是从NLP中借鉴过来的思想，因此仍然保留了Query, Key和Value等名称。下图是self-attention的基本结构，feature maps是由基本的深度卷积网络得到的特征图</p><p>自上而下分为三个分支，分别是query、key、value。计算分为三步</p><ul><li><p>将query和每个key进行<strong>相似度计算得到权重</strong>，常用的相似度函数有点积，感知机等</p></li><li><p>一般是使用一个softmax函数<strong>对这些权重进行归一化</strong>；</p></li><li><p>将权重和相应的键值value进行<strong>加权求和</strong>得到最后的attention。</p></li></ul><p>可以看出，步骤和刚才我们抽象出来的注意力机制思想的基本步骤是一致的，只是这里的source和target是一个东西，我们需要找到特征图内部的重点。可能是通道上的，也可能是空间上的。下面就从空间和通道两个维度向大家介绍一些经典的CV领域的注意力模型。</p><h3 id="空间注意力模型—Non-Local"><a href="#空间注意力模型—Non-Local" class="headerlink" title="空间注意力模型—Non-Local"></a>空间注意力模型—Non-Local</h3><p>我们知道卷积网络通过多层的网络来捕获更强的语义信息与更大的感受野，但这样的学习效率太低，需要通过不断加深的网络堆叠来实现，于是作者提出了一个泛化、简单、可直接嵌入到当前网络的<strong>非局部操作算子</strong>，这个简单的注意力模块可以方便的加入网络中，来学习长距离的依赖关系。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112111248613.png" alt="image-20210112102728299"></p><p>作者这个思想是来源于传统的基于图片滤波领域的非局部均值滤波操作思想（核心思想是在计算每个像素位置输出时候，不再只和邻域计算，而是和图像中所有位置计算相关性）</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112111401100.png" alt="image-20210112111401100"></p><p>下图是 non-local block的示意图，从左到右也对应了之前说的query,key,value，通过1x1的卷积来映射特征与通道数降维。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112111502943.png" alt="image-20210112111502943"></p><h3 id="空间注意力模型—STN"><a href="#空间注意力模型—STN" class="headerlink" title="空间注意力模型—STN"></a>空间注意力模型—STN</h3><p>空间区域注意力可以理解为让神经网络在看哪里。通过注意力机制，将原始图片中的空间信息变换到另一个空间中并保留了关键信息，在很多现有的方法中都有使用这种网络，自己接触过的一个就是ALPHA Pose。spatial transformer其实就是注意力机制的实现，因为训练出的spatial transformer能够找出图片信息中需要被关注的区域，同时这个transformer又能够具有旋转、缩放变换的功能，这样图片局部的重要信息能够通过变换而被框盒提取出来。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112111845810.png" alt="image-20210112111845810"></p><p>STN主要分为三个模块</p><ul><li><p><strong>Localisation net</strong>由全连接和卷积构成的网络，它输入U，输出变化参数Θ，这个参数用来映射U和V的坐标关系</p></li><li><p><strong>Grid generator</strong>根据V中的坐标点和变化参数Θ，计算出U中的坐标点。在Sampler中根据这个坐标在U中找到像素值，这样子来填充V</p></li><li><p><strong>Sampler</strong>填充V，根据Grid generator得到的一系列坐标和原图U来填充，因为计算出来的坐标可能为小数，使用双线性或其他插值方法。</p></li></ul><h3 id="通道注意力模型—SENet"><a href="#通道注意力模型—SENet" class="headerlink" title="通道注意力模型—SENet"></a>通道注意力模型—SENet</h3><p> <strong>这篇论文就是通道维度（channel-wise）增加注意力机制</strong>，关键的两个操作是squeeze和excitation，所以论文把这个attention结构命名为SE block，SE block是为了显式地实现特征通道的的相互依赖关系，就是说就是<strong>通过自动学习的方式（用另外一个新的神经网络实现）获取到每个特征通道的重要程度，然后用这个重要程度去给每一个特征通道赋予一个权重值，从而让神经网络重点关注某些特征通道</strong>，即提升对当前任务有用的特征通道并抑制对当前任务用处不大的特征通道。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20210112111958685.png" alt="image-20210112111958685"></p><p><strong>第一个操作：Squeeze</strong>，通过全局池化（global pooling），将每个通道的二维特征（H×W）压缩为1个实数，论文是通过平均值池化的方式实现。这属于空间维度的一种特征压缩，因为这个实数是根据二维特征所有值算出来的，所以在某种程度上具有全局的感受野，通道数保持不变，所以通过squeeze操作后变为1×1×C。</p><p><strong>第二个操作：excitation</strong>，通过参数来为每个特征通道生成一个权重值，这个权重值是如何生成就很关键了，论文是通过两个全连接层组成一个Bottleneck结构去建模通道间的相关性，并输出和输入特征同样数目的权重值。</p><p><strong>第三个操作：Scale</strong>，将前面得到的归一化权重加权到每个通道的特征上。论文中的方法是用乘法，逐通道乘以权重系数，完成再通道维度上引入attention机制。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 注意力机制就是通过学习得到一个权重分布，再把这个权重分布施加到原来的特征上面。以获取更多所需要关注目标的细节信息，而抑制其他无用信息。是一种资源分配方式。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 注意力机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mask R-CNN 演变笔记</title>
      <link href="/2020/12/19/maskrcnn/"/>
      <url>/2020/12/19/maskrcnn/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>目标检测分为两种方法：一阶段法和两阶段法。一阶段法的代表算法为YOLO,SSD，具有速度快的优势。所谓两阶段法就是先找出图像中的region proposal ，再分别对每个proposal进行回归和分类，它的优势则是精确度高，Mask R-CNN则是这一方法，从一开始的R-CNN到Fast R-CNN再到Faster R-CNN，FPN，到最后的Mask R-CNN，演进过程中的一些方法依旧用于其他的机器视觉任务中，所以这个路线中的网络架构和方法非常值得我们去学习。</p><h2 id="Sliding-windows"><a href="#Sliding-windows" class="headerlink" title="Sliding windows"></a>Sliding windows</h2><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230310.png" alt="2020121901"></p><p>这是目标检测的最早期的算法——滑动窗口法，很好理解，就是固定一个窗口(不同的size 和长宽比)从左向右，从上到下的去滑动，对每个窗口的图像进行目标识别与分类。这种方法可想而知，非常耗时。</p><h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><p>2014年的时候随着深度学习的兴起，R-CNN横空出世了。与滑动窗口法不同，这里使用selective search 这种 region proposal method 来提取图像的RoIs (感兴趣区域)。这里我们可以看下这种方法的思想，相似的像素、纹理或者是灰度等会被归为一个区域，并得到这样的很多个小bounding box后，在对这些bounding box进行归类或者说聚类，使得整个图像的RoIs保持在2000个左右。</p><p>下面我们来看下R-CNN的网络结构图</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230311.png" alt="image-20201218110258776"></p><p>总结一下网络结构图：</p><ul><li>首先对图像使用 selective search方法，得到图像的RoIs</li><li>根据 RoIs 在原图像中裁剪，得到2k个不同尺寸的小image，再wrap 成相同尺寸大小的img</li><li>把相同大小的2k个img分别喂入CNN中提取特征，并使用SVM对目标进行分类，使用 bbox reg对 bounding Box进行定位。</li></ul><p><strong>SVM我们都知道是如何分类的，那么bounding box是如何通过回归来确定呢？</strong></p><p>首先我们可以看到这个一张飞机的图像，红色是候选的建议框，绿色是ground truth真实框，这个回归就是去学习这种变换映射关系，一个bounding box 通常由四个坐标表示，x,y坐标以及长宽w,h。通过映射公式可以看出 在 x,y上做平移变换，在 w,h做缩放变换，经过整理，就可以得到目标的优化对象。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230312.png" alt="image-20201218110519892"></p><p>现在，我们来回顾一下R-CNN的贡献和缺点</p><ul><li>使用selective search 来做region proposal</li><li>使用 SVM分类，boundingbox reg 回归</li></ul><p>缺点：</p><ul><li>selective search依旧费时</li><li>分别把2k个RoI图像送入CNN提取特征，存在大量重复计算</li></ul><h2 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h2><p>Fast R-CNN出现就是为了解决这个重复计算的问题，它最大的贡献就是把region proposal method 直接应用到feature map上，因此只要对一张图片喂入CNN中进行特征提取，然后把selective search得到的RoI位置映射到feature map(这点作者在论文中已经证明, feature map 中的位置和原图像的位置具有对应关系)。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219231350.png" alt="image-20201219231330001"></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219231347.png" alt="image-20201219231337746"></p><p>总结一下Fast R-CNN的网络结构：</p><ul><li>对原图像应用selective search 得到2k 个region proposal </li><li>把原图像喂入CNN网络提取特征，得到feature map</li><li>把region proposal 映射到feature map 中，并对这2k 个proposal 的进行ROI pooling 来 wrap 到固定的尺寸</li><li>使用CNN网络来做分类和回归</li></ul><p><strong>那么 ROI pooling 到底是怎么实现的呢？</strong></p><p>比如一个 8 x 8 的 feature map ,我们要在这个feature map上得到ROI，并且进行ROI pooling到2x2大小的输出。</p><p>假设一个ROI的 bounding box 为(0,3,7,8) , 将它划分为2x2的网格，因为ROI的长宽除以2是不能整除的，所以会出现每个格子大小不一样的情况,对每个区域进行最大池化，就可以得到 2 x 2 的的输出。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219231535.png" alt="image-20201219231532213"></p><p>因此，总结一下，Fast R-CNN的贡献和缺点</p><ul><li>从 feature map 得到proposal 而不是 images</li><li>使用ROI pooling 把所有RoI特征图 wrap到固定尺寸</li></ul><p>缺点：</p><ul><li>selective search的时间消耗问题仍未解决</li></ul><h2 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h2><p>Faster R-CNN出现就是为了解决selective search 耗时的问题，这里使用了RPN深度学习网络来生成region proposal，下面先看一下算法的网络架构图。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230315.png" alt="image-20201218124454510"></p><p>总结一下Faster R-CNN的网络结构：</p><ul><li>把原图像喂入CNN网络提取特征，得到feature map</li><li>在得到的 feature map上用RPN网络获取 region proposal ，大大降低时间。</li><li>将得到的 region proposal 在映射到特征图中，并做ROI pooling 来wrap成相同的尺寸</li><li>使用CNN网络来做分类和回归</li></ul><p><strong>那么，RPN是怎么实现的呢？</strong></p><p>这里就不得不说到 anchor的思想，下图是一个256维度的8 x 8  的 feature map，其中每一个特征点都对应原图像的一块区域，先用3 x 3 的卷积来获得更大的感受野 ，然后每个特征点用 9 种 anchor 来尝试框住目标区域（3种size ,3 抓种长宽比）。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230314.png" alt="1"></p><p>通过这张图可以看出 8 x 8 x 256 的特征图 经过两次1 x 1的卷积 变成两部分： 8 x 8 x 9 x 2 分数和 8 x 8 x 9 x 4 坐标偏移</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230317.png" alt="image-20201218132245129"></p><p>总结一下</p><ul><li>Training：在训练的时候，通过 IoU(交并比)来训练，这样的特征可能对应这样的anchor</li><li>Predition：预测的时候，对feature map 中的每一个特征点做预测，得到分数</li></ul><p>至此，Faster R-CNN可以说是解决了之前存在的问题，但是依旧有优化的空间。</p><p>其中有两个点值得优化：</p><ul><li><p>Faster R-CNN 是单尺度的目标检测框架，会遗漏一些小的目标。</p></li><li><p>ROI pooling 优化为ROI Align</p></li></ul><h2 id="FPN"><a href="#FPN" class="headerlink" title="FPN"></a>FPN</h2><p>FPN 的全称是 Feature Pyramid Network  特征金字塔网络，我们首先来看下单尺度的框架</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230318.png" alt="image-20201218140731596"></p><p>其中，高分辨率的特征比如 112x112x128的特征</p><ul><li>精确地空间位置信息</li><li>低维度的语义信息</li></ul><p>低分辨率的特征比如7x7x512的特征</p><ul><li>高维度的语义信息</li><li>模糊的空间位置信息</li></ul><p>而单尺度的框架最后只用了7x7x512 这样的低分辨率特征，丢失了精确地空间位置信息，因此，多尺度的特征金字塔解决了这个问题！</p><p>下面看一下FPN的简单结构图：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230319.png" alt="image-20201218141837927"></p><p>总结一下结构，由三部分组成：</p><ul><li>自下而上的下采样，提取高维度的语义特征</li><li>自上而下的上采样(双线性插值或者反卷积)</li><li>横向连接，保留空间位置信息</li></ul><p>FPN只是一种思路，具体可以有很多种网络架构实现，比如 VGG，AlexNet，ResNet，下图是使用 ResNet 实现的FPN，也是Mask R-CNN中使用的架构，下面是架构图。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230320.png" alt="image-20201218142911230"></p><h2 id="FPN-Faster-R-CNN"><a href="#FPN-Faster-R-CNN" class="headerlink" title="FPN+Faster R-CNN"></a>FPN+Faster R-CNN</h2><p>将 FPN 加入到 Faster R-CNN 网络架构中，变成下图 </p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230321.png" alt="image-20201218143049566"></p><p>那么问题来了，对于多尺度的特征图，选择哪个feature map来切出这些ROI区域呢？</p><p>实际上，我们会选择最合适的尺度的feature map来切ROI。具体来说，我们通过一个公式来决定宽w和高h的ROI到底要从哪个来切：</p><p>$k=\left\lfloor k_{0}+\log _{2}(\sqrt{w h} / 224)\right\rfloor$</p><p>先来说一下这几个参数的意义</p><ul><li>224 : 使用ImageNet预训练数据集的图片尺寸</li><li>k0 : 当 RoI 为 224 x 224 时所在的层级，作者将 k0 设置为 4，也就是ROI从P4中切出来</li></ul><p>比如一个112 x 112 的ROI ，k=3， 这个ROI 应该从 P3 从切出来，这很好理解，分辨率越小的RoI应该从feature map 尺寸较大的层级切出来，因为这样的feature map 保留了更多的空间位置信息。</p><h2 id="Mask-R-CNN"><a href="#Mask-R-CNN" class="headerlink" title="Mask R-CNN"></a>Mask R-CNN</h2><p>FPN+Faster R-CNN+Mask Prediction = Mask R-CNN</p><p>下图是 Mask R-CNN的网络结构图</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230323.png" alt="image-20201219200434400"></p><p>总结一下结构：</p><ul><li>backbone：ResNet-FPN 用于特征提取，另外，ResNet还可以是：ResNet-50,ResNet-101,ResNeXt-50,ResNeXt-101；</li><li>Head：包括边界框识别（分类和回归）+ mask预测。头部结构见下图</li></ul><p>现在细看一下Mask branch 是怎么做的</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230322.png" alt="image-20201218155313527"></p><p>可以从结构图中看出，前面经过POIAlign后的ROI被送入两个分支</p><ul><li><p>第一个分支用来分类和回归boundingbox</p></li><li><p>第二个mask分支来做实例分割，通过全卷积和反卷积最后得到一个28x 28 x80 的mask，要注意这里的80个通道指分类的类别数为80，后面我们也会通过损失函数来详细说明</p></li></ul><p>至此，从R-CNN到Mask R-CNN的演变之路就讲完了，下面我们讲一下MaskR-CNN的一些细节。</p><h3 id="ROIAlign"><a href="#ROIAlign" class="headerlink" title="ROIAlign"></a>ROIAlign</h3><p>首先是ROIAlign，我们知道之前的网络对ROI  wrap到固定的尺寸都是使用的ROI Pooling，那么这样做有什么缺点呢？这里我们通过一组图来说明</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230324.png" alt="image-20201219212431878"></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230327.png" alt="image-20201219215855556"></p><p>可以看出，原本的original ROI 最后变成2x2的ROI一共经历了两次取整的操作，存在误差，会影响bounding box的位置准备度</p><ul><li>第一次取整： regional ROI可能是浮点数，首先是取整，将ROI和feature map 对齐</li><li>第二次取整：regional ROI 可能不能被最后的2x 2整除，比如原本的ROI尺寸是5x4，那么如图，最终分成的2x2ROI并不是每一块都是一样大的，进行了不均等的切分。</li></ul><p>这两次取整操作，对于大目标来说还好，但是小目标的包围框坐标对这样的误差还是很敏感的，为了解决这个问题，ROIAlign出现了，下面是结构图</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230326.png" alt="image-20201219213447848"></p><ul><li>针对第一次取整，这里图画的本来就是和feature map对准的，其实不是对准的也没关系，ROI Align保留这里的浮点数，不做取整操作</li><li>针对第二次取整，我们可以看到7x5的ROI被平均的分成了四份，针对每一小份又使用了4个采样点对这块区域进行采样，那么是如何采样的呢？首先4个采样点就是把这一小份平均分成四份，每一小份的值由双线性插值方法获得。因此每一小份最终可以由4份得到，在对这样的特征图进行MaxPooling , 最终得到2x2的ROI，这里为什么用4个采样点呢，其实用1个也是可以的，作者在实验中证明4个采样点的效果最好。</li><li>双线性插值我们可以从图中直观地看到，其实就是做了三次线性插值</li></ul><h3 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h3><p>Mask R-CNN的损失函数有些特殊，我们来看一下公式</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230325.png" alt="image-20201219212439319"></p><p>其中的Lmask 就是Mask branch的损失，这个mask就是指每个像素是0还是1，用来区分背景，做分割</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230328.png" alt="image-20201219220637393"></p><p>这个7x7的mask,其中每一个像素都有80个通道，每一个通道都对应一个类别，通常 对于实例分割来说，都是使用softmax做分类，得出这80个类别分别的概率，然后再去区别是目标还是背景，因此需要做两个任务，一个是类别预测，一个是mask预测.</p><p>而Mask RCNN是怎么做的呢，它不做类别预测，只做mask预测，通过其他分支的类别预测选择对应的80个通道中一个，比如是狗，那么只要对这7x7个像素预测，这个像素是目标狗还是背景，输出一个0或1的二值mask，因此只做了一个任务mask预测</p><p>相比之前的softmax方法，有两个优势</p><ul><li>避免了类间竞争，使得性能提高</li><li>类别预测和mask预测分开来做，解耦</li></ul><h3 id="Application"><a href="#Application" class="headerlink" title="Application"></a>Application</h3><p><strong>Instance segmentation</strong></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230329.png" alt="image-20201219224118913"></p><p><strong>Human pose estimation</strong></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201219230330.png" alt="image-20201219224141806"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 目标检测 </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode总结—二叉树的构造</title>
      <link href="/2020/12/13/er-cha-shu-de-gou-zao/"/>
      <url>/2020/12/13/er-cha-shu-de-gou-zao/</url>
      
        <content type="html"><![CDATA[<p>二叉树是面试中常见的题目类型，这里，针对leetcode前200道题中的二叉树相关问题进行总结与思考，力求烂熟于心，能根据题目名回忆起题目的具体描述，进而用简洁的语言描述出算法的核心。具体的题目答案可打开leetcode查看历史提交记录。</p><p><a href="https://www.yuque.com/ugdongzhou/sivpgk/b97740505d86178e7fe86be2088b42c2/edit">二叉树的遍历</a>是上一篇的内容，可先回顾；本篇主要整理二叉树的构造相关题目和思路。</p><h2 id="二叉树的构造（binary-tree-traversal）"><a href="#二叉树的构造（binary-tree-traversal）" class="headerlink" title="二叉树的构造（binary-tree-traversal）"></a>二叉树的构造（binary-tree-traversal）</h2><blockquote><p>给定二叉树特定遍历下的结果，构造出原本的二叉树。</p></blockquote><p>解题关键在于定位出根节点，划分出左右子树，然后 递归 构建左右子树</p><h2 id="1-从前序与中序遍历序列构造二叉树"><a href="#1-从前序与中序遍历序列构造二叉树" class="headerlink" title="1.从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">1.从前序与中序遍历序列构造二叉树</a></h2><p>该题是leetcode105题，medium难度，一句话题干描述：从前序与中序遍历序列构造二叉树。</p><p><strong>解决方案1(复杂度高)：</strong> 先序遍历的顺序是根节点，左子树，右子树。中序遍历的顺序是左子树，根节点，右子树。</p><p>所以我们只需要根据先序遍历得到根节点，然后在中序遍历中找到根节点的位置，它的左边就是左子树的节点，右边就是右子树的节点。生成左子树和右子树就可以递归的进行了。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201214104215.png" alt="image.png"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>{</span><br><span class="line">    <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(preorder.length==<span class="number">0</span>||inorder.length==<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(preorder.length!=inorder.length){</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入错误"</span>);</span><br><span class="line">    }</span><br><span class="line">    TreeNode root=<span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;preorder.length;i++){</span><br><span class="line">        <span class="keyword">if</span>(preorder[<span class="number">0</span>]==inorder[i]){</span><br><span class="line">            <span class="keyword">int</span>[] pre_left=Arrays.copyOfRange(preorder,<span class="number">1</span>,i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span>[] pre_right=Arrays.copyOfRange(preorder,i+<span class="number">1</span>,preorder.length);</span><br><span class="line">            <span class="keyword">int</span>[] in_left=Arrays.copyOfRange(inorder,<span class="number">0</span>,i);</span><br><span class="line">            <span class="keyword">int</span>[] in_right=Arrays.copyOfRange(inorder,i+<span class="number">1</span>,inorder.length);</span><br><span class="line">            root.left=buildTree(pre_left,in_left);</span><br><span class="line">            root.right=buildTree(pre_right,in_right);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201214104223.gif" alt="image"></p><p>二叉树相关的很多问题的解决思路都有分治法的思想在里面。我们复习一下分治法的思想：把原问题拆解成若干个与原问题结构相同但规模更小的子问题，待子问题解决以后，原问题就得以解决，“归并排序”和“快速排序”都是分治法思想的应用，其中“归并排序”先无脑地“分”，在“合”的时候就麻烦一些；“快速排序”开始在 partition 上花了很多时间，即在“分”上使了很多劲，然后就递归处理下去就好了，没有在“合”上再花时间。</p><p><strong>解决方案2(优化版)：</strong> 以上的解法，存在两个问题：</p><p>1.在中序遍历中找到根节点的位置每次都得遍历中序遍历的数组去寻找，我们可以用一个HashMap把中序遍历数组的每个元素的值和下标存起来，这样寻找根节点的位置就可以直接得到；</p><p>2.每次递归都分割数组，占用空间大，其次只要传数组索引。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201214104245.png" alt="image.png"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] preorder;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; hash;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> prelength=preorder.length;</span><br><span class="line">        <span class="keyword">int</span> inlength=inorder.length;</span><br><span class="line">        <span class="keyword">if</span>(prelength!=inlength){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入错误"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.preorder=preorder;</span><br><span class="line">        <span class="keyword">this</span>.hash=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inlength;i++){</span><br><span class="line">            hash.put(inorder[i],i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>,prelength-<span class="number">1</span>,<span class="number">0</span>,inlength-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">     <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> preleft,<span class="keyword">int</span> preright, <span class="keyword">int</span> inleft,<span class="keyword">int</span> inright)</span> </span>{</span><br><span class="line">         <span class="comment">// 因为是递归调用的方法，按照国际惯例，先写递归终止条件</span></span><br><span class="line">         <span class="keyword">if</span>(preleft&gt;preright || inleft&gt;inright){</span><br><span class="line">             <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">         }</span><br><span class="line">         TreeNode root=<span class="keyword">new</span> TreeNode(preorder[preleft]);</span><br><span class="line">         <span class="keyword">int</span> inindex=hash.get(preorder[preleft]);</span><br><span class="line">         root.left=buildTree(preleft+<span class="number">1</span>,inindex-inleft+preleft,inleft,inindex-<span class="number">1</span>);</span><br><span class="line">         root.right=buildTree(inindex-inleft+preleft+<span class="number">1</span>,preright,inindex+<span class="number">1</span>,inright);</span><br><span class="line">         <span class="keyword">return</span> root;</span><br><span class="line">     }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-从中序与后序遍历序列构造二叉树"><a href="#2-从中序与后序遍历序列构造二叉树" class="headerlink" title="2.从中序与后序遍历序列构造二叉树"></a><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">2.从中序与后序遍历序列构造二叉树</a></h2><p>该题是 leetcode106 题，medium 难度，一句话题干描述：从中序和后序遍历序列构造二叉树。</p><p><strong>解决方案：</strong> 和上一题类似，中序遍历的顺序是左子树，根节点，右子树，后序遍历的顺序是左子树，右子树，根节点。所以我们只需要根据后序遍历得到根节点，然后在中序遍历中找到根节点的位置，它的左边就是左子树的节点，右边就是右子树的节点。生成左子树和右子树就可以递归的进行了。下面是更详细的图解。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201214104301.png" alt="image"></p><p>直接套用上一题的解决方案2,使用哈希表和传数组索引的方法降低复杂度。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] postorder;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer,Integer&gt; hash;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] inorder, <span class="keyword">int</span>[] postorder)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> inLen=inorder.length;</span><br><span class="line">        <span class="keyword">int</span> postLen=postorder.length;</span><br><span class="line">        <span class="keyword">if</span>(inLen!=postLen){</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"输入错误"</span>);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">this</span>.hash=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.postorder=postorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;inLen;i++){</span><br><span class="line">            hash.put(inorder[i],i);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> buildTree(<span class="number">0</span>,inLen-<span class="number">1</span>,<span class="number">0</span>,postLen-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span> inLeft,<span class="keyword">int</span> inRight,<span class="keyword">int</span> postLeft,<span class="keyword">int</span> postRight)</span> </span>{</span><br><span class="line">        <span class="comment">//递归终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(inLeft&gt;inRight || postLeft&gt;postRight){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(postorder[postRight]);</span><br><span class="line">        <span class="keyword">int</span> inindex=hash.get(postorder[postRight]);</span><br><span class="line">        root.left=buildTree(inLeft,inindex-<span class="number">1</span>,postLeft,inindex-inLeft+postLeft-<span class="number">1</span>);</span><br><span class="line">        root.right=buildTree(inindex+<span class="number">1</span>,inRight,inindex-inLeft+postLeft,postRight-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="3-将有序数组转换为二叉搜索树"><a href="#3-将有序数组转换为二叉搜索树" class="headerlink" title="3.将有序数组转换为二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">3.将有序数组转换为二叉搜索树</a></h2><p>该题是 leetcode108 题，easy难度，一句话题干描述：根据升序数组，恢复一棵高度平衡的BST🌲。</p><p><strong>解决方案：</strong>BST的中序遍历是升序的，因此本题等同于<strong>根据中序遍历的序列恢复二叉搜索树</strong>。因此我们可以以升序序列中的任一个元素作为根节点，以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样得到的树就是一棵二叉搜索树啦～ 又因为本题要求高度平衡，因此我们需要选择升序序列的中间元素作为根节点。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201214104317.png" alt="微信图片_20201209103046.png"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> dfs(nums,<span class="number">0</span>,nums.length-<span class="number">1</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(left&gt;right){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> mid=left+(right-left)/<span class="number">2</span>;</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line">        root.left=dfs(nums,left,mid-<span class="number">1</span>);</span><br><span class="line">        root.right=dfs(nums,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="4-有序链表转换二叉搜索树"><a href="#4-有序链表转换二叉搜索树" class="headerlink" title="4.有序链表转换二叉搜索树"></a><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree/">4.有序链表转换二叉搜索树</a></h2><p>该题是 leetcode109 题，medium 难度，一句话题干描述：根据升序数组，恢复一棵高度平衡的BST🌲。</p><p><strong>解决方案：</strong>与上一题 leetcode108 题类似，唯一的不同在与数据结构，上一题是数组，这一题是链表，链表找中间根节点可以使用快慢指针法。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201214104334.png" alt="image"></p><p>下面的代码与上图不同的地方是 构建左BST时没有断开链表，那处理的时候就是要改一下寻找中间节点的代码。<code>while (fast != null &amp;&amp; fast.next != null) ---》   while(fast!=tail &amp;&amp; fast.next!=tail)</code></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedListToBST</span><span class="params">(ListNode head)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        ListNode tail=head;</span><br><span class="line">        <span class="keyword">while</span>(tail!=<span class="keyword">null</span>){</span><br><span class="line">            tail=tail.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> dfs(head,tail);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> TreeNode <span class="title">dfs</span><span class="params">(ListNode head,ListNode tail)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(head==tail){</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        }</span><br><span class="line">        ListNode node=findMid(head,tail);</span><br><span class="line">        TreeNode root=<span class="keyword">new</span> TreeNode(node.val);</span><br><span class="line">        root.left=dfs(head,node);</span><br><span class="line">        root.right=dfs(node.next,tail);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">findMid</span><span class="params">(ListNode head,ListNode tail)</span> </span>{</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=tail &amp;&amp; fast.next!=tail){</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="5-平衡二叉树"><a href="#5-平衡二叉树" class="headerlink" title="5. 平衡二叉树"></a><a href="https://leetcode-cn.com/problems/balanced-binary-tree/">5. 平衡二叉树</a></h2><p>该题是 leetcode110 题，easy难度，一句话题干描述：给定一个二叉树，判断它是否是高度平衡的二叉树。</p><p>前两题要求构建的是平衡二叉树，我们的处理办法是从中间节点开始左右分别构建，这样的二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 ，也称作平衡二叉树。</p><p><strong>解决方案(暴力法自顶向下)：</strong>构造一个获取当前节点最大深度的方法<code>depth(root)</code> ，通过比较此子树的左右子树的最大高度差<code>abs(depth(root.left) - depth(root.right))</code>，来判断此子树是否是二叉平衡树。若树的所有子树都平衡时，此树才平衡。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(depth(root.left)-depth(root.right))&lt;<span class="number">2</span> &amp;&amp; isBalanced(root.left) &amp;&amp; isBalanced(root.right);</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            <span class="keyword">return</span> Math.max(depth(root.left),depth(root.right))+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">//上面的方法要不断递归左右子树, 有重复部分,所以时间复杂度为O(n2)</span></span><br></pre></td></tr></tbody></table></figure><p><strong>解决方案(优化法自底向上)：</strong>后序遍历，左右中，从底至顶返回子树最大高度，若判定某子树不是平衡树则 “剪枝” ，直接向上返回。</p><p><strong>NOTE:</strong>参数的话为传入的节点指针，就没有其他参数需要传递了，返回值要返回传入节点为根节点树的深度。</p><p><strong>那么如何标记左右子树是否差值大于1呢。</strong></p><p>如果当前传入节点为根节点的二叉树已经不是二叉平衡树了，还返回高度的话就没有意义了。所以如果已经不是二叉平衡树了，可以返回-1 来标记已经不符合平衡树的规则了。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isBalanced</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> dfs(root)!=-<span class="number">1</span>;      </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 返回以该节点为根节点的二叉树的高度，如果不是二叉搜索树了则返回-1</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span></span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=dfs(root.left);<span class="comment">// 说明左子树已经不是二叉平衡树</span></span><br><span class="line">        <span class="keyword">if</span>(left==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right=dfs(root.right);<span class="comment">// 说明右子树已经不是二叉平衡树</span></span><br><span class="line">        <span class="keyword">if</span>(right==-<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left-right)&lt;<span class="number">2</span>?Math.max(left,right)+<span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>参考资料：leetcode题解，感谢这些大佬的配图以及易懂的语言！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>iCAN (BMVC2018)</title>
      <link href="/2020/12/10/lun-wen-ican-bmvc2018/"/>
      <url>/2020/12/10/lun-wen-ican-bmvc2018/</url>
      
        <content type="html"><![CDATA[<h1 id="文献-iCAN-Instance-Centric-Attention-Network-for-Human-Object-Interaction-Detection"><a href="#文献-iCAN-Instance-Centric-Attention-Network-for-Human-Object-Interaction-Detection" class="headerlink" title="文献-iCAN: Instance-Centric Attention Network for Human-Object Interaction Detection"></a>文献-iCAN: Instance-Centric Attention Network for Human-Object Interaction Detection</h1><ul><li>概述：人或物体实例的外观包含上下文线索，利用这些信息可以注意到图像中可以促进交互预测的部分。为了利用这些线索，研究者提出了一个以实例为中心的注意力模块，学习根据每个实例的外观动态突出显示图像中的区域。这种基于注意力的网络允许研究者选择性地聚合与识别 HOI相关的特征。在InteractNet上做的改进,达到了 V-COCO 45.3%。</li><li>关键词：注意力机制</li><li>论文地址：<a href="https://www.yuque.com/ugdongzhou/io8kmc/1661063">https://www.yuque.com/ugdongzhou/io8kmc/1661063</a></li><li>源码:  <a href="https://github.com/vt-vl-lab/iCAN">https://github.com/vt-vl-lab/iCAN</a>  和DRG2020同属<a href="https://github.com/vt-vl-lab">vt-vl-lab</a>实验室</li></ul><h2 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h2><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134848.png" alt="image-20201209144401235"></p><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul><li>引入了一个以实例为中心的注意力模块，它允许网络动态突出信息区域以改进 HOI 检测。</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134849.png" alt="image-20201209152307633"></p><ol><li><p>在由h或者o计算a的分数时，不止用它们本身的特征，还concat了context特征，contex特征则是根据intance产生的注意力在原图的特征上得到的。</p><p>给定图像的卷积特征（以灰色显示）和人/物体边界框（以红色显示），iCAN 模块提取实例</p><p>（人类）或（物体）的外观特征以及来自以实例为中心的注意力映射的特征。为了计算注意力映射，研究者使用 512 个通道的 bottleneck 来评估嵌入空间中的相似性【37】【38】。具体来说，研究者用 1×1 卷积和实例外观特征将图像特征嵌入到全连接层中。这里的 res5 表示第五个残差块，GAP 表示全局平均池化层，FC 表示全连接层。</p></li><li><p>同样需要判断h和o是否有关系，该方法是用空间的interaction pattern（neural-motif中有这个）并concat human instance计算得到的。</p></li></ol><p>【37】 Ashish V aswani, Noam Shazeer, Niki Parmar, Jakob Uszkoreit, Llion Jones, Aidan N Gomez,<br>Łukasz Kaiser, and Illia Polosukhin. Attention is all you need. In NIPS, 2017.</p><p>【38】Xiaolong Wang, Ross Girshick, Abhinav Gupta, and Kaiming He. Non-local neural networks. InCVPR, 2018.</p><h2 id="【38】Non-local-Neural-Networks-facebook"><a href="#【38】Non-local-Neural-Networks-facebook" class="headerlink" title="【38】Non-local Neural Networks -facebook"></a>【38】Non-local Neural Networks -facebook</h2><h4 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h4><p>计算机视觉领域注意力机制的开篇之作。提出了non-local operations，使用自注意力机制建立远程依赖。 - local operations: 卷积(对局部领域)、recurrent(对当前/前一时刻)等操作。 - non-local operations用于捕获长距离依赖（long-range dependencies），即如何建立图像上两个有一定距离的像素之间的联系，如何建立视频里两帧的联系，如何建立一段话中不同词的联系等。 Non-local operations 在计算某个位置的响应时，是考虑所有位置 features 的加权——所有位置可以是空间的，时间的，时空的。</p><h4 id="网络结构-1"><a href="#网络结构-1" class="headerlink" title="网络结构"></a>网络结构</h4><p>给出非局部操作的具体公式。首先在深度学习中非局部操作可以表达为：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134850.png" alt="img"></p><p>i是输出特征图的其中一个位置，通用来说这个位置可以是时间、空间和时空。j是所有可能位置的索引，x是输入信号，可以是图像、序列和视频，通常是特征图。y是和x尺度一样的输出图，f是配对计算函数，计算第i个位置和其他所有位置的相关性，g是一元输入函数，目的是进行信息变换，C(x)是归一化函数，保证变换前后整体信息不变。以上是一个非常泛化的公式，结合神经网络特定，需要考虑其具体形式。首先 g 由于是一元输出，比较简单，我可以采用1x1卷积，代表线性嵌入，其形式为</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134851.png" alt="img"></p><p>对于f，前面我们说过其实就是计算两个位置的相关性，那么第一个非常自然的函数是Gaussian</p><p><strong>(1) Gaussian</strong></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134852.png" alt="img"></p><p>对两个位置进行点乘，然后通过指数映射，放大差异。</p><p><strong>(2) Embedded Gaussian</strong></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134853.png" alt="img"></p><p>前面的gaussian形式是直接在当前空间计算，而(2)更加通用，在嵌入空间中计算高斯距离。这里：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134854.png" alt="img"></p><p>完整考虑是：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134855.png" alt="img"></p><p><strong>(3) Dot product</strong></p><p>考虑一种最简单的非局部操作形式：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134856.png" alt="image-20201210134835084"></p><p>其中C(x)=N，像素个数。可以看出(2) (3)的主要区别是是否含有激活函数softmax。</p><p><strong>(4) Concatenation</strong></p><p>参考 Relation Networks可以提出：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134857.png" alt="image-20201210134825277"></p><h4 id="Non-local-Block"><a href="#Non-local-Block" class="headerlink" title="Non-local Block"></a>Non-local Block</h4><p>前面是基本的非局部操作算子，利用这些算子，下面开始构造成模块。 </p><p><img src="https:////upload-images.jianshu.io/upload_images/11692737-fd82671ed688abb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/140/format/webp" alt="img"></p><p>可以看出，上面构造成了残差形式。上面的做法的<strong>好处是可以随意嵌入到任何一个预训练好的网络中，因为只要设置W_z初始化为0，那么就没有任何影响，然后在迁移学习中学习新的权重。这样就不会因为引入了新的模块而导致预训练权重无法使用</strong>。</p><p>下面结合具体实例分析：。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201210134858.png" alt="img"></p><p>由于我们考虑的是图片，故可以直接设置T=1，或者说不存在。</p><ul><li><p>首先网络输入是X= (batch, h, w, 1024) ，经过Embedded Gaussian中的两个嵌入权重变换<img src="https://img2018.cnblogs.com/blog/1470684/201911/1470684-20191118183432078-1492031547.png" alt="W_{\theta}"> ， <img src="https://img2018.cnblogs.com/blog/1470684/201911/1470684-20191118183432402-981947511.png" alt="W_{\phi}">得到(batch, h, w, 512), (batch, h, w, 512), 其实这里的目的是降低通道数，减少计算量；</p></li><li><p>然后分别对这两个输出进行reshape操作，变成(batch, hw, 512)，后对这两个输出进行矩阵乘(其中一个要转置)，计算相似性，得到(batch, hw, hw),</p></li><li><p>然后在第2个维度即最后一个维度上进行softmax操作，得到(batch, hw, hw), 意这样做就是空间注意力，相当于找到了当前图片或特征图中每个像素与其他所有位置像素的归一化相关性；也就是得到0~1的weights，这里就是我们需要的 Self-attention 系数；</p></li><li><p>然后将 g 也采用一样的操作，先通道降维，然后reshape；然后和 (batch, hw, hw)进行矩阵乘，得到(batch, h, w, 512), 即将空间注意力机制应用到了所有通道的每张特征图对应位置上，本质就是输出的每个位置值都是其他所有位置的加权平均值，通过softmax操作可以进一步突出共性。最后经过一个1x1卷积恢复输出通道，保证输入输出尺度完全相同。</p></li></ul><p>代码地址  <a href="https://github.com/AlexHex7/Non-local_pytorch">https://github.com/AlexHex7/Non-local_pytorch</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HOI人物交互检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实验室gpu管理</title>
      <link href="/2020/12/09/shu-lxd-gpu/"/>
      <url>/2020/12/09/shu-lxd-gpu/</url>
      
        <content type="html"><![CDATA[<p><strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f642.png?v8">🙂</span>在线阅读地址</strong>：项目地址：<a href="https://github.com/DongZhouGu/shu-lxd-gpu">https://github.com/DongZhouGu/shu-lxd-gpu</a></p><p><strong><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f642.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f642.png?v8">🙂</span>在线阅读地址</strong>：<a href="https://dongzhougu.github.io/shu-lxd-gpu/">https://dongzhougu.github.io/shu-lxd-gpu/</a></p><h2 id="GPU-容器使用说明"><a href="#GPU-容器使用说明" class="headerlink" title="GPU 容器使用说明"></a>GPU 容器使用说明</h2><blockquote><p>容器目前只在新到的服务器上(2* 2080Ti)实施</p><p>但可以访问  <span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8">👉</span><a href="https://dongzhougu.github.io/lxd-nvidia-smi/signin.html">显卡监控界面</a> 看到实验室所有显卡的使用情况</p></blockquote><p>使用LXD创建和管理容器，多位同学可以同时使用校园网远程访问服务器；</p><p>操作简单，你可以像是用自己的电脑一样使用容器。</p><h2 id="请根据角色，阅读以下具体的使用文档"><a href="#请根据角色，阅读以下具体的使用文档" class="headerlink" title="请根据角色，阅读以下具体的使用文档"></a>请根据角色，阅读以下具体的使用文档</h2><h2 id="point-right-For-用户"><a href="#point-right-For-用户" class="headerlink" title=":point_right:For 用户"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8">👉</span><a href="doc/用户.md">For 用户</a></h2><h2 id="point-right-For-管理员"><a href="#point-right-For-管理员" class="headerlink" title=":point_right:For 管理员"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8">👉</span><a href="doc/管理员.md">For 管理员</a></h2><h2 id="point-right-显卡监控界面"><a href="#point-right-显卡监控界面" class="headerlink" title=":point_right:显卡监控界面"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f449.png?v8">👉</span><a href="https://dongzhougu.github.io/lxd-nvidia-smi/signin.html">显卡监控界面</a></h2><blockquote><p>监控界面的登入用户名与密码，见下方文档</p><p><a href="https://shimo.im/docs/yVpDgvJKqPwtvpqr">https://shimo.im/docs/yVpDgvJKqPwtvpqr</a></p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HICO-DET数据集</title>
      <link href="/2020/12/03/lun-wen-hico-det-shu-ju-ji/"/>
      <url>/2020/12/03/lun-wen-hico-det-shu-ju-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="文献-Learning-to-Detect-Human-Object-Interaction"><a href="#文献-Learning-to-Detect-Human-Object-Interaction" class="headerlink" title="文献-Learning to Detect Human-Object Interaction"></a>文献-Learning to Detect Human-Object Interaction</h1><ul><li>概述：2018年由密歇根大学和华盛顿大学共同提出HICO-DET数据集</li><li>关键词：数据集</li><li>论文地址：<a href="https://www.yuque.com/ugdongzhou/io8kmc/1661139">https://www.yuque.com/ugdongzhou/io8kmc/1661139</a></li><li>数据集:  <a href="http://www-personal.umich.edu/~ywchao/hico/">http://www-personal.umich.edu/~ywchao/hico/</a></li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201206213325.png" alt="image-20201203205600371"></p><h2 id="主要贡献"><a href="#主要贡献" class="headerlink" title="主要贡献"></a>主要贡献</h2><ul><li>提出一个新的benchmark ——HICO-DET，提供了超过150,000个标注后的人类-物体组合，包含600个HOI类别，即每个HOI类别平均250个组合实例。</li><li>提出了基于人-物区域的卷积神经网络HO-RCNN。分两步，1. 使用最先进的人体和物体检测器生成人体-物体区域对的proposal；2. 将每个人-物框proposal送入CNN，以生成HOI分类分数。</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201206213222.png" alt="image-20201203211834372"></p><h2 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h2><h4 id="三个benchmark"><a href="#三个benchmark" class="headerlink" title="三个benchmark"></a>三个benchmark</h4><ul><li>Full—— 所有的600个HOI分类</li><li>Rare ——138个HOI类别（少于10个训练实例）</li><li>Non-Rare ——462个HOI类别（大于等于10个训练实例）</li></ul><h4 id="两种评估方法"><a href="#两种评估方法" class="headerlink" title="两种评估方法"></a>两种评估方法</h4><ul><li>Known Object ——定位HOI(如人-自行车对)以及区分互动(如“骑行”)</li><li>Default setting ——更有挑战性，图像中可能不存在目标对象</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 科研 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HOI人物交互检测 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图解HTTP总结</title>
      <link href="/2020/11/29/tu-jie-http-zong-jie/"/>
      <url>/2020/11/29/tu-jie-http-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014.</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129164421.jpg" alt="image-20201129163253254"></p><h2 id="一-、基础概念"><a href="#一-、基础概念" class="headerlink" title="一 、基础概念"></a>一 、基础概念</h2><h3 id="请求和响应报文"><a href="#请求和响应报文" class="headerlink" title="请求和响应报文"></a>请求和响应报文</h3><p>客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。</p><p>请求报文结构：</p><ul><li>第一行是包含了请求方法、URL、协议版本；</li><li>接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。</li><li>一个空行用来分隔首部和内容主体 Body</li><li>最后是请求的内容主体</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">GET</span> <span class="string">http://www.example.com/</span> <span class="string">HTTP/1.1</span></span><br><span class="line"><span class="attr">Accept:</span> <span class="string">text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9</span></span><br><span class="line"><span class="attr">Accept-Encoding:</span> <span class="string">gzip,</span> <span class="string">deflate</span></span><br><span class="line"><span class="attr">Accept-Language:</span> <span class="string">zh-CN,zh;q=0.9,en;q=0.8</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="string">max-age=0</span></span><br><span class="line"><span class="attr">Host:</span> <span class="string">www.example.com</span></span><br><span class="line"><span class="attr">If-Modified-Since:</span> <span class="string">Thu,</span> <span class="number">17</span> <span class="string">Oct</span> <span class="number">2019 07:18:26 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">If-None-Match:</span> <span class="string">"3147526947+gzip"</span></span><br><span class="line"><span class="attr">Proxy-Connection:</span> <span class="string">keep-alive</span></span><br><span class="line"><span class="attr">Upgrade-Insecure-Requests:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">User-Agent:</span> <span class="string">Mozilla/5.0</span> <span class="string">xxx</span></span><br><span class="line"><span class="string">//空行</span></span><br><span class="line"><span class="string">param1=1&amp;param2=2</span></span><br></pre></td></tr></tbody></table></figure><p>响应报文结构：</p><ul><li>第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了</li><li>接下来多行也是首部内容，包含很多首部字段</li><li>一个空行分隔首部和内容主体</li><li>最后是响应的内容主体</li></ul><figure class="highlight yaml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">HTTP/1.1</span> <span class="number">200</span> <span class="string">OK</span></span><br><span class="line"><span class="attr">Age:</span> <span class="number">529651</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="string">max-age=604800</span></span><br><span class="line"><span class="attr">Connection:</span> <span class="string">keep-alive</span></span><br><span class="line"><span class="attr">Content-Encoding:</span> <span class="string">gzip</span></span><br><span class="line"><span class="attr">Content-Length:</span> <span class="number">648</span></span><br><span class="line"><span class="attr">Content-Type:</span> <span class="string">text/html;</span> <span class="string">charset=UTF-8</span></span><br><span class="line"><span class="attr">Date:</span> <span class="string">Mon,</span> <span class="number">02</span> <span class="string">Nov</span> <span class="number">2020 17:53:39 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">Etag:</span> <span class="string">"3147526947+ident+gzip"</span></span><br><span class="line"><span class="attr">Expires:</span> <span class="string">Mon,</span> <span class="number">09</span> <span class="string">Nov</span> <span class="number">2020 17:53:39 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">Keep-Alive:</span> <span class="string">timeout=4</span></span><br><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Thu,</span> <span class="number">17</span> <span class="string">Oct</span> <span class="number">2019 07:18:26 </span><span class="string">GMT</span></span><br><span class="line"><span class="attr">Proxy-Connection:</span> <span class="string">keep-alive</span></span><br><span class="line"><span class="attr">Server:</span> <span class="string">ECS</span> <span class="string">(sjc/16DF)</span></span><br><span class="line"><span class="attr">Vary:</span> <span class="string">Accept-Encoding</span></span><br><span class="line"><span class="attr">X-Cache:</span> <span class="string">HIT</span></span><br><span class="line"><span class="string">//空行</span></span><br><span class="line"><span class="string">&lt;!doctype</span> <span class="string">html&gt;</span></span><br><span class="line"><span class="string">&lt;html&gt;</span></span><br><span class="line"><span class="string">&lt;head&gt;</span></span><br><span class="line">    <span class="string">&lt;title&gt;Example</span> <span class="string">Domain&lt;/title&gt;</span></span><br><span class="line">    <span class="string">//</span> <span class="string">省略...</span> </span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></tbody></table></figure><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><p>HTTP 使用 URL（ <strong>U</strong> niform <strong>R</strong>esource <strong>L</strong>ocator，<strong>统一资源定位符</strong>）来定位资源，它是  URI（<strong>U</strong>niform <strong>R</strong>esource <strong>I</strong>dentifier，<strong>统一资源标识符</strong>）的子集，URL 在 URI 的基础上增加了定位能力。URI 除了包含 URL，还包含 URN（Uniform Resource Name，统一资源名称），它只是用来定义一个资源的名称，并不具备定位该资源的能力。例如 urn:isbn:0451450523 用来定义一个书籍名称，但是却没有表示怎么找到这本书。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162304.png" alt="image"></p><ul><li><a href="https://zh.wikipedia.org/wiki/统一资源标志符">wikipedia：统一资源标志符</a></li><li><a href="https://en.wikipedia.org/wiki/URL">wikipedia: URL</a></li><li><a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.2">rfc2616：3.2.2 http URL</a></li><li><a href="https://stackoverflow.com/questions/176264/what-is-the-difference-between-a-uri-a-url-and-a-urn">What is the difference between a URI, a URL and a URN?</a></li></ul><h2 id="二、HTTP-方法"><a href="#二、HTTP-方法" class="headerlink" title="二、HTTP 方法"></a>二、HTTP 方法</h2><p>客户端发送的  <strong>请求报文</strong>  第一行为请求行，包含了方法字段。</p><h3 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h3><blockquote><p>获取资源</p></blockquote><p>当前网络请求中，绝大部分使用的是 GET 方法。</p><h3 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h3><blockquote><p>获取报文首部</p></blockquote><p>和 GET 方法类似，但是不返回报文实体主体部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。</p><h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><blockquote><p>传输实体主体</p></blockquote><p>POST 主要用来传输数据，而 GET 主要用来获取资源。更多 POST 与 GET 的比较请见第九章。</p><h3 id="PUT"><a href="#PUT" class="headerlink" title="PUT"></a>PUT</h3><blockquote><p>上传文件</p></blockquote><p>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /new.html HTTP/1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-type: text/html</span><br><span class="line">Content-length: 16</span><br><span class="line"></span><br><span class="line">&lt;p&gt;New File&lt;/p&gt;</span><br></pre></td></tr></tbody></table></figure><h3 id="PATCH"><a href="#PATCH" class="headerlink" title="PATCH"></a>PATCH</h3><blockquote><p>对资源进行部分修改</p></blockquote><p>PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PATCH /file.txt HTTP/1.1</span><br><span class="line">Host: www.example.com</span><br><span class="line">Content-Type: application/example</span><br><span class="line">If-Match: "e0023aa4e"</span><br><span class="line">Content-Length: 100</span><br><span class="line"></span><br><span class="line">[description of changes]</span><br></pre></td></tr></tbody></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><blockquote><p>删除文件</p></blockquote><p>与 PUT 功能相反，并且同样不带验证机制。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE /file.html HTTP/1.1</span><br></pre></td></tr></tbody></table></figure><h3 id="OPTIONS"><a href="#OPTIONS" class="headerlink" title="OPTIONS"></a>OPTIONS</h3><blockquote><p>查询支持的方法</p></blockquote><p>查询指定的 URL 能够支持的方法。会返回 <code>Allow: GET, POST, HEAD, OPTIONS</code> 这样的内容。</p><h3 id="CONNECT"><a href="#CONNECT" class="headerlink" title="CONNECT"></a>CONNECT</h3><blockquote><p>要求在与代理服务器通信时建立隧道</p></blockquote><p>使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONNECT www.example.com:443 HTTP/1.1</span><br></pre></td></tr></tbody></table></figure><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162326.jpeg" alt="image"></p><h3 id="TRACE"><a href="#TRACE" class="headerlink" title="TRACE"></a>TRACE</h3><blockquote><p>追踪路径</p></blockquote><p>服务器会将通信路径返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。</p><h2 id="三、HTTP-状态码"><a href="#三、HTTP-状态码" class="headerlink" title="三、HTTP 状态码"></a>三、HTTP 状态码</h2><p>服务器返回的  <strong>响应报文</strong>  中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。</p><table><thead><tr><th align="center">状态码</th><th align="center">类别</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1XX</td><td align="center">Informational（信息性状态码）</td><td align="center">接收的请求正在处理</td></tr><tr><td align="center">2XX</td><td align="center">Success（成功状态码）</td><td align="center">请求正常处理完毕</td></tr><tr><td align="center">3XX</td><td align="center">Redirection（重定向状态码）</td><td align="center">需要进行附加操作以完成请求</td></tr><tr><td align="center">4XX</td><td align="center">Client Error（客户端错误状态码）</td><td align="center">服务器无法处理请求</td></tr><tr><td align="center">5XX</td><td align="center">Server Error（服务器错误状态码）</td><td align="center">服务器处理请求出错</td></tr></tbody></table><h3 id="1XX-信息"><a href="#1XX-信息" class="headerlink" title="1XX 信息"></a>1XX 信息</h3><ul><li><strong>100 Continue</strong>  ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。</li></ul><h3 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h3><ul><li><strong>200 OK</strong></li><li><strong>204 No Content</strong>  ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。</li><li><strong>206 Partial Content</strong>  ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。</li></ul><h3 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h3><ul><li><strong>301 Moved Permanently</strong>  ：永久性重定向</li><li><strong>302 Found</strong>  ：临时性重定向</li><li><strong>303 See Other</strong>  ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。</li><li>注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。</li><li><strong>304 Not Modified</strong>  ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。</li><li><strong>307 Temporary Redirect</strong>  ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。</li></ul><h3 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h3><ul><li><strong>400 Bad Request</strong>  ：请求报文中存在语法错误。</li><li><strong>401 Unauthorized</strong>  ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。</li><li><strong>403 Forbidden</strong>  ：请求被拒绝。</li><li><strong>404 Not Found</strong></li></ul><h3 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h3><ul><li><strong>500 Internal Server Error</strong>  ：服务器正在执行请求时发生错误。</li><li><strong>503 Service Unavailable</strong>  ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><h2 id="四、HTTP-首部"><a href="#四、HTTP-首部" class="headerlink" title="四、HTTP 首部"></a>四、HTTP 首部</h2><p>有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。</p><p>各种首部字段及其含义如下（不需要全记，仅供查阅）：</p><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">控制缓存的行为</td></tr><tr><td align="center">Connection</td><td align="center">控制不再转发给代理的首部字段、管理持久连接</td></tr><tr><td align="center">Date</td><td align="center">创建报文的日期时间</td></tr><tr><td align="center">Pragma</td><td align="center">报文指令</td></tr><tr><td align="center">Trailer</td><td align="center">报文末端的首部一览</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">指定报文主体的传输编码方式</td></tr><tr><td align="center">Upgrade</td><td align="center">升级为其他协议</td></tr><tr><td align="center">Via</td><td align="center">代理服务器的相关信息</td></tr><tr><td align="center">Warning</td><td align="center">错误通知</td></tr></tbody></table><h3 id="请求首部字段"><a href="#请求首部字段" class="headerlink" title="请求首部字段"></a>请求首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">用户代理可处理的媒体类型</td></tr><tr><td align="center">Accept-Charset</td><td align="center">优先的字符集</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">优先的内容编码</td></tr><tr><td align="center">Accept-Language</td><td align="center">优先的语言（自然语言）</td></tr><tr><td align="center">Authorization</td><td align="center">Web 认证信息</td></tr><tr><td align="center">Expect</td><td align="center">期待服务器的特定行为</td></tr><tr><td align="center">From</td><td align="center">用户的电子邮箱地址</td></tr><tr><td align="center">Host</td><td align="center">请求资源所在服务器</td></tr><tr><td align="center">If-Match</td><td align="center">比较实体标记（ETag）</td></tr><tr><td align="center">If-Modified-Since</td><td align="center">比较资源的更新时间</td></tr><tr><td align="center">If-None-Match</td><td align="center">比较实体标记（与 If-Match 相反）</td></tr><tr><td align="center">If-Range</td><td align="center">资源未更新时发送实体 Byte 的范围请求</td></tr><tr><td align="center">If-Unmodified-Since</td><td align="center">比较资源的更新时间（与 If-Modified-Since 相反）</td></tr><tr><td align="center">Max-Forwards</td><td align="center">最大传输逐跳数</td></tr><tr><td align="center">Proxy-Authorization</td><td align="center">代理服务器要求客户端的认证信息</td></tr><tr><td align="center">Range</td><td align="center">实体的字节范围请求</td></tr><tr><td align="center">Referer</td><td align="center">对请求中 URI 的原始获取方</td></tr><tr><td align="center">TE</td><td align="center">传输编码的优先级</td></tr><tr><td align="center">User-Agent</td><td align="center">HTTP 客户端程序的信息</td></tr></tbody></table><h3 id="响应首部字段"><a href="#响应首部字段" class="headerlink" title="响应首部字段"></a>响应首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Accept-Ranges</td><td align="center">是否接受字节范围请求</td></tr><tr><td align="center">Age</td><td align="center">推算资源创建经过时间</td></tr><tr><td align="center">ETag</td><td align="center">资源的匹配信息</td></tr><tr><td align="center">Location</td><td align="center">令客户端重定向至指定 URI</td></tr><tr><td align="center">Proxy-Authenticate</td><td align="center">代理服务器对客户端的认证信息</td></tr><tr><td align="center">Retry-After</td><td align="center">对再次发起请求的时机要求</td></tr><tr><td align="center">Server</td><td align="center">HTTP 服务器的安装信息</td></tr><tr><td align="center">Vary</td><td align="center">代理服务器缓存的管理信息</td></tr><tr><td align="center">WWW-Authenticate</td><td align="center">服务器对客户端的认证信息</td></tr></tbody></table><h3 id="实体首部字段"><a href="#实体首部字段" class="headerlink" title="实体首部字段"></a>实体首部字段</h3><table><thead><tr><th align="center">首部字段名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">Allow</td><td align="center">资源可支持的 HTTP 方法</td></tr><tr><td align="center">Content-Encoding</td><td align="center">实体主体适用的编码方式</td></tr><tr><td align="center">Content-Language</td><td align="center">实体主体的自然语言</td></tr><tr><td align="center">Content-Length</td><td align="center">实体主体的大小</td></tr><tr><td align="center">Content-Location</td><td align="center">替代对应资源的 URI</td></tr><tr><td align="center">Content-MD5</td><td align="center">实体主体的报文摘要</td></tr><tr><td align="center">Content-Range</td><td align="center">实体主体的位置范围</td></tr><tr><td align="center">Content-Type</td><td align="center">实体主体的媒体类型</td></tr><tr><td align="center">Expires</td><td align="center">实体主体过期的日期时间</td></tr><tr><td align="center">Last-Modified</td><td align="center">资源的最后修改日期时间</td></tr></tbody></table><h2 id="五、具体应用"><a href="#五、具体应用" class="headerlink" title="五、具体应用"></a>五、具体应用</h2><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162349.png" alt="image"></p><h4 id="1-短连接与长连接"><a href="#1-短连接与长连接" class="headerlink" title="1. 短连接与长连接"></a>1. 短连接与长连接</h4><p>当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。</p><p>长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。</p><ul><li>从 HTTP/1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 <code>Connection : close</code>；</li><li>在 HTTP/1.1 之前默认是短连接的，如果需要使用长连接，则使用 <code>Connection : Keep-Alive</code>。</li></ul><h4 id="2-流水线"><a href="#2-流水线" class="headerlink" title="2. 流水线"></a>2. 流水线</h4><p>默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。</p><p>流水线是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来保存状态信息。</p><p>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。</p><p>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h4 id="1-用途"><a href="#1-用途" class="headerlink" title="1. 用途"></a>1. 用途</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h4 id="2-创建过程"><a href="#2-创建过程" class="headerlink" title="2. 创建过程"></a>2. 创建过程</h4><p>服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-type: text/html</span><br><span class="line">Set-Cookie: yummy_cookie=choco</span><br><span class="line">Set-Cookie: tasty_cookie=strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></tbody></table></figure><p>客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /sample_page.html HTTP/1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie=choco; tasty_cookie=strawberry</span><br></pre></td></tr></tbody></table></figure><h4 id="3-分类"><a href="#3-分类" class="headerlink" title="3. 分类"></a>3. 分类</h4><ul><li>会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。</li><li>持久性 Cookie：指定过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。</li></ul><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></tbody></table></figure><h4 id="4-作用域"><a href="#4-作用域" class="headerlink" title="4. 作用域"></a>4. 作用域</h4><p>Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。</p><p>Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“/“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：</p><ul><li>/docs</li><li>/docs/Web/</li><li>/docs/Web/HTTP</li></ul><h4 id="5-JavaScript"><a href="#5-JavaScript" class="headerlink" title="5. JavaScript"></a>5. JavaScript</h4><p>浏览器通过 <code>document.cookie</code> 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.cookie = "yummy_cookie=choco";</span><br><span class="line">document.cookie = "tasty_cookie=strawberry";</span><br><span class="line">console.log(document.cookie);</span><br></pre></td></tr></tbody></table></figure><h4 id="6-HttpOnly"><a href="#6-HttpOnly" class="headerlink" title="6. HttpOnly"></a>6. HttpOnly</h4><p>标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 <code>document.cookie</code> API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></tbody></table></figure><h4 id="7-Secure"><a href="#7-Secure" class="headerlink" title="7. Secure"></a>7. Secure</h4><p>标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。</p><h4 id="8-Session"><a href="#8-Session" class="headerlink" title="8. Session"></a>8. Session</h4><p>除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。</p><p>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。</p><p>用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。</li></ul><p>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</p><h4 id="9-浏览器禁用-Cookie"><a href="#9-浏览器禁用-Cookie" class="headerlink" title="9. 浏览器禁用 Cookie"></a>9. 浏览器禁用 Cookie</h4><p>此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。</p><h4 id="10-Cookie-与-Session-选择"><a href="#10-Cookie-与-Session-选择" class="headerlink" title="10. Cookie 与 Session 选择"></a>10. Cookie 与 Session 选择</h4><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。</li></ul><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h4><ul><li>缓解服务器压力；</li><li>降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。</li></ul><h4 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2. 实现方法"></a>2. 实现方法</h4><ul><li>让代理服务器进行缓存；</li><li>让客户端浏览器进行缓存。</li></ul><h4 id="3-Cache-Control"><a href="#3-Cache-Control" class="headerlink" title="3. Cache-Control"></a>3. Cache-Control</h4><p>HTTP/1.1 通过 Cache-Control 首部字段来控制缓存。</p><p><strong>3.1 禁止进行缓存</strong></p><p>no-tore 指令规定不能对请求或响应的任何一部分进行缓存。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-store</span><br></pre></td></tr></tbody></table></figure><p><strong>3.2 强制确认缓存</strong></p><p>no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: no-cache</span><br></pre></td></tr></tbody></table></figure><p><strong>3.3 私有缓存和公共缓存</strong></p><p>private 指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: private</span><br></pre></td></tr></tbody></table></figure><p>public 指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: public</span><br></pre></td></tr></tbody></table></figure><p><strong>3.4 缓存过期机制</strong></p><p>max-age 指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。</p><p>max-age 指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control: max-age=31536000</span><br></pre></td></tr></tbody></table></figure><p>Exires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, 04 Jul 2012 08:26:05 GMT</span><br></pre></td></tr></tbody></table></figure><ul><li>在 HTTP/1.1 中，会优先处理 max-age 指令；</li><li>在 HTTP/1.0 中，max-age 指令会被忽略掉。</li></ul><h4 id="4-缓存验证"><a href="#4-缓存验证" class="headerlink" title="4. 缓存验证"></a>4. 缓存验证</h4><p>需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 <code>http://www.google.com/</code> 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ETag: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></tbody></table></figure><p>可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-None-Match: "82e22293907ce725faf67773957acd12"</span><br></pre></td></tr></tbody></table></figure><p>Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT</span><br></pre></td></tr></tbody></table></figure><h3 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h3><p>通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。</p><h4 id="1-类型"><a href="#1-类型" class="headerlink" title="1. 类型"></a>1. 类型</h4><p><strong>1.1 服务端驱动型</strong></p><p>客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。</p><p>它存在以下问题：</p><ul><li>服务器很难知道客户端浏览器的全部信息；</li><li>客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）；</li><li>给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。</li></ul><p><strong>1.2 代理驱动型</strong></p><p>服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。</p><h4 id="2-Vary"><a href="#2-Vary" class="headerlink" title="2. Vary"></a>2. Vary</h4><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vary: Accept-Language</span><br></pre></td></tr></tbody></table></figure><p>在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。</p><p>例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 <code>Vary: Accept-Language</code> 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。</p><h3 id="内容编码"><a href="#内容编码" class="headerlink" title="内容编码"></a>内容编码</h3><p>内容编码将实体主体进行压缩，从而减少传输的数据量。</p><p>常用的内容编码有：gzip、compress、deflate、identity。</p><p>浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。</p><h3 id="范围请求"><a href="#范围请求" class="headerlink" title="范围请求"></a>范围请求</h3><p>如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。</p><h4 id="1-Range"><a href="#1-Range" class="headerlink" title="1. Range"></a>1. Range</h4><p>在请求报文中添加 Range 首部字段指定请求的范围。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /z4d4kWk.jpg HTTP/1.1</span><br><span class="line">Host: i.imgur.com</span><br><span class="line">Range: bytes=0-1023</span><br></pre></td></tr></tbody></table></figure><p>请求成功的话服务器返回的响应包含 206 Partial Content 状态码。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 206 Partial Content</span><br><span class="line">Content-Range: bytes 0-1023/146515</span><br><span class="line">Content-Length: 1024</span><br><span class="line">...</span><br><span class="line">(binary content)</span><br></pre></td></tr></tbody></table></figure><h4 id="2-Accept-Ranges"><a href="#2-Accept-Ranges" class="headerlink" title="2. Accept-Ranges"></a>2. Accept-Ranges</h4><p>响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges: bytes</span><br></pre></td></tr></tbody></table></figure><h4 id="3-响应状态码"><a href="#3-响应状态码" class="headerlink" title="3. 响应状态码"></a>3. 响应状态码</h4><ul><li>在请求成功的情况下，服务器会返回 206 Partial Content 状态码。</li><li>在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。</li><li>在不支持范围请求的情况下，服务器会返回 200 OK 状态码。</li></ul><h3 id="分块传输编码"><a href="#分块传输编码" class="headerlink" title="分块传输编码"></a>分块传输编码</h3><p>Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。</p><h3 id="多部分对象集合"><a href="#多部分对象集合" class="headerlink" title="多部分对象集合"></a>多部分对象集合</h3><p>一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。</p><p>例如，上传多个表单时可以使用如下方式：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart/form-data; boundary=AaB03x</span><br><span class="line"></span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="submit-name"</span><br><span class="line"></span><br><span class="line">Larry</span><br><span class="line">--AaB03x</span><br><span class="line">Content-Disposition: form-data; name="files"; filename="file1.txt"</span><br><span class="line">Content-Type: text/plain</span><br><span class="line"></span><br><span class="line">... contents of file1.txt ...</span><br><span class="line">--AaB03x--</span><br></pre></td></tr></tbody></table></figure><h3 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h3><p>HTTP/1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。</p><h3 id="通信数据转发"><a href="#通信数据转发" class="headerlink" title="通信数据转发"></a>通信数据转发</h3><h4 id="1-代理"><a href="#1-代理" class="headerlink" title="1. 代理"></a>1. 代理</h4><p>代理服务器接受客户端的请求，并且转发给其它服务器。</p><p>使用代理的主要目的是：</p><ul><li>缓存</li><li>负载均衡</li><li>网络访问控制</li><li>访问日志记录</li></ul><p>代理服务器分为正向代理和反向代理两种：</p><ul><li>用户察觉得到正向代理的存在。</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162424.png" alt="image"></p><ul><li>而反向代理一般位于内部网络中，用户察觉不到。</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162430.png" alt="image"></p><h4 id="2-网关"><a href="#2-网关" class="headerlink" title="2. 网关"></a>2. 网关</h4><p>与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。</p><h4 id="3-隧道"><a href="#3-隧道" class="headerlink" title="3. 隧道"></a>3. 隧道</h4><p>使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。</p><h2 id="六、HTTPS"><a href="#六、HTTPS" class="headerlink" title="六、HTTPS"></a>六、HTTPS</h2><p>HTTP 有以下安全性问题：</p><ul><li>使用明文进行通信，内容可能会被窃听；</li><li>不验证通信方的身份，通信方的身份有可能遭遇伪装；</li><li>无法证明报文的完整性，报文有可能遭篡改。</li></ul><p>HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPS 使用了隧道进行通信。</p><p>通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162437.jpeg" alt="image"></p><h3 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h3><h4 id="1-对称密钥加密"><a href="#1-对称密钥加密" class="headerlink" title="1. 对称密钥加密"></a>1. 对称密钥加密</h4><p>对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。</p><ul><li>优点：运算速度快；</li><li>缺点：无法安全地将密钥传输给通信方。</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162449.png" alt="image"></p><h4 id="2-非对称密钥加密"><a href="#2-非对称密钥加密" class="headerlink" title="2.非对称密钥加密"></a>2.非对称密钥加密</h4><p>非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。</p><p>公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。</p><p>非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。</p><ul><li>优点：可以更安全地将公开密钥传输给通信发送方；</li><li>缺点：运算速度慢。</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162453.png" alt="image"></p><h4 id="3-HTTPS-采用的加密方式"><a href="#3-HTTPS-采用的加密方式" class="headerlink" title="3. HTTPS 采用的加密方式"></a>3. HTTPS 采用的加密方式</h4><p>上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key  传输给通信方。HTTPS 采用混合的加密机制，正是利用了上面提到的方案：</p><ul><li>使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;</li><li>获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162457.png" alt="image"></p><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><p>通过使用  <strong>证书</strong>  来对通信方进行认证。</p><p>数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。</p><p>服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。</p><p>进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162501.png" alt="image"></p><h3 id="完整性保护"><a href="#完整性保护" class="headerlink" title="完整性保护"></a>完整性保护</h3><p>SSL 提供报文摘要功能来进行完整性保护。</p><p>HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。</p><p>HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。</p><h3 id="HTTPS-的缺点"><a href="#HTTPS-的缺点" class="headerlink" title="HTTPS 的缺点"></a>HTTPS 的缺点</h3><ul><li>因为需要进行加密解密等过程，因此速度会更慢；</li><li>需要支付证书授权的高额费用。</li></ul><h2 id="七、HTTP-2-0"><a href="#七、HTTP-2-0" class="headerlink" title="七、HTTP/2.0"></a>七、HTTP/2.0</h2><h3 id="HTTP-1-x-缺陷"><a href="#HTTP-1-x-缺陷" class="headerlink" title="HTTP/1.x 缺陷"></a>HTTP/1.x 缺陷</h3><p>HTTP/1.x 实现简单是以牺牲性能为代价的：</p><ul><li>客户端需要使用多个连接才能实现并发和缩短延迟；</li><li>不会压缩请求和响应首部，从而导致不必要的网络流量；</li><li>不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。</li></ul><h3 id="二进制分帧层"><a href="#二进制分帧层" class="headerlink" title="二进制分帧层"></a>二进制分帧层</h3><p>HTTP/2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162506.png" alt="image"></p><p>在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。</p><ul><li>一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息。</li><li>消息（Message）是与逻辑请求或响应对应的完整的一系列帧。</li><li>帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162511.png" alt="image"></p><h3 id="服务端推送"><a href="#服务端推送" class="headerlink" title="服务端推送"></a>服务端推送</h3><p>HTTP/2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162515.png" alt="image"></p><h3 id="首部压缩"><a href="#首部压缩" class="headerlink" title="首部压缩"></a>首部压缩</h3><p>HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。</p><p>HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。</p><p>不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201129162520.png" alt="image"></p><h2 id="八、HTTP-1-1-新特性"><a href="#八、HTTP-1-1-新特性" class="headerlink" title="八、HTTP/1.1 新特性"></a>八、HTTP/1.1 新特性</h2><p>详细内容请见上文</p><ul><li>默认是长连接</li><li>支持流水线</li><li>支持同时打开多个 TCP 连接</li><li>支持虚拟主机</li><li>新增状态码 100</li><li>支持分块传输编码</li><li>新增缓存处理指令 max-age</li></ul><h2 id="九、GET-和-POST-比较"><a href="#九、GET-和-POST-比较" class="headerlink" title="九、GET 和 POST 比较"></a>九、GET 和 POST 比较</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>GET 用于获取资源，而 POST 用于传输实体主体。</p><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。</p><p>因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 <code>中文</code> 会转换为 <code>%E4%B8%AD%E6%96%87</code>，而空格会转换为 <code>%20</code>。POST 参数支持标准字符集。</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /test/demo_form.asp HTTP/1.1</span><br><span class="line">Host: w3schools.com</span><br><span class="line">name1=value1&amp;name2=value2</span><br></pre></td></tr></tbody></table></figure><h3 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h3><p>安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。</p><p>GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。</p><p>安全的方法除了 GET 之外还有：HEAD、OPTIONS。</p><p>不安全的方法除了 POST 之外还有 PUT、DELETE。</p><h3 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h3><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。</p><p>所有的安全方法也都是幂等的。</p><p>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。</p><p>GET /pageX HTTP/1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br><span class="line">GET /pageX HTTP/1.1</span><br></pre></td></tr></tbody></table></figure><p>POST /add_row HTTP/1.1 不是幂等的，如果调用多次，就会增加多行记录：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 1nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 2nd row</span><br><span class="line">POST /add_row HTTP/1.1   -&gt; Adds a 3rd row</span><br></pre></td></tr></tbody></table></figure><p>DELETE /idX/delete HTTP/1.1 是幂等的，即使不同的请求接收到的状态码不一样：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 200 if idX exists</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404 as it just got deleted</span><br><span class="line">DELETE /idX/delete HTTP/1.1   -&gt; Returns 404</span><br></pre></td></tr></tbody></table></figure><h3 id="可缓存"><a href="#可缓存" class="headerlink" title="可缓存"></a>可缓存</h3><p>如果要对响应进行缓存，需要满足以下条件：</p><ul><li>请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。</li><li>响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。</li><li>响应报文的 Cache-Control 首部字段没有指定不进行缓存。</li></ul><h3 id="XMLHttpRequest"><a href="#XMLHttpRequest" class="headerlink" title="XMLHttpRequest"></a>XMLHttpRequest</h3><p>为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><ul><li>在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。</li><li>而 GET 方法 Header 和 Data 会一起发送。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode总结—二叉树的遍历</title>
      <link href="/2020/11/27/er-cha-shu-de-bian-li/"/>
      <url>/2020/11/27/er-cha-shu-de-bian-li/</url>
      
        <content type="html"><![CDATA[<p>二叉树是面试中常见的题目类型，这里，针对 leetcode 前200道题中的二叉树相关问题进行总结与思考，力求烂熟于心，能根据题目名回忆起题目的具体描述，进而用简洁的语言描述出算法的核心。具体的题目答案可打开 leetcode 查看历史提交记录。</p><h2 id="二叉树的遍历（binary-tree-traversal）"><a href="#二叉树的遍历（binary-tree-traversal）" class="headerlink" title="二叉树的遍历（binary-tree-traversal）"></a>二叉树的遍历（binary-tree-traversal）</h2><blockquote><p>二叉树的遍历是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p></blockquote><p><strong>为什么研究二叉树的遍历？</strong></p><p>因为计算机只会处理线性序列，而我们研究遍历，就是把树中的结点变成某种意义的线性序列，这给程序的实现带来了好处。</p><h2 id="1-三种基本遍历方式"><a href="#1-三种基本遍历方式" class="headerlink" title="1 三种基本遍历方式"></a>1 三种基本遍历方式</h2><p>首先是二叉树的遍历方式，最简单基础的也就是前序(preorder)、中序(inorder)、后序(postorder)三种遍历方式，对应题目 <a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">144.二叉树的前序遍历</a> 、<a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a> 、<a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">145. 二叉树的后序遍历</a>。</p><blockquote><p>前中后，指的是根节点相对于左右结点的访问顺序</p></blockquote><p><strong>先序：</strong>考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)</p><p><strong>中序：</strong>考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)</p><p><strong>后序：</strong>考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165620.png" alt="image"></p><p><strong>这种类型的题一般都是有两种解题思路：递归和迭代。</strong></p><h3 id="1-1-递归法模板"><a href="#1-1-递归法模板" class="headerlink" title="1.1 递归法模板"></a>1.1 递归法模板</h3><blockquote><p>我们并不需要太过于在意具体的递归过程，而是要想清楚让计算机干什么。计算机都可能溢出，用人脑去遍历就不现实了。</p></blockquote><p>思路： 判断什么时候把结点的 <code>val</code> 加入 <code>res</code> 数组中，<code>res.add(root.val)</code>放的位置决定了遍历顺序。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">边界条件</span><br><span class="line"></span><br><span class="line">定义 dfs 函数：</span><br><span class="line">    如果root为空：返回</span><br><span class="line">    递归左子树</span><br><span class="line">    递归右子树</span><br><span class="line">    <span class="comment">// root 的值加入到结果</span></span><br><span class="line"></span><br><span class="line">执行递归函数，返回结果</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        helper(root,res);</span><br><span class="line">        <span class="keyword">return</span> res;    </span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 递归主程序</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span>  <span class="title">helper</span><span class="params">(TreeNode root,List&lt;Integer&gt; res)</span> </span>{</span><br><span class="line">        <span class="comment">// 判断root是否为空，是一个重要的递归终止的条件。</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// res.add(root.val);</span></span><br><span class="line">        helper(root.left,res);</span><br><span class="line">        helper(root.right,res);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>一样的代码，稍微调用一下位置就可以，如此固定的套路，使得只掌握递归解法并不足以令面试官信服=`=所以必须掌握迭代法加深对二叉树的理解！！</p><h3 id="1-2-迭代法模板"><a href="#1-2-迭代法模板" class="headerlink" title="1.2 迭代法模板"></a>1.2 迭代法模板</h3><p>本质上是在模拟递归，因为在递归的过程中使用了系统栈，所以在迭代的解法中常用<code>Stack</code>来模拟系统栈。</p><p><strong>思路：</strong>用<code>while</code>循环先将根节点和所有左孩子加入栈和结果数组中，直至<code>cur</code>为空。然后，每弹出一个栈顶元素 <code>tmp</code>，就到达它的右孩子，再将这个节点当作 <code>cur</code> 重新按上面的步骤来一遍，直至栈为空。这里又需要一个 <code>while</code> 循环。</p><p>使用这个迭代模板处理前序和中序遍历，只要更改 <code>res.add(cur.val)</code> 的位置即可。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">边界条件</span><br><span class="line">    </span><br><span class="line">初始化stack,res,cur</span><br><span class="line"><span class="keyword">while</span> stack或cur 非空：</span><br><span class="line">    <span class="keyword">while</span> cur非空：</span><br><span class="line">        cur的值入栈stack</span><br><span class="line">        <span class="comment">// cur的值加入res 前序</span></span><br><span class="line">        cur 向左下或右下遍历</span><br><span class="line">    弹出节点tmp</span><br><span class="line">    cur回到tmp的左或右子树</span><br><span class="line">        </span><br><span class="line">返回结果</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span>||!stack.isEmpty()){</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                <span class="comment">//res.add(cur.val);前序</span></span><br><span class="line">                cur=cur.left;</span><br><span class="line">            }</span><br><span class="line">            tmp=stack.pop();</span><br><span class="line">            <span class="comment">//res.add(tmp.val);中序</span></span><br><span class="line">            cur=tmp.right;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>但是后序并不能使用，取巧的方法是使用模板(根右左)，对其取反<code>Collections.reverse(res)</code>就是后序遍历的结果(左右根)</p><blockquote><p>利用了结果的特点反向输出，不免显得技术含量不足，因此掌握后序遍历标准的栈操作解法是必要的！</p></blockquote><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        List&lt;Integer&gt; res=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Deque&lt;TreeNode&gt; stack=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        TreeNode cur=root;</span><br><span class="line">        TreeNode p=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="keyword">null</span> || !stack.isEmpty()){</span><br><span class="line">            <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur=cur.left;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//peek不删除栈顶，pop删除</span></span><br><span class="line">            cur=stack.peek();</span><br><span class="line">            <span class="comment">// 一种情况是cur为最下面的子节点，需要加入到res，另一种是当前为遍历过右子树的根节点也需要加入到res</span></span><br><span class="line">            <span class="keyword">if</span>(cur.right==<span class="keyword">null</span>||cur.right==p){</span><br><span class="line">                res.add(cur.val);</span><br><span class="line">                stack.pop();</span><br><span class="line">                p=cur;</span><br><span class="line">                cur=<span class="keyword">null</span>;</span><br><span class="line">            }<span class="keyword">else</span>{</span><br><span class="line">                cur=cur.right;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }  </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="2-层序遍历及其变题"><a href="#2-层序遍历及其变题" class="headerlink" title="2 层序遍历及其变题"></a>2 层序遍历及其变题</h2><p>除了基本的三种遍历使用DFS，使用BFS广度优先搜索的层序遍历也很重要<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></p><p>下面是两种解决此类问题的方法，一般使用左边的BFS</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165618.png" alt="image.png"></p><h3 id="2-1-BFS层序遍历"><a href="#2-1-BFS层序遍历" class="headerlink" title="2.1 BFS层序遍历"></a>2.1 BFS层序遍历</h3><p>BFS遍历的标准写法如下，使用的是<strong>队列</strong>数据结构：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        TreeNode node = queue.poll(); <span class="comment">// Queue 中 remove() 和 poll()都是用来从队列头部删除一个元素。</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) {</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) {</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>我们可以直接用 BFS 得出层序遍历结果。然而，层序遍历要求的输入结果和 BFS 是不同的。层序遍历要求我们区分每一层，也就是返回一个二维数组。而 BFS 的遍历结果是一个一维数组，无法区分每一层，见下图的对比。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165619.jpeg" alt="image"></p><p>因此，我们需要在每一层前微修改一下代码，在每一层遍历开始前，先记录队列中的结点数量 n（也就是这一层的节点数量），然后一口气处理完这一层的 n个结点。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) {</span><br><span class="line">        queue.add(root);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) {</span><br><span class="line">        <span class="keyword">int</span> n = queue.size();</span><br><span class="line">        List&lt;Integer&gt; level = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) { </span><br><span class="line">            TreeNode node = queue.poll();</span><br><span class="line">            level.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) {</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        res.add(level);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>这样，我们就可以用BFS来解决层序遍历问题了，<strong>重点是记录了每一层节点的数量，动图如下</strong></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165622.gif" alt="image"></p><h3 id="2-2-选看-DFS层序遍历"><a href="#2-2-选看-DFS层序遍历" class="headerlink" title="2.2 (选看)DFS层序遍历"></a>2.2 (选看)DFS层序遍历</h3><p>DFS 遍历标准写法如下，使用的是<strong>递归</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    dfs(root.left);</span><br><span class="line">    dfs(root.right);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>看起来比BFS的代码简洁很多，但观看下图就可以发现两者的遍历顺序是不同的，BFS其实更贴近我们想要的层序遍历逻辑。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165621.gif" alt="image"></p><p>那DFS究竟可不可以解决层序遍历问题呢？当然是可以的！</p><p>把这个二叉树的样子调整一下，摆成一个田字形的样子。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165623.jpeg" alt="image"><br><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165626.gif" alt="image"></p><p>田字形的每一层就对应一个 list，每次递归的时候都需要<strong>带一个 index(表示当前的层数)</strong>，也就对应那个田字格子中的第几行，如果当前行对应的 list 不存在，就加入一个空 list 进去。代码实现如下。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//用来存放最终结果</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        dfs(<span class="number">1</span>,root,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index,TreeNode root, List&lt;List&lt;Integer&gt;&gt; res)</span> </span>{</span><br><span class="line">        <span class="comment">//假设res是[ [1],[2,3] ]， index是3，就再插入一个空list放到res中</span></span><br><span class="line">        <span class="keyword">if</span>(res.size()&lt;index) {</span><br><span class="line">            res.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//将当前节点的值加入到res中，index代表当前层，假设index是3，节点值是99</span></span><br><span class="line">        <span class="comment">//res是[ [1],[2,3] [4] ]，加入后res就变为 [ [1],[2,3] [4,99] ]</span></span><br><span class="line">        res.get(index-<span class="number">1</span>).add(root.val);</span><br><span class="line">        <span class="comment">//递归的处理左子树，右子树，同时将层数index+1</span></span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>) {</span><br><span class="line">            dfs(index+<span class="number">1</span>, root.left, res);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>) {</span><br><span class="line">            dfs(index+<span class="number">1</span>, root.right, res);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>感觉有点像二叉树的前序遍历，根左右</p><h3 id="2-3-变题-二叉树的锯齿形层次遍历"><a href="#2-3-变题-二叉树的锯齿形层次遍历" class="headerlink" title="2.3 (变题) 二叉树的锯齿形层次遍历"></a>2.3 (变题) <a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/">二叉树的锯齿形层次遍历</a></h3><p>该题是leetcode103题，medium难度，一句话题干描述：层序遍历，不过是之字形的。</p><p>总体思路：用个变量flag来判断是从左往右还是从右往左打印</p><p><strong>解决方案1(容易理解)：</strong> 在层序遍历代码的基础上，更改节点数值进入list的顺序</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (leftToRight) {</span><br><span class="line">    level.add(node.val);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    level.add(<span class="number">0</span>, node.val);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>解决方案2(画图理解)：</strong> 使用deuqe双端队列：可以在两边同时添加和删除的队列</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Deque&lt;TreeNode&gt; deque=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (leftToRight) {</span><br><span class="line">    <span class="comment">//从左边往右边打印</span></span><br><span class="line">    <span class="comment">//移除队列头部的元素，如果子节点不为空加入到队列的尾部</span></span><br><span class="line">    cur = deque.removeFirst();</span><br><span class="line">    <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)</span><br><span class="line">        deque.addLast(cur.right);</span><br><span class="line">    <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)</span><br><span class="line">        deque.addLast(cur.left);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="comment">//从右边往左边打印</span></span><br><span class="line">    <span class="comment">//移除队列尾部的元素，如果子节点不为空加入到队列的头部</span></span><br><span class="line">    cur = deque.removeLast();</span><br><span class="line">    <span class="keyword">if</span> (cur.left != <span class="keyword">null</span>)</span><br><span class="line">        deque.addFirst(cur.left);</span><br><span class="line">    <span class="keyword">if</span> (cur.right != <span class="keyword">null</span>)</span><br><span class="line">        deque.addFirst(cur.right);</span><br><span class="line">}</span><br><span class="line">level.add(cur.val);</span><br></pre></td></tr></tbody></table></figure><p>deque中把每一行的节点值反序列表示，然后每次打印判断从左往右读deque还是从右往左。读的时候相应的也要改变左右孩子入队列的顺序来保持 deque中每一行的节点值反序表示。</p><h3 id="2-4-变题-二叉树的右视图"><a href="#2-4-变题-二叉树的右视图" class="headerlink" title="2.4 (变题) 二叉树的右视图"></a>2.4 (变题) <a href="https://leetcode-cn.com/problems/binary-tree-right-side-view/">二叉树的右视图</a></h3><p>该题是leetcode199题，medium难度，一句话题干描述：从上到下返回每一层最后一个元素</p><p>总体思路：利用 BFS 进行层次遍历，记录下每层的最后一个元素。</p><p><strong>解决方案1(BFS)：</strong> 在层序遍历代码基础上，判断当前节点是不是这层的最后一个节点，是的话才添加进结果数组。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(i==n-<span class="number">1</span>) res.add(cur.val);</span><br></pre></td></tr></tbody></table></figure><p><strong>解决方案2(DFS)：</strong>我们按照 「根结点 -&gt; 右子树 -&gt; 左子树」 的顺序访问，就可以保证每层都是最先访问最右边的节点的。（与先序遍历 「根结点 -&gt; 左子树 -&gt; 右子树」 正好相反，先序遍历每层最先访问的是最左边的节点）</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    List&lt;Integer&gt; res= <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">rightSideView</span><span class="params">(TreeNode root)</span> </span>{</span><br><span class="line">        dfs(root,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode root,<span class="keyword">int</span> depth)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(depth==res.size()){</span><br><span class="line">            res.add(root.val);</span><br><span class="line">        }</span><br><span class="line">        depth++;</span><br><span class="line">        dfs(root.right,depth);</span><br><span class="line">        dfs(root.left,depth);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="2-5-变题-填充每个节点的下一个右侧节点指针"><a href="#2-5-变题-填充每个节点的下一个右侧节点指针" class="headerlink" title="2.5 (变题) 填充每个节点的下一个右侧节点指针"></a>2.5 (变题) <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/">填充每个节点的下一个右侧节点指针</a></h3><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165624.png" alt="image"></p><p>该题是leetcode116题，medium难度，一句话题干描述：使得每个节点的next指针指向它右侧的节点<strong>(完全二叉树)</strong></p><p>总体思路：利用 BFS 进行层次遍历队列，队列中保存了第 i 层节点的信息，我们利用这个特点，将队列中的元素都串联一遍就可以了。</p><p><strong>解决方案1(基础版)：</strong>使用队列<strong>，</strong>直接把层序遍历的代码改一改， 把每一层的节点连接起来,这种方法同样适用于不是完全二叉树的情况。</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(!queue.isEmpty()){</span><br><span class="line">    <span class="keyword">int</span> size=queue.size();</span><br><span class="line">    <span class="comment">//前一个节点</span></span><br><span class="line">    Node pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) {</span><br><span class="line">        <span class="comment">//出队</span></span><br><span class="line">        Node node = queue.poll();</span><br><span class="line">        <span class="comment">//如果pre为空就表示node节点是这一行的第一个，</span></span><br><span class="line">        <span class="comment">//没有前一个节点指向他，否则就让前一个节点指向他</span></span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="keyword">null</span>) {</span><br><span class="line">            pre.next = node;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//然后再让当前节点成为前一个节点</span></span><br><span class="line">        pre = node;</span><br><span class="line">        <span class="comment">//层序遍历的代码：左右子节点如果不为空就入队</span></span><br><span class="line">        <span class="keyword">if</span> (node.left != <span class="keyword">null</span>)</span><br><span class="line">            queue.add(node.left);</span><br><span class="line">        <span class="keyword">if</span> (node.right != <span class="keyword">null</span>)</span><br><span class="line">            queue.add(node.right);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>上面运行效率并不是很高，这是因为我们把节点不停的入队然后再不停的出队，其实可以不需要队列，每一行都可以看成一个链表比如第一行就是只有一个节点的链表，第二行是只有两个节点的链表</p><p><strong>解决方案2(优化版)：</strong>观察这样的串联树可以发现，有两种了连接方式</p><ol><li>两个串联的节点都有一个共同的父节点，通过父节点就可以将这两个子节点串联起来</li><li>这两个串联的节点的父节点不同，对于这种情况，如果我们能将这一层的上一层串联好。那么可以通过父节点的 <code>next</code> 找到邻居，完成串联。即 <code>root.right.next =&gt; root.next.left</code>，这里我们需要保证 root.next 不为空就可以了。</li></ol><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165625.gif" alt="image"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Node pre=root;</span><br><span class="line"><span class="comment">//当前节点的left为空则退出循环</span></span><br><span class="line"><span class="keyword">while</span>(pre.left!=<span class="keyword">null</span>){</span><br><span class="line">    Node tmp=pre;</span><br><span class="line">    <span class="comment">// 这层连接完成，则退出</span></span><br><span class="line">    <span class="keyword">while</span>(tmp!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//将tmp的左右节点都串联起来</span></span><br><span class="line">        <span class="comment">//注:外层循环已经判断了当前节点的left不为空</span></span><br><span class="line">        tmp.left.next = tmp.right;</span><br><span class="line">        <span class="comment">//下一个不为空说明上一层已经帮我们完成串联了</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.next!=<span class="keyword">null</span>) {</span><br><span class="line">            tmp.right.next = tmp.next.left;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//继续右边遍历</span></span><br><span class="line">        tmp = tmp.next;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//从下一层的最左边开始遍历</span></span><br><span class="line">    pre = pre.left;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>解决方案3(递归骚操作)：</strong>递归从上往下，先处理当前节点，再处理它的左、右子树中的节点——前序遍历。</p><p>递归终止条件：当遍历到叶子节点，没有孩子节点。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165627.png" alt="image"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">connect</span><span class="params">(Node root)</span> </span>{</span><br><span class="line">    dfs(root);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node root)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>){</span><br><span class="line">        root.left.next = root.right;</span><br><span class="line">        <span class="keyword">if</span> (root.next!=<span class="keyword">null</span>){</span><br><span class="line">            root.right.next = root.next.left;</span><br><span class="line">        }     </span><br><span class="line">    }</span><br><span class="line">    connect(root.left);</span><br><span class="line">    connect(root.right);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 更牛逼的写法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node node, Node next)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span>(node != <span class="keyword">null</span>) {</span><br><span class="line">        node.next = next;</span><br><span class="line">        dfs(node.left, node.right);</span><br><span class="line">        dfs(node.right, node.next != <span class="keyword">null</span> ? node.next.left : <span class="keyword">null</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>总结：**</strong>每个 node 左子树的 next , 就是 node 的右子树、每个 node 右子树的 next, 就是 node next 的 左子树**</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="2-6-变题-填充每个节点的下一个右侧节点指针II"><a href="#2-6-变题-填充每个节点的下一个右侧节点指针II" class="headerlink" title="2.6 (变题) 填充每个节点的下一个右侧节点指针II"></a>2.6 (变题) <a href="https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/">填充每个节点的下一个右侧节点指针II</a></h3><p>该题是leetcode117题，medium难度，一句话题干描述：使得每个节点的next指针指向它右侧的节点<strong>(非完全二叉树)</strong></p><p>总体思路：和上一题一样的思路</p><p><strong>解决方案1(基础版)：</strong>使用队列<strong>，</strong>直接把层序遍历的代码改一改， 把每一层的节点连接起来,同上一题代码，略。</p><p><strong>解决方案2(优化版)：</strong>更改上一题的相关代码，增加哑节点(找到下一层的第一个节点)，此代码也可用于上题</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201128165537.png" alt="image"></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Node cur=root;</span><br><span class="line"><span class="comment">//当前节点的left为空则退出循环</span></span><br><span class="line"><span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">    Node dummy = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//pre表示访下一层节点的前一个节点</span></span><br><span class="line">    Node pre = dummy;</span><br><span class="line">    <span class="comment">// 这层连接完成，则退出</span></span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="keyword">null</span>){</span><br><span class="line">        <span class="comment">//如果当前节点的左子节点不为空，就让pre节点的next指向他，也就是把它串起来</span></span><br><span class="line">        <span class="keyword">if</span>(cur.left!=<span class="keyword">null</span>){</span><br><span class="line">            pre.next=cur.left;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(cur.right!=<span class="keyword">null</span>){</span><br><span class="line">            pre.next=cur.right;</span><br><span class="line">            pre=pre.next;</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//继续访问这一行的下一个节点</span></span><br><span class="line">        cur = cur.next;</span><br><span class="line">    }</span><br><span class="line">   <span class="comment">//把下一层串联成一个链表之后，让他赋值给cur，后续继续循环，直到cur为空为止</span></span><br><span class="line">   cur = dummy.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>此外，除了这些题外，还有以下题</p><p><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/">637.二叉树的层平均值</a></p><p><a href="https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/">429.N叉树的前序遍历</a></p><p><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/">515.在每个树行中找最大值</a></p><p>参考资料：leetcode题解，感谢这些大佬的配图以及易懂的语言！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2020/11/26/linux-chang-yong-ming-ling/"/>
      <url>/2020/11/26/linux-chang-yong-ming-ling/</url>
      
        <content type="html"><![CDATA[<h2 id="一、文件-文件夹管理"><a href="#一、文件-文件夹管理" class="headerlink" title="一、文件/文件夹管理"></a><strong>一、文件/文件夹管理</strong></h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#列出当前目录文件（不包括隐含文件） </span></span><br><span class="line">ls </span><br><span class="line"><span class="comment">#列出当前目录文件（包括隐含文件）</span></span><br><span class="line">ls -a  </span><br><span class="line"><span class="comment">#列出当前目录下文件的详细信息 </span></span><br><span class="line">ls -l </span><br><span class="line"><span class="comment">#筛选命令，比如我想查找当前目录下的 markdown 文件</span></span><br><span class="line">ls -lh | grep .md</span><br><span class="line"></span><br><span class="line"><span class="comment">#回当前用户的宿主目录 </span></span><br><span class="line"><span class="built_in">cd</span></span><br><span class="line"><span class="comment">#回当前目录的上一级目录 </span></span><br><span class="line"><span class="built_in">cd</span> .. </span><br><span class="line"><span class="comment">#回上一次所在的目录 </span></span><br><span class="line"><span class="built_in">cd</span> - </span><br><span class="line"><span class="comment">#来指出当前所在的路径</span></span><br><span class="line"><span class="built_in">pwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建一个目录 </span></span><br><span class="line">mkdir 目录名 </span><br><span class="line"><span class="comment">#删除一个空目录 </span></span><br><span class="line">rmdir 空目录名 </span><br><span class="line"><span class="comment">#删除一个文件或多个文件 </span></span><br><span class="line">rm 文件名 文件名 </span><br><span class="line"><span class="comment">#删除一个非空目录下的一切 </span></span><br><span class="line">rm -rf 非空目录名 </span><br><span class="line"></span><br><span class="line"><span class="comment">#创建空文件</span></span><br><span class="line">touch 文件名</span><br><span class="line"><span class="comment">#删除文件</span></span><br><span class="line">rm -rf 文件名</span><br><span class="line"><span class="comment">#查看文件</span></span><br><span class="line">cat 文件名【显示全部内容，文件太大无法全部显示】</span><br><span class="line">cat -n 文件名 【查看内容，并添加行号】</span><br><span class="line"></span><br><span class="line"><span class="comment">#拷贝到目标位置，或者新位置</span></span><br><span class="line">cp原文件名或目录名 目标位置 </span><br><span class="line">mv 原文件名或目录名 新文件名或目录</span><br></pre></td></tr></tbody></table></figure><h2 id="二、系统信息管理"><a href="#二、系统信息管理" class="headerlink" title="二、系统信息管理"></a><strong>二、系统信息管理</strong></h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看内核版本 </span></span><br><span class="line">uname -a </span><br><span class="line"><span class="comment">#查看ubuntu版本 </span></span><br><span class="line">cat /etc/issue </span><br><span class="line"><span class="comment">#查看CPU信息 </span></span><br><span class="line">cat /proc/cpuinfo </span><br><span class="line"><span class="comment">#查看usb设备 </span></span><br><span class="line">lsusb </span><br><span class="line"><span class="comment">#查看PCI设备 </span></span><br><span class="line">lspci</span><br><span class="line"><span class="comment">#查看网络信息</span></span><br><span class="line">ifconfig</span><br><span class="line"><span class="comment">#查看磁盘信息 </span></span><br><span class="line">sudo fdisk -l </span><br><span class="line"><span class="comment">#查看硬盘剩余空间</span></span><br><span class="line">df -h  </span><br><span class="line"><span class="comment">#查看当前的内存使用情况 </span></span><br><span class="line">free -m</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前有哪些进程 </span></span><br><span class="line">ps -A </span><br><span class="line"><span class="comment">#(就是ps -A中的第一列的数字)或者 killall 进程名( 杀死一个进程) </span></span><br><span class="line"><span class="built_in">kill</span> 进程号</span><br><span class="line"><span class="comment">#强制杀死一个进程</span></span><br><span class="line"><span class="built_in">kill</span> -9 进程号  </span><br><span class="line"></span><br><span class="line"><span class="comment">#更改系统用户密码</span></span><br><span class="line">sudo passwd root </span><br><span class="line"></span><br><span class="line"><span class="comment">#进入root权限</span></span><br><span class="line">sudo su</span><br><span class="line"></span><br><span class="line"><span class="comment">#从服务器上同步时间 </span></span><br><span class="line">sudo ntpdate time.nist.gov </span><br><span class="line">sudo ntpdate time.windows.com </span><br></pre></td></tr></tbody></table></figure><h2 id="三、压缩文件处理"><a href="#三、压缩文件处理" class="headerlink" title="三、压缩文件处理"></a><strong>三、压缩文件处理</strong></h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解压缩 xxx.tar.gz </span></span><br><span class="line">tar -zxvf xxx.tar.gz </span><br><span class="line"></span><br><span class="line"><span class="comment">#解压缩 xxx.tar.bz2 </span></span><br><span class="line">tar -jxvf xxx.tar.bz2 </span><br><span class="line"></span><br><span class="line"><span class="comment">#压缩aaa bbb目录为xxx.tar.gz </span></span><br><span class="line">tar -zcvf xxx.tar.gz aaa bbb </span><br><span class="line"></span><br><span class="line"><span class="comment">#压缩aaa bbb目录为xxx.tar.bz2 </span></span><br><span class="line">tar -jcvf xxx.tar.bz2 aaa bbb </span><br><span class="line"></span><br><span class="line"><span class="comment">#解压缩 RAR 文件 </span></span><br><span class="line"><span class="comment">#1) 先安装 </span></span><br><span class="line">sudo apt-get install rar unrar </span><br><span class="line">sudo ln -f /usr/bin/rar /usr/bin/unrar </span><br><span class="line"><span class="comment">#2) 解压 </span></span><br><span class="line">unrar x aaaa.rar </span><br><span class="line"><span class="comment">#安装deb文件</span></span><br><span class="line">sudo dpkg -i xxx.deb </span><br></pre></td></tr></tbody></table></figure><h2 id="四、换国内源"><a href="#四、换国内源" class="headerlink" title="四、换国内源"></a><strong>四、换国内源</strong></h2><h3 id="apt换源"><a href="#apt换源" class="headerlink" title="apt换源"></a>apt换源</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">--</span><br><span class="line"></span><br><span class="line"><span class="comment">#刷新源</span></span><br><span class="line">sudo apt update</span><br></pre></td></tr></tbody></table></figure><h3 id="conda换源"><a href="#conda换源" class="headerlink" title="conda换源"></a>conda换源</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前的下载源</span></span><br><span class="line">conda config --show</span><br><span class="line"></span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/</span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge </span><br><span class="line">conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/msys2/</span><br><span class="line"><span class="comment">#设置搜索时显示通道地址 从channel中安装包时显示channel的url，这样就可以知道包的安装来源</span></span><br><span class="line">conda config --<span class="built_in">set</span> show_channel_urls yes</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看现在的下载源</span></span><br><span class="line">conda config --show</span><br></pre></td></tr></tbody></table></figure><h3 id="conda命令"><a href="#conda命令" class="headerlink" title="conda命令"></a>conda命令</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个名为python34的环境，指定Python版本是3.4</span></span><br><span class="line">conda create --name python34 python=3.4</span><br><span class="line"><span class="comment">#使用activate激活某个环境</span></span><br><span class="line"><span class="built_in">source</span> activate python34 <span class="comment"># for Linux &amp; Mac</span></span><br><span class="line"><span class="comment"># 离开环境</span></span><br><span class="line"><span class="built_in">source</span> deactivate</span><br><span class="line"><span class="comment">#删除一个已有的环境</span></span><br><span class="line">conda remove --name python34 --all</span><br><span class="line"><span class="comment">#克隆环境</span></span><br><span class="line">conda create --name newname --<span class="built_in">clone</span> oldname </span><br><span class="line"><span class="comment">#列出所有环境</span></span><br><span class="line">conda info -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已经安装的packages</span></span><br><span class="line">conda list</span><br><span class="line"><span class="comment"># 查看某个指定环境的已安装包</span></span><br><span class="line">conda list -n python34</span><br><span class="line"></span><br><span class="line"><span class="comment"># pip安装加上国内源</span></span><br><span class="line">pip install &lt;name&gt; -i https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">pip install &lt;name&gt; -i http://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></tbody></table></figure><h2 id="五、apt命令"><a href="#五、apt命令" class="headerlink" title="五、apt命令"></a><strong>五、apt命令</strong></h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install package 安装包 </span><br><span class="line">sudo apt-get install package - - reinstall 重新安装包 </span><br><span class="line">sudo apt-get -f install 修复安装”-f = –fix-missing” </span><br><span class="line">sudo apt-get remove package 删除包 </span><br><span class="line">sudo apt-get remove package - - purge 删除包，包括删除配置文件等 </span><br><span class="line">sudo apt-get update 更新源 </span><br><span class="line">sudo apt-get upgrade 更新已安装的包 </span><br><span class="line">sudo apt-get clean 清理所有软件缓存（即缓存在/var/cache/apt/archives目录里的deb包）</span><br><span class="line">sudo apt-get autoclean 清理旧版本的软件缓存 </span><br><span class="line">sudo apt-get autoremove  删除系统不再使用的孤立软件</span><br></pre></td></tr></tbody></table></figure><h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a><strong>六、其他</strong></h2><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 给运行权限</span></span><br><span class="line">chmod +x  *.sh</span><br><span class="line"><span class="comment"># 给所有权限</span></span><br><span class="line">chmod 777  *.sh</span><br><span class="line"><span class="comment"># 每10s显卡情况</span></span><br><span class="line">watch -n 10 nvidia-smi</span><br><span class="line"><span class="comment"># 查看cuda版本</span></span><br><span class="line">nvcc -V</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用LXD搭建多人共用GPU</title>
      <link href="/2020/11/26/lxd-gpu2.0/"/>
      <url>/2020/11/26/lxd-gpu2.0/</url>
      
        <content type="html"><![CDATA[<h2 id="1、-背景"><a href="#1、-背景" class="headerlink" title="1、 背景"></a>1、 背景</h2><p>对实验室多台工作站的多块GPU进行合理的管理和使用分配规划及申请/授权/使用自动管理，希望工作站可以作为服务器使用，能够多人同时使用，互不影响。</p><h2 id="2、需求"><a href="#2、需求" class="headerlink" title="2、需求"></a>2、需求</h2><ul><li>不同用户之间不能相互影响且可以同时使用</li><li>用户注册登录使用需要被授权</li><li>用户要能方便地访问自己的“机器”</li><li>用户要有足够大的权限，能自由地安装程序，能自由地访问网络</li><li>用户不被允许直接操作宿主机</li></ul><h2 id="3、具体方案"><a href="#3、具体方案" class="headerlink" title="3、具体方案"></a>3、具体方案</h2><h3 id="3-1、LXD-ZFS-安装及配置"><a href="#3-1、LXD-ZFS-安装及配置" class="headerlink" title="3.1、LXD/ZFS 安装及配置"></a>3.1、LXD/ZFS 安装及配置</h3><h4 id="LXD-软件安装s"><a href="#LXD-软件安装s" class="headerlink" title="LXD 软件安装s"></a>LXD 软件安装s</h4><p>LXD：用于创建和管理容器<br>ZFS：用于管理物理磁盘，支持 LXD 高级功能，负责容器存储。<br>Bridge-Utils：用于搭建网桥，负责容器上网。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install lxd zfsutils-linux bridge-utils</span><br></pre></td></tr></tbody></table></figure><h4 id="初始化-LXD"><a href="#初始化-LXD" class="headerlink" title="初始化 LXD"></a>初始化 LXD</h4><p>运行 <code>sudo lxd init</code> 进行 LXD 初始化配置，选项如下图：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/lxd.png" alt="lxd"></p><ul><li>LXD Clustering：不需要</li><li>new storage pool：需要创建一个存储池</li><li>Name of storage pool：给存储池命名</li><li>storage backend：存储后端，使用 ZFS</li><li>Create a new ZFS pool：需要创建一个 ZFS 池</li><li>use an existing block device：Yes</li><li>Path to block device：使用已有的磁盘分区用于 ZFS 的存储后端。这里用的2T硬盘</li><li>MAAS server?：不知道是啥，不需要</li><li>new local network bridge?：需要，我只需要使用 LXD 默认的网桥即可。</li><li>new bridge be called：给网桥命名</li><li>iPv4：默认 auto</li><li>IPv6：默认 auto</li><li>LXD available over the network？：默认 no</li><li>stale cached？：默认 yes</li><li>YAML printed？：选择yes，查看容器配置信息</li></ul><h4 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h4><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个remote链接，指向TUNA镜像站。</span></span><br><span class="line">sudo lxc remote add tuna-images https://mirrors.tuna.tsinghua.edu.cn/lxc-images/ --protocol=simplestreams --public</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看镜像列表，寻找合适的镜像的FINGERPRINT，用于下载</span></span><br><span class="line">sudo lxc image list tuna-images: </span><br><span class="line"><span class="meta">#</span><span class="bash"> 举例，创建一个名为tiger的容器。在lxc清华源中使用ubuntu/18.04</span></span><br><span class="line">sudo lxc launch tuna-images:ubuntu/18.04 tiger</span><br></pre></td></tr></tbody></table></figure><h4 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h4><p>运行 <code>sudo lxc list</code> 进行容器列表查看。</p><p>运行 <code>sudo lxc exec &lt;ContainerTemplateName&gt; bash</code>  可进入容器的 root 用户下 bash。</p><p>可以使用 <code>su ubuntu</code> 或 <code>sudo su</code> 进行用户切换。</p><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">使用以下命令更改容器系统用户密码</span></span><br><span class="line">passwd ubuntu </span><br><span class="line">passwd root</span><br><span class="line"><span class="meta">#</span><span class="bash">后面远程登陆会用到</span></span><br></pre></td></tr></tbody></table></figure><h4 id="设置容器"><a href="#设置容器" class="headerlink" title="设置容器"></a>设置容器</h4><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#换源，加速apt-get insatll</span></span><br><span class="line">sudo vim /etc/apt/sources.list</span><br><span class="line">====</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.163.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">===</span><br><span class="line"><span class="comment">#刷新源</span></span><br><span class="line">sudo apt update</span><br><span class="line"><span class="comment">#安装必要工具</span></span><br><span class="line">apt install make cmake openssh-server gcc g++ build-essential</span><br><span class="line"><span class="comment">#启动ssh命令 </span></span><br><span class="line">sudo service ssh start</span><br><span class="line"><span class="comment">#端口转发60601是我们定的端口号，通过宿主机的60601端口号监听容器中22端口号（SSH默认端口号）</span></span><br><span class="line">sudo lxc config device add &lt;container&gt; proxy0 proxy listen=tcp:172.22.24.126:60601 connect=tcp:10.152.210.183:22 <span class="built_in">bind</span>=host</span><br><span class="line"><span class="comment">#此时就可以使用校园网访问</span></span><br><span class="line">ssh ubuntu@172.22.24.126 -p 60601</span><br></pre></td></tr></tbody></table></figure><h3 id="3-2、配置共享目录和-GPU"><a href="#3-2、配置共享目录和-GPU" class="headerlink" title="3.2、配置共享目录和 GPU"></a>3.2、配置共享目录和 GPU</h3><p>配置共享目录</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc config <span class="built_in">set</span> &lt;yourContainerName&gt; security.privileged <span class="literal">true</span></span><br><span class="line">sudo lxc config device add &lt;yourContainerName&gt; &lt;shareName&gt; disk <span class="built_in">source</span>=path1 path=path2</span><br><span class="line"><span class="comment">#举例</span></span><br><span class="line">sudo lxc config device add tiger father disk <span class="built_in">source</span>=/home/gdz path=/father</span><br><span class="line"><span class="comment"># path1为宿主机路径，path2为容器内路径</span></span><br></pre></td></tr></tbody></table></figure><p>配置GPU</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#为容器添加所有GPU:</span></span><br><span class="line">sudo lxc config device add &lt;yourContainerName&gt; gpu gpu</span><br><span class="line"><span class="comment">#添加指定GPU： </span></span><br><span class="line">sudo lxc config device add &lt;yourContainerName&gt; gpu0 gpu id=0</span><br><span class="line"><span class="comment"># 安装驱动：在容器中显卡驱动不需要安装内核文件，安装宿主机显卡驱动的版本，通过共享目录传至容器中</span></span><br><span class="line">sudo sh /NVIDIA-Linux-x86_64-xxx.xx.run --no-kernel-module </span><br></pre></td></tr></tbody></table></figure><p>挂载 <code>nvidia-uvm</code></p><p>①如果宿主机没有<code>/dev/nvidia-uvm</code>设备，需要通过以下命令挂载设备：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/sbin/modprobe nvidia-uvm</span><br><span class="line">D=`grep nvidia-uvm /proc/devices | awk <span class="string">'{print $1}'</span>`</span><br><span class="line">mknod -m 666 /dev/nvidia-uvm c <span class="variable">$D</span> 0</span><br></pre></td></tr></tbody></table></figure><p>②挂载设备到容器：</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc config device add yourContainerName nvidia-uvm unix-char path=/dev/nvidia-uvm</span><br></pre></td></tr></tbody></table></figure><h3 id="3-3、配置图形桌面"><a href="#3-3、配置图形桌面" class="headerlink" title="3.3、配置图形桌面"></a>3.3、配置图形桌面</h3><blockquote><p>Xrdp 是 Microsoft 远程桌面协议 (RDP) 的开源实现，允许以图形方式控制远程系统。使用 RDP 可以登录到远程计算机并创建一个真实的桌面会话，就像您已登录到本地计算机一样。</p><p>Ubuntu 存储库中有好几个桌面环境，这里我们将安装 Xfce 。它是一个快速，稳定和轻量级的桌面环境，非常适合在远程服务器上使用</p></blockquote><p><strong>安装 Xrdp</strong></p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install xrdp</span><br><span class="line"><span class="comment"># 安装完成后 Xrdp 服务将自动运行，您可以通过键入以下指令来验证 Xrdp 是否正在运行</span></span><br><span class="line">sudo systemctl status xrdp</span><br></pre></td></tr></tbody></table></figure><p><strong>配置 Xrdp</strong></p><p>Xrdp 的配置文件位于 /etc/xrdp 目录。对于 Xrdp 的基本连接，只需要配置 Xrdp 即可使用 Xfce 。</p><figure class="highlight javascript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/xrdp/xrdp.ini</span><br></pre></td></tr></tbody></table></figure><p>在文件末尾添加以下内容并保存：</p><p>exec startxfce4</p><p>此外，该文件中可配置 xrdp 远程桌面服务的端口号（默认端口为3389）</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重新启动 Xrdp 服务：</span></span><br><span class="line">sudo systemctl restart xrdp</span><br></pre></td></tr></tbody></table></figure><p><strong>端口转发</strong></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 在安装好XRDP后，与之前一样，因为我们ping不通容器，所以我们需要使用宿主机的端口号监听容器的xrdp的端口3389</span><br><span class="line">sudo lxc config device add &lt;container&gt; proxy1 proxy listen=tcp:172.22.24.126:60611 connect=tcp:10.152.210.183:3389 bind=host</span><br></pre></td></tr></tbody></table></figure><p>现在可以通过windows的远程连接或者ubuntu的Remmina 来使用容器。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201126002245828.png" alt="1"></p><h3 id="3-4、创建容器模板并分发"><a href="#3-4、创建容器模板并分发" class="headerlink" title="3.4、创建容器模板并分发"></a>3.4、创建容器模板并分发</h3><p><strong>为容器修改参数配置</strong></p> <figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc config edit YourContainerName</span><br></pre></td></tr></tbody></table></figure><p>一般使用以下的配置即可满足</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1.png" alt="img"></p><p>配置默认容器参数（新容器的参数会继承default配置的参数，容器会优先使用自己的参数）</p> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc profile edit default</span><br></pre></td></tr></tbody></table></figure><p><strong>我们把这个配置好的容器当成模板，保存为镜像</strong>。</p><p>停止容器</p> <figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc stop test</span><br></pre></td></tr></tbody></table></figure><p>将该容器复制为ubuntudemo，作为以后容器分发的模板</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc copy tiger ubuntudemo</span><br></pre></td></tr></tbody></table></figure><p>并删除端口转发</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc config device remove ubuntudemo proxy1</span><br></pre></td></tr></tbody></table></figure><p>现在，建立第二个容器bigdog吧，记得把端口转发设置下，并设置容器的初始密码</p><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo lxc copy tiger ubuntudemo</span><br><span class="line">sudo lxc config device add bigdog proxy1 proxy listen=tcp:xx.xx.xx.xx:60621 connect=tcp:10.176.88.68:3389 <span class="built_in">bind</span>=host</span><br></pre></td></tr></tbody></table></figure><h3 id="3-5、LXDUI-可视化管理界面"><a href="#3-5、LXDUI-可视化管理界面" class="headerlink" title="3.5、LXDUI 可视化管理界面"></a>3.5、LXDUI 可视化管理界面</h3><p>在宿主机上根据<a href="https://github.com/AdaptiveScale/lxdui">AdaptiveScale/lxdui: LXDUI is a web UI for the native Linux container technology LXD/LXC (github.com)</a>配置可视化管理界面，如下，方便地管理容器</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201126153135876.png" alt=""></p><h2 id="4、宿主机的远程访问"><a href="#4、宿主机的远程访问" class="headerlink" title="4、宿主机的远程访问"></a>4、宿主机的远程访问</h2><p>使用xdrp访问宿主机默认桌面</p><h3 id="4-1、设置ubuntu"><a href="#4-1、设置ubuntu" class="headerlink" title="4.1、设置ubuntu"></a>4.1、设置ubuntu</h3><blockquote><p>首先，我们先设置Ubuntu的远程控制，将其设置为允许被远程连接，进入系统-》首选项-》桌面共享，或者直接搜索桌面共享</p><p>将【允许其他人查看您的桌面】这一项勾上，然后在安全那项，勾选【要求远程用户输入此密码】，并设置远程密码。并且我们取消勾选【必须为对本机器的每次访问进行确定】（这样做，是为了被远程的时候不需要再确认，否则每次远程都要人为确认才能被远程，会很繁琐）如图所示：</p></blockquote><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201126153209005.png" alt=""></p><h3 id="4-2、安装xdrp-vnc"><a href="#4-2、安装xdrp-vnc" class="headerlink" title="4.2、安装xdrp+vnc"></a>4.2、安装xdrp+vnc</h3><figure class="highlight sh"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#步骤一、安装TigerVNC Server软件包</span></span><br><span class="line">sudo apt-get install tightvncserver （使用在线安装）</span><br><span class="line"><span class="comment">#步骤二、安装xrdp</span></span><br><span class="line">sudo apt-get install xrdp -y</span><br><span class="line"><span class="comment">#步骤三、编辑配置：</span></span><br><span class="line">sudo vi /etc/xrdp/startwm.sh</span><br><span class="line"><span class="comment">#把最下面的test和exec两行注释掉，添加一行</span></span><br><span class="line">unity</span><br></pre></td></tr></tbody></table></figure><h3 id="4-3、安装dconf-editor-取消权限限制"><a href="#4-3、安装dconf-editor-取消权限限制" class="headerlink" title="4.3、安装dconf-editor(取消权限限制)"></a>4.3、安装dconf-editor(取消权限限制)</h3><p>再次，我们需要取消掉请求加密的功能，否则缺少这一步是无法远程上的，这个时候我们需要安装dconf-editor工具进行配置，输入以下命令：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install dconf-editor</span><br></pre></td></tr></tbody></table></figure><p>安装完成之后，我们需要打开dconf-editor工具，在桌面搜索dconf-editor打开，如图所示：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201126153453473.png" alt=""></p><p>打开之后，依次展开org-&gt;gnome-&gt;desktop-&gt;remote-access，然后取消 “requlre-encryption”的勾选即可。如图所示：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201126153555644.png" alt=""></p><p>至此，前期准备工作已经完成，后面直接通过VNC工具或者Windows自带的mstsc(远程桌面控制)进行访问就行。</p><h2 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h2><p>现在就可以在宿舍或家里使用校园网访问工作站了，不管是宿主机还是容器都可以远程访问桌面。容器内已安装好cuda和显卡驱动，以及pycharm、miniconda、Chrome浏览器。</p><p>通过此次练习与配置，对Linux环境更加熟悉了，准备整理一篇Linux常用命令供自己查阅使用。</p><p>参考链接：</p><p><a href="https://github.com/shenuiuin/LXD_GPU_SERVER">shenuiuin/LXD_GPU_SERVER: 实验室GPU服务器的LXD虚拟化 (github.com)</a></p><p><a href="https://blog.csdn.net/wangke0809/article/details/80235989">https://blog.csdn.net/wangke0809/article/details/80235989</a></p><p><a href="https://blog.yangl1996.com/post/gpu-passthrough-for-lxc/">https://blog.yangl1996.com/post/gpu-passthrough-for-lxc/</a></p><p><a href="https://abcdabcd987.com/setup-shared-gpu-server-for-labs/">https://abcdabcd987.com/setup-shared-gpu-server-for-labs/</a></p><p><a href="https://github.com/abcdabcd987/lxc-gpu">https://github.com/abcdabcd987/lxc-gpu</a></p><p><a href="https://blog.csdn.net/weixin_42749767/article/details/83720831?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.pc_relevant_is_cache&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.pc_relevant_is_cache">https://blog.csdn.net/weixin_42749767/article/details/83720831?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.pc_relevant_is_cache&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.pc_relevant_is_cache</a></p><p><a href="https://developer.aliyun.com/article/578196">https://developer.aliyun.com/article/578196</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSM框架整合</title>
      <link href="/2020/10/21/ssm-kuang-jia-zheng-he/"/>
      <url>/2020/10/21/ssm-kuang-jia-zheng-he/</url>
      
        <content type="html"><![CDATA[<h3 id="1-环境配置"><a href="#1-环境配置" class="headerlink" title="1. 环境配置"></a>1. 环境配置</h3><h4 id="1-1-新建一Maven项目！ssmbuild-，-添加web的支持"><a href="#1-1-新建一Maven项目！ssmbuild-，-添加web的支持" class="headerlink" title="1.1 新建一Maven项目！ssmbuild ， 添加web的支持"></a>1.1 新建一Maven项目！ssmbuild ， 添加web的支持</h4><h4 id="1-2-导入相关的pom依赖！"><a href="#1-2-导入相关的pom依赖！" class="headerlink" title="1.2 导入相关的pom依赖！"></a>1.2 导入相关的pom依赖！</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--Junit--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--数据库驱动--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.47<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 数据库连接池 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.mchange<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>c3p0<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--Servlet - JSP --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--Mybatis--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--Spring--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.16.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="1-3-Maven资源过滤设置"><a href="#1-3-Maven资源过滤设置" class="headerlink" title="1.3 Maven资源过滤设置"></a>1.3 Maven资源过滤设置</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/java<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">directory</span>&gt;</span>src/main/resources<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">includes</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.properties<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">include</span>&gt;</span>**/*.xml<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">includes</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">filtering</span>&gt;</span>false<span class="tag">&lt;/<span class="name">filtering</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="1-4-建立基本结构和配置框架！"><a href="#1-4-建立基本结构和配置框架！" class="headerlink" title="1.4 建立基本结构和配置框架！"></a>1.4 建立基本结构和配置框架！</h4><p>com.gdz.pojo<br>com.gdz.dao<br>com.gdz.service<br>com.gdz.controller<br><strong>mybatis-config.xml</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>applicationContext.xml</strong></p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-Mybatis层编写"><a href="#2-Mybatis层编写" class="headerlink" title="2. Mybatis层编写"></a>2. Mybatis层编写</h4><h4 id="2-1-数据库配置文件-database-properties"><a href="#2-1-数据库配置文件-database-properties" class="headerlink" title="2.1 数据库配置文件 database.properties"></a>2.1 数据库配置文件 database.properties</h4><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driver</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.url</span>=<span class="string">jdbc:mysql://localhost:3306/ssmbuild?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf8</span></span><br><span class="line"><span class="meta">jdbc.username</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">gudongzhou678</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-2-IDEA关联数据库"><a href="#2-2-IDEA关联数据库" class="headerlink" title="2.2 IDEA关联数据库"></a>2.2 IDEA关联数据库</h4><h4 id="2-3-编写MyBatis的核心配置文件"><a href="#2-3-编写MyBatis的核心配置文件" class="headerlink" title="2.3 编写MyBatis的核心配置文件"></a>2.3 编写MyBatis的核心配置文件</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span></span></span><br><span class="line"><span class="meta">       <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">       <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"com.gdz.pojo"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/gdz/dao/BookMapper.xml"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-4-编写数据库对应的实体类"><a href="#2-4-编写数据库对应的实体类" class="headerlink" title="2.4 编写数据库对应的实体类"></a>2.4 编写数据库对应的实体类</h4><p>com.gdz.pojo.Books<br>使用lombok插件！</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gdz.pojo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.NoArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Books</span> </span>{</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookID;</span><br><span class="line">    <span class="keyword">private</span> String bookName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> bookCounts;</span><br><span class="line">    <span class="keyword">private</span> String detail;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-5-编写Dao层的-Mapper接口！"><a href="#2-5-编写Dao层的-Mapper接口！" class="headerlink" title="2.5 编写Dao层的 Mapper接口！"></a>2.5 编写Dao层的 Mapper接口！</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gdz.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gdz.pojo.Books;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookMapper</span> </span>{</span><br><span class="line">    <span class="comment">//增加一个Book</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books book)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id删除一个Book</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Book</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查询,返回一个Book</span></span><br><span class="line">    <span class="function">Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部Book,返回list集合</span></span><br><span class="line">    <span class="function">List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="2-6-编写接口对应的-Mapper-xml-文件"><a href="#2-6-编写接口对应的-Mapper-xml-文件" class="headerlink" title="2.6 编写接口对应的 Mapper.xml 文件"></a>2.6 编写接口对应的 Mapper.xml 文件</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span></span></span><br><span class="line"><span class="meta">        <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.gdz.dao.BookMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--增加一个Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addBook"</span> <span class="attr">parameterType</span>=<span class="string">"Books"</span>&gt;</span></span><br><span class="line">        insert into ssmbuild.books(bookName, bookCounts, detail)</span><br><span class="line">        values (#{bookName}, #{bookCounts}, #{detail})</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据id删除一个Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteBookById"</span> <span class="attr">parameterType</span>=<span class="string">"int"</span>&gt;</span></span><br><span class="line">        delete</span><br><span class="line">        from ssmbuild.books</span><br><span class="line">        where bookID = #{bookID}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--更新Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBook"</span> <span class="attr">parameterType</span>=<span class="string">"Books"</span>&gt;</span></span><br><span class="line">        update ssmbuild.books</span><br><span class="line">        set bookName   = #{bookName},</span><br><span class="line">            bookCounts = #{bookCounts},</span><br><span class="line">            detail     = #{detail}</span><br><span class="line">        where bookID = #{bookID}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--根据id查询,返回一个Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryBookById"</span> <span class="attr">resultType</span>=<span class="string">"Books"</span>&gt;</span></span><br><span class="line">        select *</span><br><span class="line">        from ssmbuild.books</span><br><span class="line">        where bookID = #{bookID}</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--查询全部Book--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"queryAllBook"</span> <span class="attr">resultType</span>=<span class="string">"Books"</span>&gt;</span></span><br><span class="line">        SELECT *</span><br><span class="line">        from ssmbuild.books</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="2-7-编写Service层的接口和实现类"><a href="#2-7-编写Service层的接口和实现类" class="headerlink" title="2.7 编写Service层的接口和实现类"></a>2.7 编写Service层的接口和实现类</h4><p>接口：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gdz.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gdz.pojo.Books;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookService</span> </span>{</span><br><span class="line">    <span class="comment">//增加一个Book</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books book)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id删除一个Book</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新Book</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据id查询,返回一个Book</span></span><br><span class="line">    <span class="function">Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询全部Book,返回list集合</span></span><br><span class="line">    <span class="function">List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>实现类：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.gdz.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.gdz.dao.BookMapper;</span><br><span class="line"><span class="keyword">import</span> com.gdz.pojo.Books;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title">BookService</span> </span>{</span><br><span class="line">    <span class="comment">//调用dao层的操作，设置一个set接口，方便Spring管理</span></span><br><span class="line">    <span class="keyword">private</span> BookMapper bookMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBookMapper</span><span class="params">(BookMapper bookMapper)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.bookMapper = bookMapper;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addBook</span><span class="params">(Books book)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bookMapper.addBook(book);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bookMapper.deleteBookById(id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateBook</span><span class="params">(Books books)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bookMapper.updateBook(books);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Books <span class="title">queryBookById</span><span class="params">(<span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryBookById(id);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Books&gt; <span class="title">queryAllBook</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> bookMapper.queryAllBook();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p><strong>OK，到此，底层需求操作编写完毕！</strong></p><hr><h3 id="3-Spring层"><a href="#3-Spring层" class="headerlink" title="3. Spring层"></a>3. Spring层</h3><h4 id="3-1-编写Spring整合Mybatis的配置文件"><a href="#3-1-编写Spring整合Mybatis的配置文件" class="headerlink" title="3.1 编写Spring整合Mybatis的配置文件"></a>3.1 编写Spring整合Mybatis的配置文件</h4><blockquote><p>spring-dao.xml</p></blockquote><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 配置整合mybatis --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 1.关联数据库文件 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:database.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 2.数据库连接池 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--数据库连接池</span></span><br><span class="line"><span class="comment">       dbcp 半自动化操作 不能自动连接</span></span><br><span class="line"><span class="comment">       c3p0 自动化操作（自动的加载配置文件 并且设置到对象里面）</span></span><br><span class="line"><span class="comment">   --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置连接池属性 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"${jdbc.driver}"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"${jdbc.url}"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"${jdbc.username}"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"${jdbc.password}"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">&lt;!-- c3p0连接池的私有属性 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"30"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 关闭连接后不自动commit --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"autoCommitOnClose"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 获取连接超时时间 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span> <span class="attr">value</span>=<span class="string">"10000"</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 当获取连接失败重试次数 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireRetryAttempts"</span> <span class="attr">value</span>=<span class="string">"2"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 3.配置SqlSessionFactory对象 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口注入到spring容器中 --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--解释 ：https://www.cnblogs.com/jpfss/p/7799806.html--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 注入sqlSessionFactory --&gt;</span></span><br><span class="line">       &lt;propertyname="sqlSessionFactoryBeanName"value="sqlSessionFactory"/&gt;</span><br><span class="line">       <span class="comment">&lt;!-- 给出需要扫描Dao接口包 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.gdz.dao"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p>我们这里数据源使用c3p0连接池；</p><h4 id="3-2-Spring整合service层"><a href="#3-2-Spring整合service层" class="headerlink" title="3.2 Spring整合service层"></a>3.2 Spring整合service层</h4><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 扫描service相关的bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.gdz.service"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--BookServiceImpl注入到IOC容器中--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"BookServiceImpl"</span> <span class="attr">class</span>=<span class="string">"com.gdz.service.BookServiceImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"bookMapper"</span> <span class="attr">ref</span>=<span class="string">"bookMapper"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入数据库连接池 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p><strong>Spring层搞定！再次理解一下，Spring就是一个大杂烩，一个容器！对吧！</strong></p><h3 id="4-SpringMVC层"><a href="#4-SpringMVC层" class="headerlink" title="4. SpringMVC层"></a>4. SpringMVC层</h3><h4 id="4-1-配置文件"><a href="#4-1-配置文件" class="headerlink" title="4.1 配置文件"></a>4.1 配置文件</h4><h5 id="web-xml"><a href="#web-xml" class="headerlink" title="web.xml"></a>web.xml</h5><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--DispatcherServlet--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="comment">&lt;!--一定要注意:我们这里加载的是总的配置文件，之前被这里坑了！--&gt;</span>  </span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:applicationContext.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!--encodingFilter--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">          org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">       <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>utf-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment">&lt;!--Session过期时间--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>15<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h5 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h5><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">   http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="string"><span class="tag">   https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 配置SpringMVC --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 1.开启SpringMVC注解驱动 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 2.静态资源默认servlet配置--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 3.配置jsp 显示ViewResolver视图解析器 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"viewClass"</span> <span class="attr">value</span>=<span class="string">"org.springframework.web.servlet.view.JstlView"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- 4.扫描web相关的bean --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.kuang.controller"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><p> 配置文件，暂时结束！</p><h5 id="Spring配置整合文件，applicationContext-xml"><a href="#Spring配置整合文件，applicationContext-xml" class="headerlink" title="Spring配置整合文件，applicationContext.xml"></a>Spring配置整合文件，applicationContext.xml</h5><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"spring-dao.xml"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"spring-service.xml"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"spring-mvc.xml"</span>/&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="4-2-Controller-和-视图层编写"><a href="#4-2-Controller-和-视图层编写" class="headerlink" title="4.2 Controller 和 视图层编写"></a>4.2 Controller 和 视图层编写</h4><h5 id="BookController-类编写-，-方法一：查询全部书籍"><a href="#BookController-类编写-，-方法一：查询全部书籍" class="headerlink" title="BookController 类编写 ， 方法一：查询全部书籍"></a>BookController 类编写 ， 方法一：查询全部书籍</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping("/book")</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookController</span> </span>{</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier("BookServiceImpl")</span></span><br><span class="line">   <span class="keyword">private</span> BookService bookService;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@RequestMapping("/allBook")</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span> </span>{</span><br><span class="line">       List&lt;Books&gt; list = bookService.queryAllBook();</span><br><span class="line">       model.addAttribute(<span class="string">"list"</span>, list);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"allBook"</span>;</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="编写首页-index-jsp"><a href="#编写首页-index-jsp" class="headerlink" title="编写首页 index.jsp"></a>编写首页 index.jsp</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;首页&lt;/title&gt;</span><br><span class="line">   &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">       a {</span><br><span class="line">           text-decoration: none;</span><br><span class="line">           color: black;</span><br><span class="line">           font-size: 18px;</span><br><span class="line">      }</span><br><span class="line">       h3 {</span><br><span class="line">           width: 180px;</span><br><span class="line">           height: 38px;</span><br><span class="line">           margin: 100px auto;</span><br><span class="line">           text-align: center;</span><br><span class="line">           line-height: 38px;</span><br><span class="line">           background: deepskyblue;</span><br><span class="line">           border-radius: 4px;</span><br><span class="line">      }</span><br><span class="line">   &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;h3&gt;</span><br><span class="line">   &lt;a href=<span class="string">"${pageContext.request.contextPath}/book/allBook"</span>&gt;点击进入列表页&lt;/a&gt;</span><br><span class="line">&lt;/h3&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="书籍列表页面-allbook-jsp"><a href="#书籍列表页面-allbook-jsp" class="headerlink" title="书籍列表页面 allbook.jsp"></a>书籍列表页面 allbook.jsp</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;书籍展示&lt;/title&gt;</span><br><span class="line">    &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">    &lt;link href=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"page-header"</span>&gt;</span><br><span class="line">                &lt;h1&gt;</span><br><span class="line">                    &lt;small&gt;书籍列表 -------- 显示所有书籍&lt;/small&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"row"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-md-4 column"</span>&gt;</span><br><span class="line">            &lt;a <span class="class"><span class="keyword">class</span></span>=<span class="string">"btn btn-primary"</span> href=<span class="string">"${pageContext.request.contextPath}/book/toAddBook"</span>&gt;新增书籍&lt;/a&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-mid-12 column"</span>&gt;</span><br><span class="line">            &lt;table <span class="class"><span class="keyword">class</span></span>=<span class="string">"table table-hover table-striped"</span>&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                    &lt;tr&gt;</span><br><span class="line">                        &lt;th&gt;书籍编号&lt;/th&gt;</span><br><span class="line">                        &lt;th&gt;书籍名称&lt;/th&gt;</span><br><span class="line">                        &lt;th&gt;书籍数量&lt;/th&gt;</span><br><span class="line">                        &lt;th&gt;书籍详情&lt;/th&gt;</span><br><span class="line">                        &lt;th&gt;操作&lt;/th&gt;</span><br><span class="line">                    &lt;/tr&gt;</span><br><span class="line">                &lt;/thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                    &lt;c:forEach <span class="keyword">var</span>=<span class="string">"book"</span> items=<span class="string">"${list}"</span>&gt;</span><br><span class="line">                        &lt;tr&gt;</span><br><span class="line">                            &lt;td&gt;${book.bookID}&lt;/td&gt;</span><br><span class="line">                            &lt;td&gt;${book.bookName}&lt;/td&gt;</span><br><span class="line">                            &lt;td&gt;${book.bookCounts}&lt;/td&gt;</span><br><span class="line">                            &lt;td&gt;${book.detail}&lt;/td&gt;</span><br><span class="line">                            &lt;th&gt;</span><br><span class="line">                                &lt;a href=<span class="string">"${pageContext.request.contextPath}/book/toUpdate?id=${book.bookID}"</span>&gt;修改&lt;/a&gt;</span><br><span class="line">                                &amp;nbsp | &amp;nbsp</span><br><span class="line">                                &lt;a href=<span class="string">"#"</span>&gt;删除&lt;/a&gt;</span><br><span class="line">                            &lt;/th&gt;</span><br><span class="line">                        &lt;/tr&gt;</span><br><span class="line">                    &lt;/c:forEach&gt;</span><br><span class="line">                &lt;/tbody&gt;</span><br><span class="line">            &lt;/table&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="BookController-类编写-，-方法二：添加书籍"><a href="#BookController-类编写-，-方法二：添加书籍" class="headerlink" title="BookController 类编写 ， 方法二：添加书籍"></a>BookController 类编写 ， 方法二：添加书籍</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping("/toAddBook")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toAddPaper</span><span class="params">()</span> </span>{</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"addBook"</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping("/addBook")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addPaper</span><span class="params">(Books books)</span> </span>{</span><br><span class="line">   System.out.println(books);</span><br><span class="line">   bookService.addBook(books);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"redirect:/book/allBook"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h5 id="添加书籍页面：addBook-jsp"><a href="#添加书籍页面：addBook-jsp" class="headerlink" title="添加书籍页面：addBook.jsp"></a>添加书籍页面：addBook.jsp</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;新增书籍&lt;/title&gt;</span><br><span class="line">   &lt;!-- 引入 Bootstrap --&gt;</span><br><span class="line">   &lt;link href=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line">           &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"page-header"</span>&gt;</span><br><span class="line">               &lt;h1&gt;</span><br><span class="line">                   &lt;small&gt;新增书籍&lt;/small&gt;</span><br><span class="line">               &lt;/h1&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;form action=<span class="string">"${pageContext.request.contextPath}/book/addBook"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">           &lt;label&gt;书籍名称：&lt;/label&gt;</span><br><span class="line">           &lt;input type=<span class="string">"text"</span> name=<span class="string">"bookName"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> required&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">           &lt;label&gt;书籍数量：&lt;/label&gt;</span><br><span class="line">           &lt;input type=<span class="string">"text"</span> name=<span class="string">"bookCounts"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> required&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">           &lt;label&gt;书籍详情：&lt;/label&gt;</span><br><span class="line">           &lt;input type=<span class="string">"text"</span> name=<span class="string">"detail"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> required&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">           &lt;input type=<span class="string">"submit"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> value=<span class="string">"添加"</span>&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h5 id="BookController-类编写-，-方法三：修改书籍"><a href="#BookController-类编写-，-方法三：修改书籍" class="headerlink" title="BookController 类编写 ， 方法三：修改书籍"></a>BookController 类编写 ， 方法三：修改书籍</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/toUpdate")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpdatePaper</span><span class="params">(<span class="keyword">int</span> id,Model model)</span></span>{</span><br><span class="line">        Books books = bookService.queryBookById(id);</span><br><span class="line">        model.addAttribute(<span class="string">"book"</span>,books);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"updateBook"</span>;</span><br><span class="line">    }</span><br><span class="line"><span class="meta">@RequestMapping("/updateBook")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateBook</span><span class="params">(Books books)</span></span>{</span><br><span class="line">        bookService.updateBook(books);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/book/allBook"</span>;</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure><h5 id="修改书籍页面-updateBook-jsp"><a href="#修改书籍页面-updateBook-jsp" class="headerlink" title="修改书籍页面  updateBook.jsp"></a>修改书籍页面  updateBook.jsp</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">   &lt;title&gt;修改书籍&lt;/title&gt;</span><br><span class="line">    &lt;link href=<span class="string">"https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css"</span> rel=<span class="string">"stylesheet"</span>&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"container"</span>&gt;</span><br><span class="line"></span><br><span class="line">   &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"row clearfix"</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"col-md-12 column"</span>&gt;</span><br><span class="line">           &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"page-header"</span>&gt;</span><br><span class="line">               &lt;h1&gt;</span><br><span class="line">                   &lt;small&gt;修改书籍&lt;/small&gt;</span><br><span class="line">               &lt;/h1&gt;</span><br><span class="line">           &lt;/div&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">   &lt;/div&gt;</span><br><span class="line">   &lt;form action=<span class="string">"${pageContext.request.contextPath}/book/updateBook"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">       &lt;input type=<span class="string">"hidden"</span> name=<span class="string">"bookID"</span> value=<span class="string">"${book.bookID}"</span>&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">           &lt;label&gt;书籍名称：&lt;/label&gt;</span><br><span class="line">           &lt;input type=<span class="string">"text"</span> name=<span class="string">"bookName"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> value=<span class="string">"${book.bookName}"</span> required&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">           &lt;label&gt;书籍数量：&lt;/label&gt;</span><br><span class="line">           &lt;input type=<span class="string">"text"</span> name=<span class="string">"bookCounts"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> value=<span class="string">"${book.bookCounts}"</span>  required&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">           &lt;label&gt;书籍详情：&lt;/label&gt;</span><br><span class="line">           &lt;input type=<span class="string">"text"</span> name=<span class="string">"detail"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> value=<span class="string">"${book.detail}"</span> required&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line">       &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-group"</span>&gt;</span><br><span class="line">           &lt;input type=<span class="string">"submit"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"form-control"</span> value=<span class="string">"修改"</span>&gt;</span><br><span class="line">       &lt;/div&gt;</span><br><span class="line"></span><br><span class="line">   &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></tbody></table></figure><h5 id="BookController-类编写-，-方法四：删除书籍"><a href="#BookController-类编写-，-方法四：删除书籍" class="headerlink" title="BookController 类编写 ， 方法四：删除书籍"></a>BookController 类编写 ， 方法四：删除书籍</h5><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping("/del/{bookId}")</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">deleteBook</span><span class="params">(<span class="meta">@PathVariable("bookId")</span> <span class="keyword">int</span> id)</span> </span>{</span><br><span class="line">   bookService.deleteBookById(id);</span><br><span class="line">   <span class="keyword">return</span> <span class="string">"redirect:/book/allBook"</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="5-项目结构"><a href="#5-项目结构" class="headerlink" title="5 项目结构"></a>5 项目结构</h3><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/image-20201021150917335.png" alt="image-20201021150917335"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
            <tag> SSM </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础入门</title>
      <link href="/2020/10/08/mysql-ji-chu-ru-men/"/>
      <url>/2020/10/08/mysql-ji-chu-ru-men/</url>
      
        <content type="html"><![CDATA[<hr><p>下面是根据开源项目 <a href="https://github.com/jaywcjlove/mysql-tutorial/blob/master/21-minutes-MySQL-basic-entry.md">21分钟MySQL基础入门</a> 做的学习笔记</p><p><a href="https://www.w3school.com.cn/sql/sql_orderby.asp">W3SCHOOL</a>上的教程链接</p><hr><h2 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h2><p>MySQL版本: Server version: 8.0.20 MySQL Community Server - GPL</p><p>MySQL为关系型数据库，一个关系型数据库是由一个或数个表格组成，如下图：<br><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/20201008103454.png" alt="">))</p><ul><li>表头： 每一列的名称；</li><li>列（col）: 具有相同数据类型的数据的集合</li><li>行(row) :  每一行用来描述某个人/物的具体信息;</li><li>值(value) : 行的具体信息, 每个值必须与该列的数据类型相同;</li><li>键(key) : 表中用来识别某个特定的人\物的方法, 键的值在当前列中具有唯一性。</li></ul><h2 id="登录MySQL"><a href="#登录MySQL" class="headerlink" title="登录MySQL"></a>登录MySQL</h2><p>在cmd中输入：mysql -h 主机名 -u 用户名 -p<br><u>参数说明：</u></p><ul><li>-h : 指定客户端所要登录的 MySQL 主机名, 登录本机(localhost 或 127.0.0.1)该参数可以省略；</li><li>-u : 登录的用户名；</li><li>-p : 告诉服务器将会使用一个密码来登录, 如果所要登录的用户名密码为空, 可以忽略此选项。　　</li><li><strong>如果登录本机的MySQL数据库，只需要输入：mysql -u root -p</strong><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql <span class="operator">-</span>h <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="operator">-</span>u 用户名 <span class="operator">-</span>p</span><br><span class="line">mysql <span class="operator">-</span>D 所选择的数据库名 <span class="operator">-</span>h 主机名 <span class="operator">-</span>u 用户名 <span class="operator">-</span>p</span><br><span class="line">mysql<span class="operator">&gt;</span> exit # 退出 使用 “quit;” 或 “\q;” 一样的效果</span><br><span class="line">mysql<span class="operator">&gt;</span> status;  # 显示当前mysql的version的各种信息</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> version(); # 显示当前mysql的version信息</span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">'port'</span>; # 查看MySQL端口号</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>对于表的操作需要先进入数据库  <u><strong>use 库名 ；</strong></u></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--创建一个 名为samp_db 的数据库，数据库字符编码指定为 gbk</span></span><br><span class="line"><span class="keyword">create</span> database samp_db <span class="type">character</span> <span class="keyword">set</span> gbk;</span><br><span class="line"><span class="keyword">drop</span> database samp_db; <span class="comment">-- 删除库名为samp_db的库</span></span><br><span class="line"><span class="keyword">show</span> databases;            <span class="comment">-- 显示数据库列表</span></span><br><span class="line">use samp_db;                <span class="comment">-- 选择创建的数据库samp_db</span></span><br><span class="line"><span class="keyword">show</span> tables;                  <span class="comment">-- 显示samp_db下面所有的表名字</span></span><br><span class="line"><span class="keyword">describe</span> 表名；               <span class="comment">-- 显示数据表的结构</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名；           <span class="comment">-- 清空表中记录</span></span><br></pre></td></tr></tbody></table></figure><h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><blockquote><p>使用create table 语句可完成对表的创建</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--如果数据库中存在 user_accounts表，就把它从数据库中drop掉</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF EXITS <span class="string">'user_accounts'</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">'user_accounts'</span>(</span><br><span class="line">`id`             <span class="type">int</span>(<span class="number">100</span>) unsigned <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT <span class="keyword">primary</span> key,</span><br><span class="line">  `password`       <span class="type">varchar</span>(<span class="number">32</span>)       <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'用户密码'</span>,</span><br><span class="line">  `reset_password` tinyint(<span class="number">32</span>)       <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">'用户类型：0－不需要重置密码；1-需要重置密码'</span>,</span><br><span class="line">  `mobile`         <span class="type">varchar</span>(<span class="number">20</span>)       <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'手机'</span>,</span><br><span class="line">  `create_at`      <span class="type">timestamp</span>(<span class="number">6</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>),</span><br><span class="line">  `update_at`      <span class="type">timestamp</span>(<span class="number">6</span>)      <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>) <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>(<span class="number">6</span>),</span><br><span class="line">  <span class="comment">-- 创建唯一索引，不允许重复</span></span><br><span class="line">  <span class="keyword">UNIQUE</span> INDEX idx_user_mobile(`mobile`)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8</span><br><span class="line">COMMENT<span class="operator">=</span><span class="string">'用户表信息'</span>;</span><br></pre></td></tr></tbody></table></figure><p>数据类型的属性解释</p><ul><li>NULL：数据列可包含NULL值；</li><li>NOT NULL：数据列不允许包含NULL值；</li><li>DEFAULT：默认值；</li><li>PRIMARY KEY：主键；</li><li>AUTO_INCREMENT：自动递增，适用于整数类型；</li><li>UNSIGNED：是指数值类型只能为正数；</li><li>CHARACTER SET name：指定一个字符集；</li><li>COMMENT：对表或者字段说明；</li></ul><h2 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h2><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><blockquote><p>SELECT 语句用于从表中选取数据。<br>语法：SELECT 列名称 FROM 表名称<br>语法：SELECT * FROM 表名称</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">-- 表station取个别名叫s，表station中不包含 字段id=13或者14 的，并且id不等于4的 查询出来，只显示id</span></span><br><span class="line"><span class="keyword">SELECT</span> s.id <span class="keyword">from</span> station s <span class="keyword">WHERE</span> id <span class="keyword">in</span> (<span class="number">13</span>,<span class="number">14</span>) <span class="keyword">and</span> id <span class="keyword">not</span> <span class="keyword">in</span> (<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从表 Persons 选取 LastName 列的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> LastName <span class="keyword">FROM</span> Persons</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从表 users 选取 id=3 的数据，并只拉一条数据(据说能优化性能)</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">3</span> limit <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 结果会自动去除company列的重复数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> Company <span class="keyword">FROM</span> Orders </span><br><span class="line"><span class="comment">-- 表 Persons 字段 Id_P 等于 Orders 字段 Id_P 的值，</span></span><br><span class="line"><span class="comment">-- 结果集显示 Persons表的 LastName、FirstName字段，Orders表的OrderNo字段</span></span><br><span class="line"><span class="keyword">SELECT</span> p.LastName, p.FirstName, o.OrderNo <span class="keyword">FROM</span> Persons p, Orders o <span class="keyword">WHERE</span> p.Id_P <span class="operator">=</span> o.Id_P </span><br><span class="line"></span><br><span class="line"><span class="comment">-- gbk 和 utf8 中英文混合排序最简单的办法 </span></span><br><span class="line"><span class="comment">-- ci是 case insensitive, 即 “大小写不敏感”</span></span><br><span class="line"><span class="keyword">SELECT</span> tag, <span class="built_in">COUNT</span>(tag) <span class="keyword">from</span> news <span class="keyword">GROUP</span> <span class="keyword">BY</span> tag <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">convert</span>(tag <span class="keyword">using</span> gbk) <span class="keyword">collate</span> gbk_chinese_ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> tag, <span class="built_in">COUNT</span>(tag) <span class="keyword">from</span> news <span class="keyword">GROUP</span> <span class="keyword">BY</span> tag <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">convert</span>(tag <span class="keyword">using</span> utf8) <span class="keyword">collate</span> utf8_unicode_ci;</span><br></pre></td></tr></tbody></table></figure><h3 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h3><blockquote><p>Update 语句用于修改表中的数据。<br>语法：UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- update语句设置字段值为另一个结果取出来的字段</span></span><br><span class="line">update <span class="keyword">user</span> <span class="keyword">set</span> name <span class="operator">=</span> (<span class="keyword">select</span> name <span class="keyword">from</span> user1 <span class="keyword">where</span> user1 .id <span class="operator">=</span> <span class="number">1</span> )</span><br><span class="line"><span class="keyword">where</span> id <span class="operator">=</span> (<span class="keyword">select</span> id <span class="keyword">from</span> user2 <span class="keyword">where</span> user2 .name<span class="operator">=</span><span class="string">'小苏'</span>);</span><br><span class="line"><span class="comment">-- 更新表 orders 中 id=1 的那一行数据更新它的 title 字段</span></span><br><span class="line"> UPDATE `orders` <span class="keyword">set</span> title<span class="operator">=</span><span class="string">'这里是标题'</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><blockquote><p>INSERT INTO 语句用于向表格中插入新的行。<br>语法：INSERT INTO 表名称 VALUES (值1, 值2,….)<br>语法：INSERT INTO 表名称 (列1, 列2,…) VALUES (值1, 值2,….)</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 向表 Persons 插入一条字段 LastName = JSLite 字段 Address = shanghai</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Persons (LastName, Address) <span class="keyword">VALUES</span> (<span class="string">'JSLite'</span>, <span class="string">'shanghai'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向表 meeting 插入 字段 a=1 和字段 b=2</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> meeting <span class="keyword">SET</span> a<span class="operator">=</span><span class="number">1</span>,b<span class="operator">=</span><span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- -- SQL实现将一个表的数据插入到另外一个表的代码</span></span><br><span class="line"><span class="comment">-- 如果只希望导入指定字段，可以用这种方法：</span></span><br><span class="line"><span class="comment">-- INSERT INTO 目标表 (字段1, 字段2, ...) SELECT 字段1, 字段2, ... FROM 来源表;</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders (user_account_id, title) <span class="keyword">SELECT</span> m.user_id, m.title <span class="keyword">FROM</span> meeting m <span class="keyword">where</span> m.id<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 向表 charger 插入一条数据，已存在就对表 charger 更新 `type`,`update_at` 字段；</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> `charger` (`id`,`type`,`create_at`,`update_at`) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">2</span>,<span class="string">'2017-05-18 11:06:17'</span>,<span class="string">'2017-05-18 11:06:17'</span>) <span class="keyword">ON</span> DUPLICATE KEY UPDATE `id`<span class="operator">=</span><span class="keyword">VALUES</span>(`id`), `type`<span class="operator">=</span><span class="keyword">VALUES</span>(`type`), `update_at`<span class="operator">=</span><span class="keyword">VALUES</span>(`update_at`);</span><br></pre></td></tr></tbody></table></figure><h3 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h3><blockquote><p>DELETE 语句用于删除表中的行。<br>语法：DELETE FROM 表名称 WHERE 列名称 = 值</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在不删除table_name表的情况下删除所有的行，清空表。</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="comment">-- 或者</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="comment">-- 删除 Person表字段 LastName = 'JSLite' </span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> Person <span class="keyword">WHERE</span> LastName <span class="operator">=</span> <span class="string">'JSLite'</span> </span><br><span class="line"><span class="comment">-- 删除 表meeting id 为2和3的两条数据</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">from</span> meeting <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>);</span><br></pre></td></tr></tbody></table></figure><h2 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a>WHERE</h2><blockquote><p>WHERE 子句用于规定选择的标准。<br>语法：<code>SELECT 列名称 FROM 表名称 WHERE 列 运算符 值</code>  </p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从表 Persons 中选出 Year 字段大于 1965 的数据</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> <span class="keyword">Year</span><span class="operator">&gt;</span><span class="number">1965</span></span><br></pre></td></tr></tbody></table></figure><h2 id="AND-和-OR"><a href="#AND-和-OR" class="headerlink" title="AND 和 OR"></a>AND 和 OR</h2><blockquote><p>AND - 如果第一个条件和第二个条件都成立；<br>OR - 如果第一个条件和第二个条件中只要有一个成立；  </p></blockquote><h3 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除 meeting 表字段 </span></span><br><span class="line"><span class="comment">-- id=2 并且 user_id=5 的数据  和</span></span><br><span class="line"><span class="comment">-- id=3 并且 user_id=6 的数据 </span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">from</span> meeting <span class="keyword">where</span> id <span class="keyword">in</span> (<span class="number">2</span>,<span class="number">3</span>) <span class="keyword">and</span> user_id <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用 AND 来显示所有姓为 "Carter" 并且名为 "Thomas" 的人：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> FirstName<span class="operator">=</span><span class="string">'Thomas'</span> <span class="keyword">AND</span> LastName<span class="operator">=</span><span class="string">'Carter'</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h3><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 使用 OR 来显示所有姓为 "Carter" 或者名为 "Thomas" 的人：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> firstname<span class="operator">=</span><span class="string">'Thomas'</span> <span class="keyword">OR</span> lastname<span class="operator">=</span><span class="string">'Carter'</span></span><br></pre></td></tr></tbody></table></figure><h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><blockquote><p>语句默认按照升序对记录进行排序。<br><code>ORDER BY</code> - 语句用于根据指定的列对结果集进行排序。<br><code>DESC</code> - 按照降序对记录进行排序。<br><code>ASC</code> - 按照顺序对记录进行排序。  </p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Company在表Orders中为字母，则会以字母顺序显示公司名称</span></span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 后面跟上 DESC 则为降序显示</span></span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- Company以降序显示公司名称，并OrderNumber以顺序显示</span></span><br><span class="line"><span class="keyword">SELECT</span> Company, OrderNumber <span class="keyword">FROM</span> Orders <span class="keyword">ORDER</span> <span class="keyword">BY</span> Company <span class="keyword">DESC</span>, OrderNumber <span class="keyword">ASC</span></span><br></pre></td></tr></tbody></table></figure><h2 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h2><blockquote><p>IN - 操作符允许我们在 WHERE 子句中规定多个值。<br>IN - 操作符用来指定范围，范围中的每一条，都进行匹配。IN取值规律，由逗号分割，全部放置括号中。<br>语法：<code>SELECT "字段名"FROM "表格名"WHERE "字段名" IN ('值一', '值二', ...);</code></p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 从表 Persons 选取 字段 LastName 等于 Adams、Carter</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Persons <span class="keyword">WHERE</span> LastName <span class="keyword">IN</span> (<span class="string">'Adams'</span>,<span class="string">'Carter'</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h2><blockquote><p>NOT - 操作符总是与其他操作符一起使用，用在要过滤的前面。</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id, prod_name <span class="keyword">FROM</span> Products <span class="keyword">WHERE</span> <span class="keyword">NOT</span> vend_id <span class="operator">=</span> <span class="string">'DLL01'</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></tbody></table></figure><h2 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h2><blockquote><p>UNION - 操作符用于合并两个或多个 SELECT 语句的结果集。</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列出所有在中国表（Employees_China）和美国（Employees_USA）的不同的雇员名</span></span><br><span class="line"><span class="keyword">SELECT</span> E_Name <span class="keyword">FROM</span> Employees_China <span class="keyword">UNION</span> <span class="keyword">SELECT</span> E_Name <span class="keyword">FROM</span> Employees_USA</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 列出 meeting 表中的 pic_url，</span></span><br><span class="line"><span class="comment">-- station 表中的 number_station 别名设置成 pic_url 避免字段不一样报错</span></span><br><span class="line"><span class="comment">-- 按更新时间排序</span></span><br><span class="line"><span class="keyword">SELECT</span> id,pic_url <span class="keyword">FROM</span> meeting <span class="keyword">UNION</span> <span class="keyword">ALL</span> <span class="keyword">SELECT</span> id,number_station <span class="keyword">AS</span> pic_url <span class="keyword">FROM</span> station  <span class="keyword">ORDER</span> <span class="keyword">BY</span> update_at;</span><br><span class="line"><span class="comment">-- 通过 UNION 语法同时查询了 products 表 和 comments 表的总记录数，并且按照 count 排序</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="string">'product'</span> <span class="keyword">AS</span> type, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">FROM</span> `products` <span class="keyword">union</span> <span class="keyword">select</span> <span class="string">'comment'</span> <span class="keyword">as</span> type, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> count <span class="keyword">FROM</span> `comments` <span class="keyword">order</span> <span class="keyword">by</span> count;</span><br></pre></td></tr></tbody></table></figure><h2 id="AS"><a href="#AS" class="headerlink" title="AS"></a>AS</h2><blockquote><p>as - 可理解为：用作、当成，作为；别名<br>一般是重命名列名或者表名。<br>语法：<code>select column_1 as 列1,column_2 as 列2 from table as 表</code></p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> Employee <span class="keyword">AS</span> emp</span><br><span class="line"><span class="comment">-- 这句意思是查找所有Employee 表里面的数据，并把Employee表格命名为 emp。</span></span><br><span class="line"><span class="comment">-- 当你命名一个表之后，你可以在下面用 emp 代替 Employee.</span></span><br><span class="line"><span class="comment">-- 例如 SELECT * FROM emp.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(OrderPrice) <span class="keyword">AS</span> LargestOrderPrice <span class="keyword">FROM</span> Orders</span><br><span class="line"><span class="comment">-- 列出表 Orders 字段 OrderPrice 列最大值，</span></span><br><span class="line"><span class="comment">-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 显示表 users_profile 中的 name 列</span></span><br><span class="line"><span class="keyword">SELECT</span> t.name <span class="keyword">from</span> (<span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">from</span> users_profile a) <span class="keyword">AS</span> t;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 表 user_accounts 命名别名 ua，表 users_profile 命名别名 up</span></span><br><span class="line"><span class="comment">-- 满足条件 表 user_accounts 字段 id 等于 表 users_profile 字段 user_id</span></span><br><span class="line"><span class="comment">-- 结果集只显示mobile、name两列</span></span><br><span class="line"><span class="keyword">SELECT</span> ua.mobile,up.name <span class="keyword">FROM</span> user_accounts <span class="keyword">as</span> ua <span class="keyword">INNER</span> <span class="keyword">JOIN</span> users_profile <span class="keyword">as</span> up <span class="keyword">ON</span> ua.id <span class="operator">=</span> up.user_id;</span><br></pre></td></tr></tbody></table></figure><h2 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h2><blockquote><p>用于根据两个或多个表中的列之间的关系，从这些表中查询数据。  </p></blockquote><ul><li><code>JOIN</code>: 如果表中有至少一个匹配，则返回行</li><li><code>INNER JOIN</code>:在表中存在至少一个匹配时，INNER JOIN 关键字返回行。</li><li><code>LEFT JOIN</code>: 即使右表中没有匹配，也从左表返回所有的行</li><li><code>RIGHT JOIN</code>: 即使左表中没有匹配，也从右表返回所有的行</li><li><code>FULL JOIN</code>: 只要其中一个表中存在匹配，就返回行(MySQL 是不支持的，通过  <code>LEFT JOIN + UNION + RIGHT JOIN</code> 的方式 来实现)</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Persons.LastName, Persons.FirstName, Orders.OrderNo</span><br><span class="line"><span class="keyword">FROM</span> Persons</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Persons.Id_P <span class="operator">=</span> Orders.Id_P</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Persons.LastName;</span><br></pre></td></tr></tbody></table></figure><h2 id="SQL-函数"><a href="#SQL-函数" class="headerlink" title="SQL 函数"></a>SQL 函数</h2><h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT"></a>COUNT</h3><blockquote><p>COUNT 让我们能够数出在表格中有多少笔资料被选出来。<br>语法：<code>SELECT COUNT("字段名") FROM "表格名";</code></p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 表 Store_Information 有几笔 store_name 栏不是空白的资料。</span></span><br><span class="line"><span class="comment">-- "IS NOT NULL" 是 "这个栏位不是空白" 的意思。</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span> (Store_Name) <span class="keyword">FROM</span> Store_Information <span class="keyword">WHERE</span> Store_Name <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span>; </span><br><span class="line"><span class="comment">-- 获取 Persons 表的总数</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">AS</span> totals <span class="keyword">FROM</span> Persons;</span><br><span class="line"><span class="comment">-- 获取表 station 字段 user_id 相同的总数</span></span><br><span class="line"><span class="keyword">select</span> user_id, <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">as</span> totals <span class="keyword">from</span> station <span class="keyword">group</span> <span class="keyword">by</span> user_id;</span><br></pre></td></tr></tbody></table></figure><h3 id="MAX"><a href="#MAX" class="headerlink" title="MAX"></a>MAX</h3><blockquote><p>MAX 函数返回一列中的最大值。NULL 值不包括在计算中。<br>语法：<code>SELECT MAX("字段名") FROM "表格名"</code>  </p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 列出表 Orders 字段 OrderPrice 列最大值，</span></span><br><span class="line"><span class="comment">-- 结果集列不显示 OrderPrice 显示 LargestOrderPrice</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(OrderPrice) <span class="keyword">AS</span> LargestOrderPrice <span class="keyword">FROM</span> Orders</span><br></pre></td></tr></tbody></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><blockquote><p>语法：<br>create trigger &lt;触发器名称&gt;<br>{ before | after}             # 之前或者之后出发<br>insert | update | delete      # 指明了激活触发程序的语句的类型<br>on &lt;表名&gt;                     # 操作哪张表<br>for each row                  # 触发器的执行间隔，for each row 通知触发器每隔一行执行一次动作，而不是对整个表执行一次。<br>&lt;触发器SQL语句&gt;</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">delimiter $</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> set_userdate BEFORE <span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">on</span> `message`</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">EACH</span> <span class="type">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">  <span class="keyword">set</span> <span class="variable">@statu</span> <span class="operator">=</span> new.status; <span class="comment">-- 声明复制变量 statu</span></span><br><span class="line">  if <span class="variable">@statu</span> <span class="operator">=</span> <span class="number">0</span> <span class="keyword">then</span>       <span class="comment">-- 判断 statu 是否等于 0</span></span><br><span class="line">    UPDATE `user_accounts` <span class="keyword">SET</span> status<span class="operator">=</span><span class="number">1</span> <span class="keyword">WHERE</span> openid<span class="operator">=</span>NEW.openid;</span><br><span class="line">  <span class="keyword">end</span> if;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$</span><br><span class="line">DELIMITER ; <span class="comment">-- 恢复结束符号</span></span><br></pre></td></tr></tbody></table></figure><p>OLD和NEW不区分大小写</p><ul><li>NEW 用NEW.col_name，没有旧行。在DELETE触发程序中，仅能使用OLD.col_name，没有新行。</li><li>OLD 用OLD.col_name来引用更新前的某一行的列</li></ul><h2 id="添加索引"><a href="#添加索引" class="headerlink" title="添加索引"></a>添加索引</h2><h3 id="普通索引-INDEX"><a href="#普通索引-INDEX" class="headerlink" title="普通索引(INDEX)"></a>普通索引(INDEX)</h3><blockquote><p>语法：ALTER TABLE <code>表名字</code> ADD INDEX 索引名字 ( <code>字段名字</code> )</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- –直接创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> INDEX index_user <span class="keyword">ON</span> <span class="keyword">user</span>(title)</span><br><span class="line"><span class="comment">-- –修改表结构的方式添加索引</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> INDEX index_name <span class="keyword">ON</span> (<span class="keyword">column</span>(length))</span><br><span class="line"><span class="comment">-- 给 user 表中的 name 字段 添加普通索引(INDEX)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> INDEX index_name (name)</span><br><span class="line"><span class="comment">-- –创建表的时候同时创建索引</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` (</span><br><span class="line">    `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT ,</span><br><span class="line">    `title` <span class="type">char</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    `content` text <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> ,</span><br><span class="line">    `<span class="type">time</span>` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> ,</span><br><span class="line">    <span class="keyword">PRIMARY</span> KEY (`id`),</span><br><span class="line">    INDEX index_name (title(length))</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- –删除索引</span></span><br><span class="line"><span class="keyword">DROP</span> INDEX index_name <span class="keyword">ON</span> <span class="keyword">table</span></span><br></pre></td></tr></tbody></table></figure><h3 id="主键索引-PRIMARY-key"><a href="#主键索引-PRIMARY-key" class="headerlink" title="主键索引(PRIMARY key)"></a>主键索引(PRIMARY key)</h3><blockquote><p>语法：ALTER TABLE <code>表名字</code> ADD PRIMARY KEY ( <code>字段名字</code> )</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给 user 表中的 id字段 添加主键索引(PRIMARY key)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">PRIMARY</span> key (id);</span><br></pre></td></tr></tbody></table></figure><h3 id="唯一索引-UNIQUE"><a href="#唯一索引-UNIQUE" class="headerlink" title="唯一索引(UNIQUE)"></a>唯一索引(UNIQUE)</h3><blockquote><p>语法：ALTER TABLE <code>表名字</code> ADD UNIQUE (<code>字段名字</code>)</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给 user 表中的 creattime 字段添加唯一索引(UNIQUE)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> <span class="keyword">UNIQUE</span> (creattime);</span><br></pre></td></tr></tbody></table></figure><h3 id="全文索引-FULLTEXT"><a href="#全文索引-FULLTEXT" class="headerlink" title="全文索引(FULLTEXT)"></a>全文索引(FULLTEXT)</h3><blockquote><p>语法：ALTER TABLE <code>表名字</code> ADD FULLTEXT (<code>字段名字</code>)</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给 user 表中的 description 字段添加全文索引(FULLTEXT)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> `<span class="keyword">user</span>` <span class="keyword">ADD</span> FULLTEXT (description);</span><br></pre></td></tr></tbody></table></figure><h3 id="添加多列索引"><a href="#添加多列索引" class="headerlink" title="添加多列索引"></a>添加多列索引</h3><blockquote><p>语法：<br>ALTER TABLE <code>table_name</code> ADD INDEX index_name ( <code>column1</code>, <code>column2</code>, <code>column3</code>)</p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 给 user 表中的 name、city、age 字段添加名字为name_city_age的普通索引(INDEX)</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> <span class="keyword">ADD</span> INDEX name_city_age (name(<span class="number">10</span>),city,age); </span><br></pre></td></tr></tbody></table></figure><h3 id="建立索引的时机"><a href="#建立索引的时机" class="headerlink" title="建立索引的时机"></a>建立索引的时机</h3><p>在<code>WHERE</code>和<code>JOIN</code>中出现的列需要建立索引，但也不完全如此：</p><ul><li>MySQL只对<code>&lt;</code>，<code>&lt;=</code>，<code>=</code>，<code>&gt;</code>，<code>&gt;=</code>，<code>BETWEEN</code>，<code>IN</code>使用索引</li><li>某些时候的<code>LIKE</code>也会使用索引。</li><li>在<code>LIKE</code>以通配符%和_开头作查询时，MySQL不会使用索引。</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 此时就需要对city和age建立索引，</span></span><br><span class="line"><span class="comment">-- 由于mytable表的userame也出现在了JOIN子句中，也有对它建立索引的必要。</span></span><br><span class="line"><span class="keyword">SELECT</span> t.Name  </span><br><span class="line"><span class="keyword">FROM</span> mytable t <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> mytable m <span class="keyword">ON</span> t.Name<span class="operator">=</span>m.username </span><br><span class="line"><span class="keyword">WHERE</span> m.age<span class="operator">=</span><span class="number">20</span> <span class="keyword">AND</span> m.city<span class="operator">=</span><span class="string">'上海'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> username <span class="keyword">like</span><span class="string">'admin%'</span>; <span class="comment">-- 而下句就不会使用：</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> mytable <span class="keyword">WHERE</span> Name <span class="keyword">like</span><span class="string">'%admin'</span>; <span class="comment">-- 因此，在使用LIKE时应注意以上的区别。</span></span><br></pre></td></tr></tbody></table></figure><p>索引的注意事项</p><ul><li>索引不会包含有NULL值的列</li><li>使用短索引</li><li>不要在列上进行运算 索引会失效</li></ul><h2 id="创建后表的修改"><a href="#创建后表的修改" class="headerlink" title="创建后表的修改"></a>创建后表的修改</h2><h3 id="添加列"><a href="#添加列" class="headerlink" title="添加列"></a>添加列</h3><blockquote><p>语法：<code>alter table 表名 add 列名 列数据类型 [after 插入位置];</code></p></blockquote><p>示例:</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在表students的最后追加列 address: </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> address <span class="type">char</span>(<span class="number">60</span>);</span><br><span class="line"><span class="comment">-- 在名为 age 的列后插入列 birthday: </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> birthday <span class="type">date</span> after age;</span><br><span class="line"><span class="comment">-- 在名为 number_people 的列后插入列 weeks: </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">add</span> <span class="keyword">column</span> `weeks` <span class="type">varchar</span>(<span class="number">5</span>) <span class="keyword">not</span> <span class="keyword">null</span> <span class="keyword">default</span> "" after `number_people`;</span><br></pre></td></tr></tbody></table></figure><h3 id="修改列"><a href="#修改列" class="headerlink" title="修改列"></a>修改列</h3><blockquote><p>语法：<code>alter table 表名 change 列名称 列新名称 新数据类型;</code></p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将表 tel 列改名为 telphone: </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students change tel telphone <span class="type">char</span>(<span class="number">13</span>) <span class="keyword">default</span> "-";</span><br><span class="line"><span class="comment">-- 将 name 列的数据类型改为 char(16): </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students change name name <span class="type">char</span>(<span class="number">16</span>) <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">-- 修改 COMMENT 前面必须得有类型属性</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students change name name <span class="type">char</span>(<span class="number">16</span>) COMMENT <span class="string">'这里是名字'</span>;</span><br><span class="line"><span class="comment">-- 修改列属性的时候 建议使用modify,不需要重建表</span></span><br><span class="line"><span class="comment">-- change用于修改列名字，这个需要重建表</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> meeting modify `weeks` <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span> COMMENT <span class="string">'开放日期 周一到周日：0~6，间隔用英文逗号隔开'</span>;</span><br><span class="line"><span class="comment">-- `user`表的`id`列，修改成字符串类型长度50，不能为空，`FIRST`放在第一列的位置</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> `<span class="keyword">user</span>` modify <span class="keyword">COLUMN</span> `id` <span class="type">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">FIRST</span> ;</span><br></pre></td></tr></tbody></table></figure><h3 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h3><blockquote><p>语法：<code>alter table 表名 drop 列名称;</code></p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表students中的 birthday 列: </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students <span class="keyword">drop</span> birthday;</span><br></pre></td></tr></tbody></table></figure><h3 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h3><blockquote><p>语法：<code>alter table 表名 rename 新表名;</code></p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 重命名 students 表为 workmates: </span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> students rename workmates;</span><br></pre></td></tr></tbody></table></figure><h3 id="清空表数据"><a href="#清空表数据" class="headerlink" title="清空表数据"></a>清空表数据</h3><blockquote><p>方法一：<code>delete from 表名;</code><br>方法二：<code>truncate table "表名";</code></p></blockquote><ul><li><code>DELETE:</code>1. DML语言;2. 可以回退;3. 可以有条件的删除;</li><li><code>TRUNCATE:</code>1. DDL语言;2. 无法回退;3. 默认所有的表内容都删除;4. 删除速度比delete快。</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 清空表为 workmates 里面的数据，不删除表。 </span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> workmates;</span><br><span class="line"><span class="comment">-- 删除workmates表中的所有数据，且无法恢复</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> workmates;</span><br></pre></td></tr></tbody></table></figure><h3 id="删除整张表"><a href="#删除整张表" class="headerlink" title="删除整张表"></a>删除整张表</h3><blockquote><p>语法：<code>drop table 表名;</code></p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除 workmates 表: </span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> workmates;</span><br></pre></td></tr></tbody></table></figure><h3 id="删除整个数据库"><a href="#删除整个数据库" class="headerlink" title="删除整个数据库"></a>删除整个数据库</h3><blockquote><p>语法：<code>drop database 数据库名;</code></p></blockquote><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除 samp_db 数据库: </span></span><br><span class="line"><span class="keyword">drop</span> database samp_db;</span><br></pre></td></tr></tbody></table></figure><h2 id="其它实例"><a href="#其它实例" class="headerlink" title="其它实例"></a>其它实例</h2><h3 id="SQL删除重复记录"><a href="#SQL删除重复记录" class="headerlink" title="SQL删除重复记录"></a>SQL删除重复记录</h3><p><a href="http://www.xiangguo.li/sql_and_nosql/2015/01/01/sql">转载</a></p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> people <span class="keyword">where</span> peopleId <span class="keyword">in</span> (<span class="keyword">select</span> peopleId <span class="keyword">from</span> people <span class="keyword">group</span> <span class="keyword">by</span> peopleId <span class="keyword">having</span> <span class="built_in">count</span>(peopleId) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">-- 删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> people </span><br><span class="line"><span class="keyword">where</span> peopleId <span class="keyword">in</span> (<span class="keyword">select</span> peopleId <span class="keyword">from</span> people <span class="keyword">group</span> <span class="keyword">by</span> peopleId <span class="keyword">having</span> <span class="built_in">count</span>(peopleId) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br><span class="line"><span class="keyword">and</span> rowid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">min</span>(rowid) <span class="keyword">from</span> people <span class="keyword">group</span> <span class="keyword">by</span> peopleId <span class="keyword">having</span> <span class="built_in">count</span>(peopleId )<span class="operator">&gt;</span><span class="number">1</span>)</span><br><span class="line"><span class="comment">-- 查找表中多余的重复记录（多个字段）</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vitae a</span><br><span class="line"><span class="keyword">where</span> (a.peopleId,a.seq) <span class="keyword">in</span> (<span class="keyword">select</span> peopleId,seq <span class="keyword">from</span> vitae <span class="keyword">group</span> <span class="keyword">by</span> peopleId,seq <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>)</span><br><span class="line"><span class="comment">-- 删除表中多余的重复记录（多个字段），只留有rowid最小的记录</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> vitae a</span><br><span class="line"><span class="keyword">where</span> (a.peopleId,a.seq) <span class="keyword">in</span> (<span class="keyword">select</span> peopleId,seq <span class="keyword">from</span> vitae <span class="keyword">group</span> <span class="keyword">by</span> peopleId,seq <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>) <span class="keyword">and</span> rowid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">min</span>(rowid) <span class="keyword">from</span> vitae <span class="keyword">group</span> <span class="keyword">by</span> peopleId,seq <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">1</span>)</span><br><span class="line"><span class="comment">-- 查找表中多余的重复记录（多个字段），不包含rowid最小的记录</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> vitae a</span><br><span class="line"><span class="keyword">where</span> (a.peopleId,a.seq) <span class="keyword">in</span> (<span class="keyword">select</span> peopleId,seq <span class="keyword">from</span> vitae <span class="keyword">group</span> <span class="keyword">by</span> peopleId,seq <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>) <span class="keyword">and</span> rowid <span class="keyword">not</span> <span class="keyword">in</span> (<span class="keyword">select</span> <span class="built_in">min</span>(rowid) <span class="keyword">from</span> vitae <span class="keyword">group</span> <span class="keyword">by</span> peopleId,seq <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>)<span class="operator">&gt;</span><span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><h2 id="参考手册"><a href="#参考手册" class="headerlink" title="参考手册"></a>参考手册</h2><ul><li><a href="http://www.w3school.com.cn/sql/index.asp">http://www.w3school.com.cn/sql/index.asp</a></li><li><a href="http://www.1keydata.com/cn/sql/sql-count.php">http://www.1keydata.com/cn/sql/sql-count.php</a></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC核心技术</title>
      <link href="/2020/10/08/jdbc-he-xin-ji-zhu/"/>
      <url>/2020/10/08/jdbc-he-xin-ji-zhu/</url>
      
        <content type="html"><![CDATA[<hr><blockquote><p>此笔记是观看 <a href="https://www.bilibili.com/video/BV11J411c7sB?from=search&amp;seid=4044749892780872620">此视频</a>  做的笔记，供学习参考用。</p></blockquote><hr><h2 id="第1章：JDBC概述"><a href="#第1章：JDBC概述" class="headerlink" title="第1章：JDBC概述"></a>第1章：JDBC概述</h2><h3 id="1-1-数据的持久化"><a href="#1-1-数据的持久化" class="headerlink" title="1.1 数据的持久化"></a>1.1 数据的持久化</h3><ul><li><p>持久化(persistence)：<strong>把数据保存到可掉电式存储设备中以供之后使用</strong>。大多数情况下，特别是企业级应用，<strong>数据持久化意味着将内存中的数据保存到硬盘</strong>上加以”固化”<strong>，而持久化的实现过程大多通过各种关系数据库来完成</strong>。</p></li><li><p>持久化的主要应用是将内存中的数据存储在关系型数据库中，当然也可以存储在磁盘文件、XML数据文件中。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566741430592.png" alt="1566741430592"> </p></li></ul><h3 id="1-2-Java中的数据存储技术"><a href="#1-2-Java中的数据存储技术" class="headerlink" title="1.2 Java中的数据存储技术"></a>1.2 Java中的数据存储技术</h3><ul><li><p>在Java中，数据库存取技术可分为如下几类：</p><ul><li><p><strong>JDBC</strong>直接访问数据库</p></li><li><p>JDO (Java Data Object )技术</p></li><li><p><strong>第三方O/R工具</strong>，如Hibernate, Mybatis 等</p></li></ul></li><li><p>JDBC是java访问数据库的基石，JDO、Hibernate、MyBatis等只是更好的封装了JDBC。</p></li></ul><h3 id="1-3-JDBC介绍"><a href="#1-3-JDBC介绍" class="headerlink" title="1.3 JDBC介绍"></a>1.3 JDBC介绍</h3><ul><li>JDBC(Java Database Connectivity)是一个<strong>独立于特定数据库管理系统、通用的SQL数据库存取和操作的公共接口</strong>（一组API），定义了用来访问数据库的标准Java类库，（<strong>java.sql,javax.sql</strong>）使用这些类库可以以一种<strong>标准</strong>的方法、方便地访问数据库资源。</li><li>JDBC为访问不同的数据库提供了一种<strong>统一的途径</strong>，为开发者屏蔽了一些细节问题。</li><li>JDBC的目标是使Java程序员使用JDBC可以连接任何<strong>提供了JDBC驱动程序</strong>的数据库系统，这样就使得程序员无需对特定的数据库系统的特点有过多的了解，从而大大简化和加快了开发过程。</li><li>如果没有JDBC，那么Java程序访问数据库时是这样的：</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555575760234.png" alt="1555575760234"></p><hr><ul><li>有了JDBC，Java程序访问数据库时是这样的：</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555575981203.png" alt="1555575981203"></p><hr><ul><li>总结如下：</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566741692804.png" alt="1566741692804"></p><h3 id="1-4-JDBC体系结构"><a href="#1-4-JDBC体系结构" class="headerlink" title="1.4 JDBC体系结构"></a>1.4 JDBC体系结构</h3><ul><li>JDBC接口（API）包括两个层次：<ul><li><strong>面向应用的API</strong>：Java API，抽象接口，供应用程序开发人员使用（连接数据库，执行SQL语句，获得结果）。</li><li><strong>面向数据库的API</strong>：Java Driver API，供开发商开发数据库驱动程序用。</li></ul></li></ul><blockquote><p><strong>JDBC是sun公司提供一套用于数据库操作的接口，java程序员只需要面向这套接口编程即可。</strong></p><p><strong>不同的数据库厂商，需要针对这套接口，提供不同实现。不同的实现的集合，即为不同数据库的驱动。                                                                ————面向接口编程</strong></p></blockquote><h3 id="1-5-JDBC程序编写步骤"><a href="#1-5-JDBC程序编写步骤" class="headerlink" title="1.5 JDBC程序编写步骤"></a>1.5 JDBC程序编写步骤</h3><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1565969323908.png" alt="1565969323908"></p><blockquote><p>补充：ODBC(<strong>Open Database Connectivity</strong>，开放式数据库连接)，是微软在Windows平台下推出的。使用者在程序中只需要调用ODBC API，由 ODBC 驱动程序将调用转换成为对特定的数据库的调用请求。</p></blockquote><h2 id="第2章：获取数据库连接"><a href="#第2章：获取数据库连接" class="headerlink" title="第2章：获取数据库连接"></a>第2章：获取数据库连接</h2><h3 id="2-1-要素一：Driver接口实现类"><a href="#2-1-要素一：Driver接口实现类" class="headerlink" title="2.1 要素一：Driver接口实现类"></a>2.1 要素一：Driver接口实现类</h3><h4 id="2-1-1-Driver接口介绍"><a href="#2-1-1-Driver接口介绍" class="headerlink" title="2.1.1 Driver接口介绍"></a>2.1.1 Driver接口介绍</h4><ul><li><p>java.sql.Driver 接口是所有 JDBC 驱动程序需要实现的接口。这个接口是提供给数据库厂商使用的，不同数据库厂商提供不同的实现。</p></li><li><p>在程序中不需要直接去访问实现了 Driver 接口的类，而是由驱动程序管理器类(java.sql.DriverManager)去调用这些Driver实现。</p><ul><li>Oracle的驱动：<strong>oracle.jdbc.driver.OracleDriver</strong></li><li>mySql的驱动： <strong>com.mysql.jdbc.Driver</strong></li></ul></li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555576157618.png" alt="1555576157618"></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566134718955.png" alt="1555576170074"></p><ul><li><p>将上述jar包拷贝到Java工程的一个目录中，习惯上新建一个lib文件夹。</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566134781682.png" alt="1566134718955"></p></li></ul><p>在驱动jar上右键–&gt;Build Path–&gt;Add to Build Path</p><p> <img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566135290460.png" alt="1566134781682"></p><p>注意：如果是Dynamic Web Project（动态的web项目）话，则是把驱动jar放到WebContent（有的开发工具叫WebRoot）目录中的WEB-INF目录中的lib目录下即可</p><p> <img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566136831283.png" alt="1566135290460"></p><h4 id="2-1-2-加载与注册JDBC驱动"><a href="#2-1-2-加载与注册JDBC驱动" class="headerlink" title="2.1.2 加载与注册JDBC驱动"></a>2.1.2 加载与注册JDBC驱动</h4><ul><li><p>加载驱动：加载 JDBC 驱动需调用 Class 类的静态方法 forName()，向其传递要加载的 JDBC 驱动的类名</p><ul><li><strong>Class.forName(“com.mysql.jdbc.Driver”);</strong></li></ul></li><li><p>注册驱动：DriverManager 类是驱动程序管理器类，负责管理驱动程序</p><ul><li><p><strong>使用DriverManager.registerDriver(com.mysql.jdbc.Driver)来注册驱动</strong></p></li><li><p>通常不用显式调用 DriverManager 类的 registerDriver() 方法来注册驱动程序类的实例，因为 Driver 接口的驱动程序类<strong>都</strong>包含了静态代码块，在这个静态代码块中，会调用 DriverManager.registerDriver() 方法来注册自身的一个实例。下图是MySQL的Driver实现类的源码：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555576170074.png" alt="1566136831283"></p></li></ul></li></ul><h3 id="2-2-要素二：URL"><a href="#2-2-要素二：URL" class="headerlink" title="2.2 要素二：URL"></a>2.2 要素二：URL</h3><ul><li><p>JDBC URL 用于标识一个被注册的驱动程序，驱动程序管理器通过这个 URL 选择正确的驱动程序，从而建立到数据库的连接。</p></li><li><p>JDBC URL的标准由三部分组成，各部分间用冒号分隔。 </p><ul><li><strong>jdbc:子协议:子名称</strong></li><li><strong>协议</strong>：JDBC URL中的协议总是jdbc </li><li><strong>子协议</strong>：子协议用于标识一个数据库驱动程序</li><li><strong>子名称</strong>：一种标识数据库的方法。子名称可以依不同的子协议而变化，用子名称的目的是为了<strong>定位数据库</strong>提供足够的信息。包含<strong>主机名</strong>(对应服务端的ip地址)<strong>，端口号，数据库名</strong></li></ul></li><li><p>举例：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555576477107.png" alt="1555576477107"></p></li><li><p><strong>几种常用数据库的 JDBC URL</strong></p><ul><li><p>MySQL的连接URL编写方式：</p><ul><li>jdbc:mysql://主机名称:mysql服务端口号/数据库名称?参数=值&amp;参数=值</li><li>jdbc:mysql://localhost:3306/atguigu</li><li>jdbc:mysql://localhost:3306/atguigu<strong>?useUnicode=true&amp;characterEncoding=utf8</strong>（如果JDBC程序与服务器端的字符集不一致，会导致乱码，那么可以通过参数指定服务器端的字符集）</li><li>jdbc:mysql://localhost:3306/atguigu?user=root&amp;password=123456</li></ul></li><li><p>Oracle 9i的连接URL编写方式：</p><ul><li>jdbc:oracle:thin:@主机名称:oracle服务端口号:数据库名称</li><li>jdbc:oracle:thin:@localhost:1521:atguigu</li></ul></li><li><p>SQLServer的连接URL编写方式：</p><ul><li><p>jdbc:sqlserver://主机名称:sqlserver服务端口号:DatabaseName=数据库名称</p></li><li><p>jdbc:sqlserver://localhost:1433:DatabaseName=atguigu</p></li></ul></li></ul></li></ul><h3 id="2-3-要素三：用户名和密码"><a href="#2-3-要素三：用户名和密码" class="headerlink" title="2.3 要素三：用户名和密码"></a>2.3 要素三：用户名和密码</h3><ul><li>user,password可以用“属性名=属性值”方式告诉数据库</li><li>可以调用 DriverManager 类的 getConnection() 方法建立到数据库的连接</li></ul><h3 id="2-4-数据库连接方式举例"><a href="#2-4-数据库连接方式举例" class="headerlink" title="2.4 数据库连接方式举例"></a>2.4 数据库连接方式举例</h3><h4 id="2-4-1-连接方式一"><a href="#2-4-1-连接方式一" class="headerlink" title="2.4.1 连接方式一"></a>2.4.1 连接方式一</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection1</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           <span class="comment">//1.提供java.sql.Driver接口实现类的对象</span></span><br><span class="line">           Driver driver = <span class="keyword">null</span>;</span><br><span class="line">           driver = <span class="keyword">new</span> com.mysql.jdbc.Driver();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">"user"</span>, <span class="string">"root"</span>);</span><br><span class="line">           info.setProperty(<span class="string">"password"</span>, <span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       } <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>说明：上述代码中显式出现了第三方数据库的API</p></blockquote><h4 id="2-4-2-连接方式二"><a href="#2-4-2-连接方式二" class="headerlink" title="2.4.2 连接方式二"></a>2.4.2 连接方式二</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection2</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           <span class="comment">//1.实例化Driver</span></span><br><span class="line">           String className = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line">           Class clazz = Class.forName(className);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.提供url，指明具体操作的数据</span></span><br><span class="line">           String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.提供Properties的对象，指明用户名和密码</span></span><br><span class="line">           Properties info = <span class="keyword">new</span> Properties();</span><br><span class="line">           info.setProperty(<span class="string">"user"</span>, <span class="string">"root"</span>);</span><br><span class="line">           info.setProperty(<span class="string">"password"</span>, <span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line">           <span class="comment">//4.调用driver的connect()，获取连接</span></span><br><span class="line">           Connection conn = driver.connect(url, info);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line"></span><br><span class="line">       } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       }</span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>说明：相较于方式一，这里使用反射实例化Driver，不在代码中体现第三方数据库的API。体现了面向接口编程思想。</p></blockquote><h4 id="2-4-3-连接方式三"><a href="#2-4-3-连接方式三" class="headerlink" title="2.4.3 连接方式三"></a>2.4.3 连接方式三</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection3</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">           String user = <span class="string">"root"</span>;</span><br><span class="line">           String password = <span class="string">"abc123"</span>;</span><br><span class="line">           String driverName = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.实例化Driver</span></span><br><span class="line">           Class clazz = Class.forName(driverName);</span><br><span class="line">           Driver driver = (Driver) clazz.newInstance();</span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           DriverManager.registerDriver(driver);</span><br><span class="line">           <span class="comment">//4.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>说明：使用DriverManager实现数据库的连接。体会获取连接必要的4个基本要素。</p></blockquote><h4 id="2-4-4-连接方式四"><a href="#2-4-4-连接方式四" class="headerlink" title="2.4.4 连接方式四"></a>2.4.4 连接方式四</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConnection4</span><span class="params">()</span> </span>{</span><br><span class="line">       <span class="keyword">try</span> {</span><br><span class="line">           <span class="comment">//1.数据库连接的4个基本要素：</span></span><br><span class="line">           String url = <span class="string">"jdbc:mysql://localhost:3306/test"</span>;</span><br><span class="line">           String user = <span class="string">"root"</span>;</span><br><span class="line">           String password = <span class="string">"abc123"</span>;</span><br><span class="line">           String driverName = <span class="string">"com.mysql.jdbc.Driver"</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">//2.加载驱动 （①实例化Driver ②注册驱动）</span></span><br><span class="line">           Class.forName(driverName);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//Driver driver = (Driver) clazz.newInstance();</span></span><br><span class="line">           <span class="comment">//3.注册驱动</span></span><br><span class="line">           <span class="comment">//DriverManager.registerDriver(driver);</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">           可以注释掉上述代码的原因，是因为在mysql的Driver类中声明有：</span></span><br><span class="line"><span class="comment">           static {</span></span><br><span class="line"><span class="comment">               try {</span></span><br><span class="line"><span class="comment">                   DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">               } catch (SQLException var1) {</span></span><br><span class="line"><span class="comment">                   throw new RuntimeException("Can't register driver!");</span></span><br><span class="line"><span class="comment">               }</span></span><br><span class="line"><span class="comment">           }</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">           <span class="comment">//3.获取连接</span></span><br><span class="line">           Connection conn = DriverManager.getConnection(url, user, password);</span><br><span class="line">           System.out.println(conn);</span><br><span class="line">       } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       }</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><blockquote><p>说明：不必显式的注册驱动了。因为在DriverManager的源码中已经存在静态代码块，实现了驱动的注册。</p></blockquote><h4 id="2-4-5-连接方式五-最终版"><a href="#2-4-5-连接方式五-最终版" class="headerlink" title="2.4.5 连接方式五(最终版)"></a>2.4.5 连接方式五(最终版)</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">testConnection5</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">   <span class="comment">//1.加载配置文件</span></span><br><span class="line">       InputStream is = ConnectionTest.class.getClassLoader().getResourceAsStream(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">       Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">       pros.load(is);</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//2.读取配置信息</span></span><br><span class="line">       String user = pros.getProperty(<span class="string">"user"</span>);</span><br><span class="line">       String password = pros.getProperty(<span class="string">"password"</span>);</span><br><span class="line">       String url = pros.getProperty(<span class="string">"url"</span>);</span><br><span class="line">       String driverClass = pros.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//3.加载驱动</span></span><br><span class="line">       Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//4.获取连接</span></span><br><span class="line">       Connection conn = DriverManager.getConnection(url,user,password);</span><br><span class="line">       System.out.println(conn);</span><br><span class="line"></span><br><span class="line">   }</span><br></pre></td></tr></tbody></table></figure><p>其中，配置文件声明在工程的src目录下：【jdbc.properties】</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br></pre></td></tr></tbody></table></figure><blockquote><p>说明：使用配置文件的方式保存配置信息，在代码中加载配置文件</p><p><strong>使用配置文件的好处：</strong></p><p>①实现了代码和数据的分离，如果需要修改配置信息，直接在配置文件中修改，不需要深入代码<br>②如果修改了配置信息，省去重新编译的过程。</p></blockquote><h2 id="第3章：使用PreparedStatement实现CRUD操作"><a href="#第3章：使用PreparedStatement实现CRUD操作" class="headerlink" title="第3章：使用PreparedStatement实现CRUD操作"></a>第3章：使用PreparedStatement实现CRUD操作</h2><h3 id="3-1-操作和访问数据库"><a href="#3-1-操作和访问数据库" class="headerlink" title="3.1 操作和访问数据库"></a>3.1 操作和访问数据库</h3><ul><li><p>数据库连接被用于向数据库服务器发送命令和 SQL 语句，并接受数据库服务器返回的结果。其实一个数据库连接就是一个Socket连接。</p></li><li><p>在 java.sql 包中有 3 个接口分别定义了对数据库的调用的不同方式：</p><ul><li>Statement：用于执行静态 SQL 语句并返回它所生成结果的对象。 </li><li>PrepatedStatement：SQL 语句被预编译并存储在此对象中，可以使用此对象多次高效地执行该语句。</li><li>CallableStatement：用于执行 SQL 存储过程</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566573842140.png" alt="1566573842140"></p></li></ul><h3 id="3-2-使用Statement操作数据表的弊端"><a href="#3-2-使用Statement操作数据表的弊端" class="headerlink" title="3.2 使用Statement操作数据表的弊端"></a>3.2 使用Statement操作数据表的弊端</h3><ul><li><p>通过调用 Connection 对象的 createStatement() 方法创建该对象。该对象用于执行静态的 SQL 语句，并且返回执行结果。</p></li><li><p>Statement 接口中定义了下列方法用于执行 SQL 语句：</p><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> excuteUpdate(String <span class="keyword">sql</span>)：执行更新操作<span class="keyword">INSERT</span>、UPDATE、<span class="keyword">DELETE</span></span><br><span class="line">ResultSet executeQuery(String <span class="keyword">sql</span>)：执行查询操作<span class="keyword">SELECT</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>但是使用Statement操作数据表存在弊端：</p><ul><li><strong>问题一：存在拼串操作，繁琐</strong></li><li><strong>问题二：存在SQL注入问题</strong></li></ul></li><li><p>SQL 注入是利用某些系统没有对用户输入的数据进行充分的检查，而在用户输入数据中注入非法的 SQL 语句段或命令(如：SELECT user, password FROM user_table WHERE user=’a’ OR 1 = ‘ AND password = ‘ OR ‘1’ = ‘1’) ，从而利用系统的 SQL 引擎完成恶意行为的做法。</p></li><li><p>对于 Java 而言，要防范 SQL 注入，只要用 PreparedStatement(从Statement扩展而来) 取代 Statement 就可以了。</p></li><li><p>代码演示：</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatementTest</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement的弊端：需要拼写sql语句，并且存在SQL注入的问题</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLogin</span><span class="params">()</span> </span>{</span><br><span class="line">Scanner scan = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">System.out.print(<span class="string">"用户名："</span>);</span><br><span class="line">String userName = scan.nextLine();</span><br><span class="line">System.out.print(<span class="string">"密   码："</span>);</span><br><span class="line">String password = scan.nextLine();</span><br><span class="line"></span><br><span class="line"><span class="comment">// SELECT user,password FROM user_table WHERE USER = '1' or ' AND PASSWORD = '='1' or '1' = '1';</span></span><br><span class="line">String sql = <span class="string">"SELECT user,password FROM user_table WHERE USER = '"</span> + userName + <span class="string">"' AND PASSWORD = '"</span> + password</span><br><span class="line">+ <span class="string">"'"</span>;</span><br><span class="line">User user = get(sql, User.class);</span><br><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) {</span><br><span class="line">System.out.println(<span class="string">"登陆成功!"</span>);</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">System.out.println(<span class="string">"用户名或密码错误！"</span>);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Statement实现对数据表的查询操作</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(String sql, Class&lt;T&gt; clazz)</span> </span>{</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">Statement st = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">// 1.加载配置文件</span></span><br><span class="line">InputStream is = StatementTest.class.getClassLoader().getResourceAsStream(<span class="string">"jdbc.properties"</span>);</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line">pros.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.读取配置信息</span></span><br><span class="line">String user = pros.getProperty(<span class="string">"user"</span>);</span><br><span class="line">String password = pros.getProperty(<span class="string">"password"</span>);</span><br><span class="line">String url = pros.getProperty(<span class="string">"url"</span>);</span><br><span class="line">String driverClass = pros.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.加载驱动</span></span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.获取连接</span></span><br><span class="line">conn = DriverManager.getConnection(url, user, password);</span><br><span class="line"></span><br><span class="line">st = conn.createStatement();</span><br><span class="line"></span><br><span class="line">rs = st.executeQuery(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的元数据</span></span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取结果集的列数</span></span><br><span class="line"><span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (rs.next()) {</span><br><span class="line"></span><br><span class="line">t = clazz.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) {</span><br><span class="line"><span class="comment">// //1. 获取列的名称</span></span><br><span class="line"><span class="comment">// String columnName = rsmd.getColumnName(i+1);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取列的别名</span></span><br><span class="line">String columnName = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 根据列名获取对应数据表中的数据</span></span><br><span class="line">Object columnVal = rs.getObject(columnName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将数据表中得到的数据，封装进对象</span></span><br><span class="line">Field field = clazz.getDeclaredField(columnName);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line"><span class="keyword">if</span> (rs != <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">rs.close();</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"><span class="keyword">if</span> (st != <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">st.close();</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (conn != <span class="keyword">null</span>) {</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">conn.close();</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>综上：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566569819744.png" alt="1566569819744"></p><h3 id="3-3-PreparedStatement的使用"><a href="#3-3-PreparedStatement的使用" class="headerlink" title="3.3 PreparedStatement的使用"></a>3.3 PreparedStatement的使用</h3><h4 id="3-3-1-PreparedStatement介绍"><a href="#3-3-1-PreparedStatement介绍" class="headerlink" title="3.3.1 PreparedStatement介绍"></a>3.3.1 PreparedStatement介绍</h4><ul><li><p>可以通过调用 Connection 对象的 <strong>preparedStatement(String sql)</strong> 方法获取 PreparedStatement 对象</p></li><li><p><strong>PreparedStatement 接口是 Statement 的子接口，它表示一条预编译过的 SQL 语句</strong></p></li><li><p>PreparedStatement 对象所代表的 SQL 语句中的参数用问号(?)来表示，调用 PreparedStatement 对象的 setXxx() 方法来设置这些参数. setXxx() 方法有两个参数，第一个参数是要设置的 SQL 语句中的参数的索引(从 1 开始)，第二个是设置的 SQL 语句中的参数的值</p></li></ul><h4 id="3-3-2-PreparedStatement-vs-Statement"><a href="#3-3-2-PreparedStatement-vs-Statement" class="headerlink" title="3.3.2 PreparedStatement vs Statement"></a>3.3.2 PreparedStatement vs Statement</h4><ul><li><p>代码的可读性和可维护性。</p></li><li><p><strong>PreparedStatement 能最大可能提高性能：</strong></p><ul><li>DBServer会对<strong>预编译</strong>语句提供性能优化。因为预编译语句有可能被重复调用，所以<u>语句在被DBServer的编译器编译后的执行代码被缓存下来，那么下次调用时只要是相同的预编译语句就不需要编译，只要将参数直接传入编译过的语句执行代码中就会得到执行。</u></li><li>在statement语句中,即使是相同操作但因为数据内容不一样,所以整个语句本身不能匹配,没有缓存语句的意义.事实是没有数据库会对普通语句编译后的执行代码缓存。这样<u>每执行一次都要对传入的语句编译一次。</u></li><li>(语法检查，语义检查，翻译成二进制命令，缓存)</li></ul></li><li><p>PreparedStatement 可以防止 SQL 注入 </p></li></ul><h4 id="3-3-3-Java与SQL对应数据类型转换表"><a href="#3-3-3-Java与SQL对应数据类型转换表" class="headerlink" title="3.3.3 Java与SQL对应数据类型转换表"></a>3.3.3 Java与SQL对应数据类型转换表</h4><table><thead><tr><th>Java类型</th><th>SQL类型</th></tr></thead><tbody><tr><td>boolean</td><td>BIT</td></tr><tr><td>byte</td><td>TINYINT</td></tr><tr><td>short</td><td>SMALLINT</td></tr><tr><td>int</td><td>INTEGER</td></tr><tr><td>long</td><td>BIGINT</td></tr><tr><td>String</td><td>CHAR,VARCHAR,LONGVARCHAR</td></tr><tr><td>byte   array</td><td>BINARY  ,    VAR BINARY</td></tr><tr><td>java.sql.Date</td><td>DATE</td></tr><tr><td>java.sql.Time</td><td>TIME</td></tr><tr><td>java.sql.Timestamp</td><td>TIMESTAMP</td></tr></tbody></table><h4 id="3-3-4-使用PreparedStatement实现增、删、改操作"><a href="#3-3-4-使用PreparedStatement实现增、删、改操作" class="headerlink" title="3.3.4 使用PreparedStatement实现增、删、改操作"></a>3.3.4 使用PreparedStatement实现增、删、改操作</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通用的增、删、改操作（体现一：增、删、改 ； 体现二：针对于不同的表）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String sql,Object ... args)</span></span>{</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//1.获取数据库的连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">//3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; args.length;i++){</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">}<span class="keyword">finally</span>{</span><br><span class="line"><span class="comment">//5.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="3-3-5-使用PreparedStatement实现查询操作"><a href="#3-3-5-使用PreparedStatement实现查询操作" class="headerlink" title="3.3.5 使用PreparedStatement实现查询操作"></a>3.3.5 使用PreparedStatement实现查询操作</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用的针对于不同表的查询:返回一个对象 (version 1.0)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getInstance</span><span class="params">(Class&lt;T&gt; clazz, String sql, Object... args)</span> </span>{</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.预编译sql语句，得到PreparedStatement对象</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.执行executeQuery(),得到结果集：ResultSet</span></span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.得到结果集的元数据：ResultSetMetaData</span></span><br><span class="line">ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.1通过ResultSetMetaData得到columnCount,columnLabel；通过ResultSet得到列值</span></span><br><span class="line"><span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) {</span><br><span class="line">T t = clazz.newInstance();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; columnCount; i++) {<span class="comment">// 遍历每一个列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取列值</span></span><br><span class="line">Object columnVal = rs.getObject(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 获取列的别名:列的别名，使用类的属性名充当</span></span><br><span class="line">String columnLabel = rsmd.getColumnLabel(i + <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 6.2使用反射，给对象的相应属性赋值</span></span><br><span class="line">Field field = clazz.getDeclaredField(columnLabel);</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(t, columnVal);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line"></span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line"><span class="comment">// 7.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><blockquote><p>说明：使用PreparedStatement实现的查询操作可以替换Statement实现的查询操作，解决Statement拼串和SQL注入问题。</p></blockquote><h3 id="3-4-ResultSet与ResultSetMetaData"><a href="#3-4-ResultSet与ResultSetMetaData" class="headerlink" title="3.4 ResultSet与ResultSetMetaData"></a>3.4 ResultSet与ResultSetMetaData</h3><h4 id="3-4-1-ResultSet"><a href="#3-4-1-ResultSet" class="headerlink" title="3.4.1 ResultSet"></a>3.4.1 ResultSet</h4><ul><li><p>查询需要调用PreparedStatement 的 executeQuery() 方法，查询结果是一个ResultSet 对象</p></li><li><p>ResultSet 对象以逻辑表格的形式封装了执行数据库操作的结果集，ResultSet 接口由数据库厂商提供实现</p></li><li><p>ResultSet 返回的实际上就是一张数据表。有一个指针指向数据表的第一条记录的前面。</p></li><li><p>ResultSet 对象维护了一个指向当前数据行的<strong>游标</strong>，初始的时候，游标在第一行之前，可以通过 ResultSet 对象的 next() 方法移动到下一行。调用 next()方法检测下一行是否有效。若有效，该方法返回 true，且指针下移。相当于Iterator对象的 hasNext() 和 next() 方法的结合体。</p></li><li><p>当指针指向一行时, 可以通过调用 getXxx(int index) 或 getXxx(int columnName) 获取每一列的值。</p><ul><li>例如: getInt(1), getString(“name”)</li><li><strong>注意：Java与数据库交互涉及到的相关Java API中的索引都从1开始。</strong></li></ul></li><li><p>ResultSet 接口的常用方法：</p><ul><li><p>boolean next()</p></li><li><p>getString()</p></li><li><p>…</p></li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555580152530.png" alt="1555580152530"></p></li></ul><h4 id="3-4-2-ResultSetMetaData"><a href="#3-4-2-ResultSetMetaData" class="headerlink" title="3.4.2 ResultSetMetaData"></a>3.4.2 ResultSetMetaData</h4><ul><li><p>可用于获取关于 ResultSet 对象中列的类型和属性信息的对象</p></li><li><p>ResultSetMetaData meta = rs.getMetaData();</p><ul><li><p><strong>getColumnName</strong>(int column)：获取指定列的名称</p></li><li><p><strong>getColumnLabel</strong>(int column)：获取指定列的别名</p></li><li><p><strong>getColumnCount</strong>()：返回当前 ResultSet 对象中的列数。 </p></li><li><p>getColumnTypeName(int column)：检索指定列的数据库特定的类型名称。 </p></li><li><p>getColumnDisplaySize(int column)：指示指定列的最大标准宽度，以字符为单位。 </p></li><li><p><strong>isNullable</strong>(int column)：指示指定列中的值是否可以为 null。 </p></li><li><p>isAutoIncrement(int column)：指示是否自动为指定列进行编号，这样这些列仍然是只读的。 </p></li></ul></li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555579494691.png" alt="1555579494691"></p><p><strong>问题1：得到结果集后, 如何知道该结果集中有哪些列 ？ 列名是什么？</strong></p><p>​     需要使用一个描述 ResultSet 的对象， 即 ResultSetMetaData</p><p><strong>问题2：关于ResultSetMetaData</strong></p><ol><li><strong>如何获取 ResultSetMetaData</strong>： 调用 ResultSet 的 getMetaData() 方法即可</li><li><strong>获取 ResultSet 中有多少列</strong>：调用 ResultSetMetaData 的 getColumnCount() 方法</li><li><strong>获取 ResultSet 每一列的列的别名是什么</strong>：调用 ResultSetMetaData 的getColumnLabel() 方法</li></ol><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555579816884.png" alt="1555579816884"></p><h3 id="3-5-资源的释放"><a href="#3-5-资源的释放" class="headerlink" title="3.5 资源的释放"></a>3.5 资源的释放</h3><ul><li>释放ResultSet, Statement,Connection。</li><li>数据库连接（Connection）是非常稀有的资源，用完后必须马上释放，如果Connection不能及时正确的关闭将导致系统宕机。Connection的使用原则是<strong>尽量晚创建，尽量早的释放。</strong></li><li>可以在finally中关闭，保证及时其他代码出现异常，资源也一定能被关闭。</li></ul><h3 id="3-6-JDBC-API小结"><a href="#3-6-JDBC-API小结" class="headerlink" title="3.6 JDBC API小结"></a>3.6 JDBC API小结</h3><ul><li><p>两种思想</p><ul><li><p>面向接口编程的思想</p></li><li><p>ORM思想(object relational mapping)</p><ul><li>一个数据表对应一个java类</li><li>表中的一条记录对应java类的一个对象</li><li>表中的一个字段对应java类的一个属性</li></ul></li></ul><blockquote><p>sql是需要结合列名和表的属性名来写。注意起别名。</p></blockquote></li><li><p>两种技术</p><ul><li>JDBC结果集的元数据：ResultSetMetaData<ul><li>获取列数：getColumnCount()</li><li>获取列的别名：getColumnLabel()</li></ul></li><li>通过反射，创建指定类的对象，获取指定的属性并赋值</li></ul></li></ul><hr><h2 id="章节练习"><a href="#章节练习" class="headerlink" title="章节练习"></a>章节练习</h2><p><strong>练习题1：从控制台向数据库的表customers中插入一条数据，表结构如下：</strong></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555580735377.png" alt="1555580275036"></p><p><strong>练习题2：创立数据库表 examstudent，表结构如下：</strong></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555580763636.png" alt="1555580735377"></p><p>向数据表中添加如下数据：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555580275036.png" alt="1555580763636"></p><p><strong>代码实现1：插入一个新的student 信息</strong></p><p>请输入考生的详细信息</p><p>Type:<br>IDCard:<br>ExamCard:<br>StudentName:<br>Location:<br>Grade:</p><p>信息录入成功!</p><p><strong>代码实现2：在 eclipse中建立 java 程序：输入身份证号或准考证号可以查询到学生的基本信息。结果如下：</strong></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555580965019.png" alt="1555580937490"></p><p><strong>代码实现3：完成学生信息的删除功能</strong></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555580937490.png" alt="1555580965019"></p><hr><h2 id="第4章-操作BLOB类型字段"><a href="#第4章-操作BLOB类型字段" class="headerlink" title="第4章 操作BLOB类型字段"></a>第4章 操作BLOB类型字段</h2><h3 id="4-1-MySQL-BLOB类型"><a href="#4-1-MySQL-BLOB类型" class="headerlink" title="4.1 MySQL BLOB类型"></a>4.1 MySQL BLOB类型</h3><ul><li><p>MySQL中，BLOB是一个二进制大型对象，是一个可以存储大量数据的容器，它能容纳不同大小的数据。</p></li><li><p>插入BLOB类型的数据必须使用PreparedStatement，因为BLOB类型的数据无法使用字符串拼接写的。</p></li><li><p>MySQL的四种BLOB类型(除了在存储的最大信息量上不同外，他们是等同的)</p></li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555581069798.png" alt="1555581069798"></p><ul><li>实际使用中根据需要存入的数据大小定义不同的BLOB类型。</li><li>需要注意的是：如果存储的文件过大，数据库的性能会下降。</li><li>如果在指定了相关的Blob类型以后，还报错：xxx too large，那么在mysql的安装目录下，找my.ini文件加上如下的配置参数： <strong>max_allowed_packet=16M</strong>。同时注意：修改了my.ini文件之后，需要重新启动mysql服务。</li></ul><h3 id="4-2-向数据表中插入大数据类型"><a href="#4-2-向数据表中插入大数据类型" class="headerlink" title="4.2 向数据表中插入大数据类型"></a>4.2 向数据表中插入大数据类型</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取连接</span></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"insert into customers(name,email,birth,photo)values(?,?,?,?)"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">"徐海强"</span>);</span><br><span class="line">ps.setString(<span class="number">2</span>, <span class="string">"xhq@126.com"</span>);</span><br><span class="line">ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(<span class="keyword">new</span> java.util.Date().getTime()));</span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"xhq.png"</span>);</span><br><span class="line">ps.setBlob(<span class="number">4</span>, fis);</span><br><span class="line"><span class="comment">//执行</span></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="4-3-修改数据表中的Blob类型字段"><a href="#4-3-修改数据表中的Blob类型字段" class="headerlink" title="4.3 修改数据表中的Blob类型字段"></a>4.3 修改数据表中的Blob类型字段</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">String sql = <span class="string">"update customers set photo = ? where id = ?"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充占位符</span></span><br><span class="line"><span class="comment">// 操作Blob类型的变量</span></span><br><span class="line">FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"coffee.png"</span>);</span><br><span class="line">ps.setBlob(<span class="number">1</span>, fis);</span><br><span class="line">ps.setInt(<span class="number">2</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">ps.execute();</span><br><span class="line"></span><br><span class="line">fis.close();</span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></tbody></table></figure><h3 id="4-4-从数据表中读取大数据类型"><a href="#4-4-从数据表中读取大数据类型" class="headerlink" title="4.4 从数据表中读取大数据类型"></a>4.4 从数据表中读取大数据类型</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"SELECT id, name, email, birth, photo FROM customer WHERE id = ?"</span>;</span><br><span class="line">conn = getConnection();</span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line">ps.setInt(<span class="number">1</span>, <span class="number">8</span>);</span><br><span class="line">rs = ps.executeQuery();</span><br><span class="line"><span class="keyword">if</span>(rs.next()){</span><br><span class="line">Integer id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    String name = rs.getString(<span class="number">2</span>);</span><br><span class="line">String email = rs.getString(<span class="number">3</span>);</span><br><span class="line">    Date birth = rs.getDate(<span class="number">4</span>);</span><br><span class="line">Customer cust = <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">    System.out.println(cust); </span><br><span class="line">    <span class="comment">//读取Blob类型的字段</span></span><br><span class="line">Blob photo = rs.getBlob(<span class="number">5</span>);</span><br><span class="line">InputStream is = photo.getBinaryStream();</span><br><span class="line">OutputStream os = <span class="keyword">new</span> FileOutputStream(<span class="string">"c.jpg"</span>);</span><br><span class="line"><span class="keyword">byte</span> [] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>){</span><br><span class="line">os.write(buffer, <span class="number">0</span>, len);</span><br><span class="line">}</span><br><span class="line">    JDBCUtils.closeResource(conn, ps, rs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(is != <span class="keyword">null</span>){</span><br><span class="line">is.close();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(os !=  <span class="keyword">null</span>){</span><br><span class="line">os.close();</span><br><span class="line">}</span><br><span class="line">    </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="第5章-批量插入"><a href="#第5章-批量插入" class="headerlink" title="第5章 批量插入"></a>第5章 批量插入</h2><h3 id="5-1-批量执行SQL语句"><a href="#5-1-批量执行SQL语句" class="headerlink" title="5.1 批量执行SQL语句"></a>5.1 批量执行SQL语句</h3><p>当需要成批插入或者更新记录时，可以采用Java的批量<strong>更新</strong>机制，这一机制允许多条语句一次性提交给数据库批量处理。通常情况下比单独提交处理更有效率</p><p>JDBC的批量处理语句包括下面三个方法：</p><ul><li><strong>addBatch(String)：添加需要批量处理的SQL语句或是参数；</strong></li><li><strong>executeBatch()：执行批量处理语句；</strong></li><li><strong>clearBatch():清空缓存的数据</strong></li></ul><p>通常我们会遇到两种批量执行SQL语句的情况：</p><ul><li>多条SQL语句的批量处理；</li><li>一个SQL语句的批量传参；</li></ul><h3 id="5-2-高效的批量插入"><a href="#5-2-高效的批量插入" class="headerlink" title="5.2 高效的批量插入"></a>5.2 高效的批量插入</h3><p>举例：向数据表中插入20000条数据</p><ul><li>数据库中提供一个goods表。创建如下：</li></ul><figure class="highlight sql"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> goods(</span><br><span class="line">id <span class="type">INT</span> <span class="keyword">PRIMARY</span> KEY AUTO_INCREMENT,</span><br><span class="line">NAME <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><h4 id="5-2-1-实现层次一：使用Statement"><a href="#5-2-1-实现层次一：使用Statement" class="headerlink" title="5.2.1 实现层次一：使用Statement"></a>5.2.1 实现层次一：使用Statement</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line">Statement st = conn.createStatement();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++){</span><br><span class="line">String sql = <span class="string">"insert into goods(name) values('name_' + "</span>+ i +<span class="string">")"</span>;</span><br><span class="line">st.executeUpdate(sql);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5-2-2-实现层次二：使用PreparedStatement"><a href="#5-2-2-实现层次二：使用PreparedStatement" class="headerlink" title="5.2.2 实现层次二：使用PreparedStatement"></a>5.2.2 实现层次二：使用PreparedStatement</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"insert into goods(name)values(?)"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">20000</span>;i++){</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">"name_"</span> + i);</span><br><span class="line">ps.executeUpdate();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"花费的时间为："</span> + (end - start));<span class="comment">//82340</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br></pre></td></tr></tbody></table></figure><h4 id="5-2-3-实现层次三"><a href="#5-2-3-实现层次三" class="headerlink" title="5.2.3 实现层次三"></a>5.2.3 实现层次三</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 修改1： 使用 addBatch() / executeBatch() / clearBatch()</span></span><br><span class="line"><span class="comment"> * 修改2：mysql服务器默认是关闭批处理的，我们需要通过一个参数，让mysql开启批处理的支持。</span></span><br><span class="line"><span class="comment"> *  ?rewriteBatchedStatements=true 写在配置文件的url后面</span></span><br><span class="line"><span class="comment"> * 修改3：使用更新的mysql 驱动：mysql-connector-java-5.1.37-bin.jar</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"insert into goods(name)values(?)"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++){</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">"name_"</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.“攒”sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>){</span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"花费的时间为："</span> + (end - start));<span class="comment">//20000条：625                                                                         //1000000条:14733  </span></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="5-2-4-实现层次四"><a href="#5-2-4-实现层次四" class="headerlink" title="5.2.4 实现层次四"></a>5.2.4 实现层次四</h4><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 层次四：在层次三的基础上操作</span></span><br><span class="line"><span class="comment">* 使用Connection 的 setAutoCommit(false)  /  commit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert2</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.设置为不自动提交数据</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"insert into goods(name)values(?)"</span>;</span><br><span class="line">PreparedStatement ps = conn.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= <span class="number">1000000</span>;i++){</span><br><span class="line">ps.setString(<span class="number">1</span>, <span class="string">"name_"</span> + i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.“攒”sql</span></span><br><span class="line">ps.addBatch();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % <span class="number">500</span> == <span class="number">0</span>){</span><br><span class="line"><span class="comment">//2.执行</span></span><br><span class="line">ps.executeBatch();</span><br><span class="line"><span class="comment">//3.清空</span></span><br><span class="line">ps.clearBatch();</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.提交数据</span></span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"花费的时间为："</span> + (end - start));<span class="comment">//1000000条:4978 </span></span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, ps);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="第6章：-数据库事务"><a href="#第6章：-数据库事务" class="headerlink" title="第6章： 数据库事务"></a>第6章： 数据库事务</h2><h3 id="6-1-数据库事务介绍"><a href="#6-1-数据库事务介绍" class="headerlink" title="6.1 数据库事务介绍"></a>6.1 数据库事务介绍</h3><ul><li><p><strong>事务：一组逻辑操作单元,使数据从一种状态变换到另一种状态。</strong></p></li><li><p><strong>事务处理（事务操作）：</strong>保证所有事务都作为一个工作单元来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都<strong>被提交(commit)</strong>，那么这些修改就永久地保存下来；要么数据库管理系统将放弃所作的所有修改，整个事务<strong>回滚(rollback)</strong>到最初状态。</p></li><li><p>为确保数据库中数据的<strong>一致性</strong>，数据的操纵应当是离散的成组的逻辑单元：当它全部完成时，数据的一致性可以保持，而当这个单元中的一部分操作失败，整个事务应全部视为错误，所有从起始点以后的操作应全部回退到开始状态。 </p></li></ul><h3 id="6-2-JDBC事务处理"><a href="#6-2-JDBC事务处理" class="headerlink" title="6.2 JDBC事务处理"></a>6.2 JDBC事务处理</h3><ul><li><p>数据一旦提交，就不可回滚。</p></li><li><p>数据什么时候意味着提交？</p><ul><li><strong>当一个连接对象被创建时，默认情况下是自动提交事务</strong>：每次执行一个 SQL 语句时，如果执行成功，就会向数据库自动提交，而不能回滚。</li><li><strong>关闭数据库连接，数据就会自动的提交。</strong>如果多个操作，每个操作使用的是自己单独的连接，则无法保证事务。即同一个事务的多个操作必须在同一个连接下。</li></ul></li><li><p><strong>JDBC程序中为了让多个 SQL 语句作为一个事务执行：</strong></p><ul><li>调用 Connection 对象的 <strong>setAutoCommit(false);</strong> 以取消自动提交事务</li><li>在所有的 SQL 语句都成功执行后，调用 <strong>commit();</strong> 方法提交事务</li><li>在出现异常时，调用 <strong>rollback();</strong> 方法回滚事务</li></ul><blockquote><p>若此时 Connection 没有被关闭，还可能被重复使用，则需要恢复其自动提交状态 setAutoCommit(true)。尤其是在使用数据库连接池技术时，执行close()方法前，建议恢复自动提交状态。</p></blockquote></li></ul><p>【案例：用户AA向用户BB转账100】</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJDBCTransaction</span><span class="params">()</span> </span>{</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">// 1.获取数据库连接</span></span><br><span class="line">conn = JDBCUtils.getConnection();</span><br><span class="line"><span class="comment">// 2.开启事务</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// 3.进行数据库操作</span></span><br><span class="line">String sql1 = <span class="string">"update user_table set balance = balance - 100 where user = ?"</span>;</span><br><span class="line">update(conn, sql1, <span class="string">"AA"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟网络异常</span></span><br><span class="line"><span class="comment">//System.out.println(10 / 0);</span></span><br><span class="line"></span><br><span class="line">String sql2 = <span class="string">"update user_table set balance = balance + 100 where user = ?"</span>;</span><br><span class="line">update(conn, sql2, <span class="string">"BB"</span>);</span><br><span class="line"><span class="comment">// 4.若没有异常，则提交事务</span></span><br><span class="line">conn.commit();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">// 5.若有异常，则回滚事务</span></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">conn.rollback();</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e1) {</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">}</span><br><span class="line">    } <span class="keyword">finally</span> {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//6.恢复每次DML操作的自动提交功能</span></span><br><span class="line">conn.setAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line">        <span class="comment">//7.关闭连接</span></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>, <span class="keyword">null</span>); </span><br><span class="line">    }  </span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>其中，对数据库操作的方法为：</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用事务以后的通用的增删改操作（version 2.0）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Connection conn ,String sql, Object... args)</span> </span>{</span><br><span class="line">PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">// 1.获取PreparedStatement的实例 (或：预编译sql语句)</span></span><br><span class="line">ps = conn.prepareStatement(sql);</span><br><span class="line"><span class="comment">// 2.填充占位符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) {</span><br><span class="line">ps.setObject(i + <span class="number">1</span>, args[i]);</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 3.执行sql语句</span></span><br><span class="line">ps.execute();</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} <span class="keyword">finally</span> {</span><br><span class="line"><span class="comment">// 4.关闭资源</span></span><br><span class="line">JDBCUtils.closeResource(<span class="keyword">null</span>, ps);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="6-3-事务的ACID属性"><a href="#6-3-事务的ACID属性" class="headerlink" title="6.3 事务的ACID属性"></a>6.3 事务的ACID属性</h3><ol><li><p><strong>原子性（Atomicity）</strong><br>原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 </p></li><li><p><strong>一致性（Consistency）</strong><br>事务必须使数据库从一个一致性状态变换到另外一个一致性状态。</p></li><li><p><strong>隔离性（Isolation）</strong><br>事务的隔离性是指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p><strong>持久性（Durability）</strong><br>持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。</p></li></ol><h4 id="6-3-1-数据库的并发问题"><a href="#6-3-1-数据库的并发问题" class="headerlink" title="6.3.1 数据库的并发问题"></a>6.3.1 数据库的并发问题</h4><ul><li><p>对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题:</p><ul><li><strong>脏读</strong>: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还<strong>没有被提交</strong>的字段。之后, 若 T2 回滚, T1读取的内容就是临时且无效的。</li><li><strong>不可重复读</strong>: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 <strong>更新</strong>了该字段。之后, T1再次读取同一个字段, 值就不同了。</li><li><strong>幻读</strong>: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中<strong>插入</strong>了一些新的行。之后, 如果 T1 再次读取同一个表, 就会多出几行。</li></ul></li><li><p><strong>数据库事务的隔离性</strong>: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题。</p></li><li><p>一个事务与其他事务隔离的程度称为隔离级别。数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, <strong>隔离级别越高, 数据一致性就越好, 但并发性越弱。</strong></p></li></ul><h4 id="6-3-2-四种隔离级别"><a href="#6-3-2-四种隔离级别" class="headerlink" title="6.3.2 四种隔离级别"></a>6.3.2 四种隔离级别</h4><ul><li><p>数据库提供的4种事务隔离级别：</p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555586275271.png" alt="1555586275271"></p></li><li><p>Oracle 支持的 2 种事务隔离级别：<strong>READ COMMITED</strong>, SERIALIZABLE。 Oracle 默认的事务隔离级别为: <strong>READ COMMITED</strong> 。</p></li></ul><ul><li>Mysql 支持 4 种事务隔离级别。Mysql 默认的事务隔离级别为: <strong>REPEATABLE READ。</strong></li></ul><h4 id="6-3-3-在MySql中设置隔离级别"><a href="#6-3-3-在MySql中设置隔离级别" class="headerlink" title="6.3.3 在MySql中设置隔离级别"></a>6.3.3 在MySql中设置隔离级别</h4><ul><li><p>每启动一个 mysql 程序, 就会获得一个单独的数据库连接. 每个数据库连接都有一个全局变量 @@tx_isolation, 表示当前的事务隔离级别。</p></li><li><p>查看当前的隔离级别: </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT @@tx_isolation;</span><br></pre></td></tr></tbody></table></figure></li><li><p>设置当前 mySQL 连接的隔离级别:  </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set  transaction isolation level read committed;</span><br></pre></td></tr></tbody></table></figure></li><li><p>设置数据库系统的全局的隔离级别:</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global transaction isolation level read committed;</span><br></pre></td></tr></tbody></table></figure></li><li><p>补充操作：</p><ul><li><p>创建mysql数据库用户：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create user tom identified by 'abc123';</span><br></pre></td></tr></tbody></table></figure></li><li><p>授予权限</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#授予通过网络方式登录的tom用户，对所有库所有表的全部权限，密码设为abc123.</span><br><span class="line">grant all privileges on *.* to tom@'%'  identified by 'abc123'; </span><br><span class="line"></span><br><span class="line"> #给tom用户使用本地命令行方式，授予atguigudb这个库下的所有表的插删改查的权限。</span><br><span class="line">grant select,insert,delete,update on atguigudb.* to tom@localhost identified by 'abc123'; </span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></li></ul></li></ul><h2 id="第7章：DAO及相关实现类"><a href="#第7章：DAO及相关实现类" class="headerlink" title="第7章：DAO及相关实现类"></a>第7章：DAO及相关实现类</h2><ul><li>DAO：Data Access Object访问数据信息的类和接口，包括了对数据的CRUD（Create、Retrival、Update、Delete），而不包含任何业务相关的信息。有时也称作：BaseDAO</li><li>作用：为了实现功能的模块化，更有利于代码的维护和升级。</li><li>下面是尚硅谷JavaWeb阶段书城项目中DAO使用的体现：</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566726681515.png" alt="1566726681515"></p><ul><li>层次结构：</li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555593598606.png" alt="1566745811244"></p><h3 id="【BaseDAO-java】"><a href="#【BaseDAO-java】" class="headerlink" title="【BaseDAO.java】"></a>【BaseDAO.java】</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.ParameterizedType;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Type;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.BeanListHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.handlers.ScalarHandler;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义一个用来被继承的对数据库进行基本操作的Dao</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> HanYanBing</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseDao</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"><span class="keyword">private</span> QueryRunner queryRunner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"><span class="comment">// 定义一个变量来接收泛型的类型</span></span><br><span class="line"><span class="keyword">private</span> Class&lt;T&gt; type;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取T的Class对象，获取泛型的类型，泛型是在被子类继承时才确定</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BaseDao</span><span class="params">()</span> </span>{</span><br><span class="line"><span class="comment">// 获取子类的类型</span></span><br><span class="line">Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line"><span class="comment">// 获取父类的类型</span></span><br><span class="line"><span class="comment">// getGenericSuperclass()用来获取当前类的父类的类型</span></span><br><span class="line"><span class="comment">// ParameterizedType表示的是带泛型的类型</span></span><br><span class="line">ParameterizedType parameterizedType = (ParameterizedType) clazz.getGenericSuperclass();</span><br><span class="line"><span class="comment">// 获取具体的泛型类型 getActualTypeArguments获取具体的泛型的类型</span></span><br><span class="line"><span class="comment">// 这个方法会返回一个Type的数组</span></span><br><span class="line">Type[] types = parameterizedType.getActualTypeArguments();</span><br><span class="line"><span class="comment">// 获取具体的泛型的类型·</span></span><br><span class="line"><span class="keyword">this</span>.type = (Class&lt;T&gt;) types[<span class="number">0</span>];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通用的增删改操作</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">update</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>{</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">count = queryRunner.update(conn, sql, params);</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">getBean</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>{</span><br><span class="line">T t = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">t = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanHandler&lt;T&gt;(type), params);</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> t;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取所有对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getBeanList</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>{</span><br><span class="line">List&lt;T&gt; list = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">list = queryRunner.query(conn, sql, <span class="keyword">new</span> BeanListHandler&lt;T&gt;(type), params);</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> list;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取一个但一值得方法，专门用来执行像 select count(*)...这样的sql语句</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sql</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(Connection conn,String sql, Object... params)</span> </span>{</span><br><span class="line">Object count = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">// 调用queryRunner的query方法获取一个单一的值</span></span><br><span class="line">count = queryRunner.query(conn, sql, <span class="keyword">new</span> ScalarHandler&lt;&gt;(), params);</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">} </span><br><span class="line"><span class="keyword">return</span> count;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="【BookDAO-java】"><a href="#【BookDAO-java】" class="headerlink" title="【BookDAO.java】"></a>【BookDAO.java】</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookDao</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中查询出所有的记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 从数据库中根据图书的id删除一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中查询出一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> bookId</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据图书的id从数据库中更新一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> book</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取带分页和价格范围的图书信息</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> page：是只包含了用户输入的pageNo属性的page对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回的Page对象是包含了所有属性的Page对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span></span>;</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="【UserDAO-java】"><a href="#【UserDAO-java】" class="headerlink" title="【UserDAO.java】"></a>【UserDAO.java】</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名和密码从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> User 数据库中有记录 null 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据User对象中的用户名从数据库中获取一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true 数据库中有记录 false 数据库中无此记录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 向数据库中插入User对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="【BookDaoImpl-java】"><a href="#【BookDaoImpl-java】" class="headerlink" title="【BookDaoImpl.java】"></a>【BookDaoImpl.java】</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Book;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.Page;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BookDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">Book</span>&gt; <span class="keyword">implements</span> <span class="title">BookDao</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Book&gt; <span class="title">getBooks</span><span class="params">(Connection conn)</span> </span>{</span><br><span class="line"><span class="comment">// 调用BaseDao中得到一个List的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books"</span>;</span><br><span class="line">beanList = getBeanList(conn,sql);</span><br><span class="line"><span class="keyword">return</span> beanList;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveBook</span><span class="params">(Connection conn,Book book)</span> </span>{</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">"insert into books(title,author,price,sales,stock,img_path) values(?,?,?,?,?,?)"</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(),book.getImgPath());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteBookById</span><span class="params">(Connection conn,String bookId)</span> </span>{</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">"DELETE FROM books WHERE id = ?"</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用增删改的方法</span></span><br><span class="line">update(conn,sql, bookId);</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Book <span class="title">getBookById</span><span class="params">(Connection conn,String bookId)</span> </span>{</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">Book book = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books where id = ?"</span>;</span><br><span class="line">book = getBean(conn,sql, bookId);</span><br><span class="line"><span class="keyword">return</span> book;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBook</span><span class="params">(Connection conn,Book book)</span> </span>{</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">"update books set title = ? , author = ? , price = ? , sales = ? , stock = ? where id = ?"</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, book.getTitle(), book.getAuthor(), book.getPrice(), book.getSales(), book.getStock(), book.getId());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooks</span><span class="params">(Connection conn,Page&lt;Book&gt; page)</span> </span>{</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">String sql = <span class="string">"select count(*) from books"</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">String sql2 = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books limit ?,?"</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Page&lt;Book&gt; <span class="title">getPageBooksByPrice</span><span class="params">(Connection conn,Page&lt;Book&gt; page, <span class="keyword">double</span> minPrice, <span class="keyword">double</span> maxPrice)</span> </span>{</span><br><span class="line"><span class="comment">// 获取数据库中图书的总记录数</span></span><br><span class="line">String sql = <span class="string">"select count(*) from books where price between ? and ?"</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个单一值的方法</span></span><br><span class="line"><span class="keyword">long</span> totalRecord = (<span class="keyword">long</span>) getValue(conn,sql,minPrice,maxPrice);</span><br><span class="line"><span class="comment">// 将总记录数设置都page对象中</span></span><br><span class="line">page.setTotalRecord((<span class="keyword">int</span>) totalRecord);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前页中的记录存放的List</span></span><br><span class="line">String sql2 = <span class="string">"select id,title,author,price,sales,stock,img_path imgPath from books where price between ? and ? limit ?,?"</span>;</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个集合的方法</span></span><br><span class="line">List&lt;Book&gt; beanList = getBeanList(conn,sql2, minPrice , maxPrice , (page.getPageNo() - <span class="number">1</span>) * Page.PAGE_SIZE, Page.PAGE_SIZE);</span><br><span class="line"><span class="comment">// 将这个List设置到page对象中</span></span><br><span class="line">page.setList(beanList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> page;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="【UserDaoImpl-java】"><a href="#【UserDaoImpl-java】" class="headerlink" title="【UserDaoImpl.java】"></a>【UserDaoImpl.java】</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.beans.User;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.BaseDao;</span><br><span class="line"><span class="keyword">import</span> com.atguigu.bookstore.dao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">extends</span> <span class="title">BaseDao</span>&lt;<span class="title">User</span>&gt; <span class="keyword">implements</span> <span class="title">UserDao</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(Connection conn,User user)</span> </span>{</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">User bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">"select id,username,password,email from users where username = ? and password = ?"</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername(), user.getPassword());</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUsername</span><span class="params">(Connection conn,User user)</span> </span>{</span><br><span class="line"><span class="comment">// 调用BaseDao中获取一个对象的方法</span></span><br><span class="line">User bean = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 写sql语句</span></span><br><span class="line">String sql = <span class="string">"select id,username,password,email from users where username = ?"</span>;</span><br><span class="line">bean = getBean(conn,sql, user.getUsername());</span><br><span class="line"><span class="keyword">return</span> bean != <span class="keyword">null</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">(Connection conn,User user)</span> </span>{</span><br><span class="line"><span class="comment">//写sql语句</span></span><br><span class="line">String sql = <span class="string">"insert into users(username,password,email) values(?,?,?)"</span>;</span><br><span class="line"><span class="comment">//调用BaseDao中通用的增删改的方法</span></span><br><span class="line">update(conn,sql, user.getUsername(),user.getPassword(),user.getEmail());</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="【Book-java】"><a href="#【Book-java】" class="headerlink" title="【Book.java】"></a>【Book.java】</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 图书类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String title; <span class="comment">// 书名</span></span><br><span class="line"><span class="keyword">private</span> String author; <span class="comment">// 作者</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">double</span> price; <span class="comment">// 价格</span></span><br><span class="line"><span class="keyword">private</span> Integer sales; <span class="comment">// 销量</span></span><br><span class="line"><span class="keyword">private</span> Integer stock; <span class="comment">// 库存</span></span><br><span class="line"><span class="keyword">private</span> String imgPath = <span class="string">"static/img/default.jpg"</span>; <span class="comment">// 封面图片的路径</span></span><br><span class="line"><span class="comment">//构造器，get()，set()，toString()方法略</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="【Page-java】"><a href="#【Page-java】" class="headerlink" title="【Page.java】"></a>【Page.java】</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 页码类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Page</span>&lt;<span class="title">T</span>&gt; </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> List&lt;T&gt; list; <span class="comment">// 每页查到的记录存放的集合</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PAGE_SIZE = <span class="number">4</span>; <span class="comment">// 每页显示的记录数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> pageNo; <span class="comment">// 当前页</span></span><br><span class="line"><span class="comment">//private int totalPageNo; // 总页数，通过计算得到</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> totalRecord; <span class="comment">// 总记录数，通过查询数据库得到</span></span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h3 id="【User-java】"><a href="#【User-java】" class="headerlink" title="【User.java】"></a>【User.java】</h3><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.bookstore.beans;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> songhongkang</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>{</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><h2 id="第8章：数据库连接池"><a href="#第8章：数据库连接池" class="headerlink" title="第8章：数据库连接池"></a>第8章：数据库连接池</h2><h3 id="8-1-JDBC数据库连接池的必要性"><a href="#8-1-JDBC数据库连接池的必要性" class="headerlink" title="8.1 JDBC数据库连接池的必要性"></a>8.1 JDBC数据库连接池的必要性</h3><ul><li><p>在使用开发基于数据库的web程序时，传统的模式基本是按以下步骤：　　</p><ul><li><strong>在主程序（如servlet、beans）中建立数据库连接</strong></li><li><strong>进行sql操作</strong></li><li><strong>断开数据库连接</strong></li></ul></li><li><p>这种模式开发，存在的问题:</p><ul><li>普通的JDBC数据库连接使用 DriverManager 来获取，每次向数据库建立连接的时候都要将 Connection 加载到内存中，再验证用户名和密码(得花费0.05s～1s的时间)。需要数据库连接的时候，就向数据库要求一个，执行完成后再断开连接。这样的方式将会消耗大量的资源和时间。<strong>数据库的连接资源并没有得到很好的重复利用。</strong>若同时有几百人甚至几千人在线，频繁的进行数据库连接操作将占用很多的系统资源，严重的甚至会造成服务器的崩溃。</li><li><strong>对于每一次数据库连接，使用完后都得断开。</strong>否则，如果程序出现异常而未能关闭，将会导致数据库系统中的内存泄漏，最终将导致重启数据库。（回忆：何为Java的内存泄漏？）</li><li><strong>这种开发不能控制被创建的连接对象数</strong>，系统资源会被毫无顾及的分配出去，如连接过多，也可能导致内存泄漏，服务器崩溃。 </li></ul></li></ul><h3 id="8-2-数据库连接池技术"><a href="#8-2-数据库连接池技术" class="headerlink" title="8.2 数据库连接池技术"></a>8.2 数据库连接池技术</h3><ul><li><p>为解决传统开发中的数据库连接问题，可以采用数据库连接池技术。</p></li><li><p><strong>数据库连接池的基本思想</strong>：就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需从“缓冲池”中取出一个，使用完毕之后再放回去。</p></li><li><p><strong>数据库连接池</strong>负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接，而不是重新建立一个</strong>。</p></li><li><p>数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由<strong>最小数据库连接数来设定</strong>的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的<strong>最大数据库连接数量</strong>限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。</p></li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555593464033.png" alt="1555593464033"></p><ul><li><strong>工作原理：</strong></li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1566745811244.png" alt="1555593598606"></p><ul><li><p><strong>数据库连接池技术的优点</strong></p><p><strong>1. 资源重用</strong></p><p>由于数据库连接得以重用，避免了频繁创建，释放连接引起的大量性能开销。在减少系统消耗的基础上，另一方面也增加了系统运行环境的平稳性。</p><p><strong>2. 更快的系统反应速度</strong></p><p>数据库连接池在初始化过程中，往往已经创建了若干数据库连接置于连接池中备用。此时连接的初始化工作均已完成。对于业务请求处理而言，直接利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而减少了系统的响应时间</p><p><strong>3. 新的资源分配手段</strong></p><p>对于多应用共享同一数据库的系统而言，可在应用层通过数据库连接池的配置，实现某一应用最大可用数据库连接数的限制，避免某一应用独占所有的数据库资源</p><p><strong>4. 统一的连接管理，避免数据库连接泄漏</strong></p><p>在较为完善的数据库连接池实现中，可根据预先的占用超时设定，强制回收被占用连接，从而避免了常规数据库连接操作中可能出现的资源泄露</p></li></ul><h3 id="8-3-多种开源的数据库连接池"><a href="#8-3-多种开源的数据库连接池" class="headerlink" title="8.3 多种开源的数据库连接池"></a>8.3 多种开源的数据库连接池</h3><ul><li>JDBC 的数据库连接池使用 javax.sql.DataSource 来表示，DataSource 只是一个接口，该接口通常由服务器(Weblogic, WebSphere, Tomcat)提供实现，也有一些开源组织提供实现：<ul><li><strong>DBCP</strong> 是Apache提供的数据库连接池。tomcat 服务器自带dbcp数据库连接池。<strong>速度相对c3p0较快</strong>，但因自身存在BUG，Hibernate3已不再提供支持。</li><li><strong>C3P0</strong> 是一个开源组织提供的一个数据库连接池，<strong>速度相对较慢，稳定性还可以。</strong>hibernate官方推荐使用</li><li><strong>Proxool</strong> 是sourceforge下的一个开源项目数据库连接池，有监控连接池状态的功能，<strong>稳定性较c3p0差一点</strong></li><li><strong>BoneCP</strong> 是一个开源组织提供的数据库连接池，速度快</li><li><strong>Druid</strong> 是阿里提供的数据库连接池，据说是集DBCP 、C3P0 、Proxool 优点于一身的数据库连接池，但是速度不确定是否有BoneCP快</li></ul></li><li>DataSource 通常被称为数据源，它包含连接池和连接池管理两个部分，习惯上也经常把 DataSource 称为连接池</li><li><strong>DataSource用来取代DriverManager来获取Connection，获取速度快，同时可以大幅度提高数据库访问速度。</strong></li><li>特别注意：<ul><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此<strong>整个应用只需要一个数据源即可。</strong></li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但conn.close()并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li></ul></li></ul><h4 id="8-3-1-C3P0数据库连接池"><a href="#8-3-1-C3P0数据库连接池" class="headerlink" title="8.3.1 C3P0数据库连接池"></a>8.3.1 C3P0数据库连接池</h4><ul><li>获取连接方式一</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的方式，获取数据库的连接：不推荐</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">cpds.setDriverClass(<span class="string">"com.mysql.jdbc.Driver"</span>); </span><br><span class="line">cpds.setJdbcUrl(<span class="string">"jdbc:mysql://localhost:3306/test"</span>);</span><br><span class="line">cpds.setUser(<span class="string">"root"</span>);</span><br><span class="line">cpds.setPassword(<span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//cpds.setMaxPoolSize(100);</span></span><br><span class="line"></span><br><span class="line">Connection conn = cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>获取连接方式二</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用C3P0数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource cpds = <span class="keyword">new</span> ComboPooledDataSource(<span class="string">"helloc3p0"</span>);</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection2</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>{</span><br><span class="line">Connection conn = cpds.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，src下的配置文件为：【c3p0-config.xml】</p><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">"helloc3p0"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 获取连接的4个基本信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>abc123<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 涉及到数据库连接池的管理的相关属性的设置 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 若数据库中连接数不足时, 一次向数据库服务器申请多少个连接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 初始化数据库连接池时连接的数量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池中的最小的数据库连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据库连接池中的最大的数据库连接数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- C3P0 数据库连接池可以维护的 Statement 的个数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>20<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 每个连接同时可以使用的 Statement 对象的个数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatementsPerConnection"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure><h4 id="8-3-2-DBCP数据库连接池"><a href="#8-3-2-DBCP数据库连接池" class="headerlink" title="8.3.2 DBCP数据库连接池"></a>8.3.2 DBCP数据库连接池</h4><ul><li>DBCP 是 Apache 软件基金组织下的开源连接池实现，该连接池依赖该组织下的另一个开源系统：Common-pool。如需使用该连接池实现，应在系统中增加如下两个 jar 文件：<ul><li>Commons-dbcp.jar：连接池的实现</li><li>Commons-pool.jar：连接池实现的依赖库</li></ul></li><li><strong>Tomcat 的连接池正是采用该连接池来实现的。</strong>该数据库连接池既可以与应用服务器整合使用，也可由应用程序独立使用。</li><li>数据源和数据库连接不同，数据源无需创建多个，它是产生数据库连接的工厂，因此整个应用只需要一个数据源即可。</li><li>当数据库访问结束后，程序还是像以前一样关闭数据库连接：conn.close(); 但上面的代码并没有关闭数据库的物理连接，它仅仅把数据库连接释放，归还给了数据库连接池。</li><li>配置属性说明</li></ul><table><thead><tr><th>属性</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td>initialSize</td><td>0</td><td>连接池启动时创建的初始化连接数量</td></tr><tr><td>maxActive</td><td>8</td><td>连接池中可同时连接的最大的连接数</td></tr><tr><td>maxIdle</td><td>8</td><td>连接池中最大的空闲的连接数，超过的空闲连接将被释放，如果设置为负数表示不限制</td></tr><tr><td>minIdle</td><td>0</td><td>连接池中最小的空闲的连接数，低于这个数量会被创建新的连接。该参数越接近maxIdle，性能越好，因为连接的创建和销毁，都是需要消耗资源的；但是不能太大。</td></tr><tr><td>maxWait</td><td>无限制</td><td>最大等待时间，当没有可用连接时，连接池等待连接释放的最大时间，超过该时间限制会抛出异常，如果设置-1表示无限等待</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>开启池的Statement是否prepared</td></tr><tr><td>maxOpenPreparedStatements</td><td>无限制</td><td>开启池的prepared 后的同时最大连接数</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td>连接池中连接，在时间段内一直空闲， 被逐出连接池的时间</td></tr><tr><td>removeAbandonedTimeout</td><td>300</td><td>超过时间限制，回收没有用(废弃)的连接</td></tr><tr><td>removeAbandoned</td><td>false</td><td>超过removeAbandonedTimeout时间后，是否进 行没用连接（废弃）的回收</td></tr></tbody></table><ul><li>获取连接方式一：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">BasicDataSource source = <span class="keyword">new</span> BasicDataSource();</span><br><span class="line"></span><br><span class="line">source.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">source.setUrl(<span class="string">"jdbc:mysql:///test"</span>);</span><br><span class="line">source.setUsername(<span class="string">"root"</span>);</span><br><span class="line">source.setPassword(<span class="string">"abc123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">source.setInitialSize(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">Connection conn = source.getConnection();</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>获取连接方式二：</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用dbcp数据库连接池的配置文件方式，获取数据库的连接：推荐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource source = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>{</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line">Properties pros = <span class="keyword">new</span> Properties();</span><br><span class="line"></span><br><span class="line">InputStream is = DBCPTest.class.getClassLoader().getResourceAsStream(<span class="string">"dbcp.properties"</span>);</span><br><span class="line"></span><br><span class="line">pros.load(is);</span><br><span class="line"><span class="comment">//根据提供的BasicDataSourceFactory创建对应的DataSource对象</span></span><br><span class="line">source = BasicDataSourceFactory.createDataSource(pros);</span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection4</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line"></span><br><span class="line">Connection conn = source.getConnection();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><p>其中，src下的配置文件为：【dbcp.properties】</p><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">driverClassName</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true&amp;useServerPrepStmts=false</span></span><br><span class="line"><span class="attr">username</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">abc123</span></span><br><span class="line"></span><br><span class="line"><span class="attr">initialSize</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#...</span></span><br></pre></td></tr></tbody></table></figure><h4 id="8-3-3-Druid（德鲁伊）数据库连接池"><a href="#8-3-3-Druid（德鲁伊）数据库连接池" class="headerlink" title="8.3.3 Druid（德鲁伊）数据库连接池"></a>8.3.3 Druid（德鲁伊）数据库连接池</h4><p>Druid是阿里巴巴开源平台上一个数据库连接池实现，它结合了C3P0、DBCP、Proxool等DB池的优点，同时加入了日志监控，可以很好的监控DB池连接和SQL的执行情况，可以说是针对监控而生的DB连接池，<strong>可以说是目前最好的连接池之一。</strong></p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.druid;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestDruid</span> </span>{</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties(); pro.load(TestDruid.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>));</span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">Connection conn = ds.getConnection();</span><br><span class="line">System.out.println(conn);</span><br><span class="line">}</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure><p>其中，src下的配置文件为：【druid.properties】</p><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">url=jdbc:mysql:<span class="comment">//localhost:3306/test?rewriteBatchedStatements=true</span></span><br><span class="line">username=root</span><br><span class="line">password=<span class="number">123456</span></span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">initialSize=<span class="number">10</span></span><br><span class="line">maxActive=<span class="number">20</span></span><br><span class="line">maxWait=<span class="number">1000</span></span><br><span class="line">filters=wall</span><br></pre></td></tr></tbody></table></figure><ul><li>详细配置参数：</li></ul><table><thead><tr><th><strong>配置</strong></th><th><strong>缺省</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>name</td><td></td><td>配置这个属性的意义在于，如果存在多个数据源，监控的时候可以通过名字来区分开来。   如果没有配置，将会生成一个名字，格式是：”DataSource-” +   System.identityHashCode(this)</td></tr><tr><td>url</td><td></td><td>连接数据库的url，不同数据库不一样。例如：mysql :   jdbc:mysql://10.20.153.104:3306/druid2      oracle :   jdbc:oracle:thin:@10.20.149.85:1521:ocnauto</td></tr><tr><td>username</td><td></td><td>连接数据库的用户名</td></tr><tr><td>password</td><td></td><td>连接数据库的密码。如果你不希望密码直接写在配置文件中，可以使用ConfigFilter。详细看这里：<a href="https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter">https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</a></td></tr><tr><td>driverClassName</td><td></td><td>根据url自动识别   这一项可配可不配，如果不配置druid会根据url自动识别dbType，然后选择相应的driverClassName(建议配置下)</td></tr><tr><td>initialSize</td><td>0</td><td>初始化时建立物理连接的个数。初始化发生在显示调用init方法，或者第一次getConnection时</td></tr><tr><td>maxActive</td><td>8</td><td>最大连接池数量</td></tr><tr><td>maxIdle</td><td>8</td><td>已经不再使用，配置了也没效果</td></tr><tr><td>minIdle</td><td></td><td>最小连接池数量</td></tr><tr><td>maxWait</td><td></td><td>获取连接时最大等待时间，单位毫秒。配置了maxWait之后，缺省启用公平锁，并发效率会有所下降，如果需要可以通过配置useUnfairLock属性为true使用非公平锁。</td></tr><tr><td>poolPreparedStatements</td><td>false</td><td>是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭。</td></tr><tr><td>maxOpenPreparedStatements</td><td>-1</td><td>要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100</td></tr><tr><td>validationQuery</td><td></td><td>用来检测连接是否有效的sql，要求是一个查询语句。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会其作用。</td></tr><tr><td>testOnBorrow</td><td>true</td><td>申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。</td></tr><tr><td>testOnReturn</td><td>false</td><td>归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能</td></tr><tr><td>testWhileIdle</td><td>false</td><td>建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。</td></tr><tr><td>timeBetweenEvictionRunsMillis</td><td></td><td>有两个含义： 1)Destroy线程会检测连接的间隔时间2)testWhileIdle的判断依据，详细看testWhileIdle属性的说明</td></tr><tr><td>numTestsPerEvictionRun</td><td></td><td>不再使用，一个DruidDataSource只支持一个EvictionRun</td></tr><tr><td>minEvictableIdleTimeMillis</td><td></td><td></td></tr><tr><td>connectionInitSqls</td><td></td><td>物理连接初始化的时候执行的sql</td></tr><tr><td>exceptionSorter</td><td></td><td>根据dbType自动识别   当数据库抛出一些不可恢复的异常时，抛弃连接</td></tr><tr><td>filters</td><td></td><td>属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：   监控统计用的filter:stat日志用的filter:log4j防御sql注入的filter:wall</td></tr><tr><td>proxyFilters</td><td></td><td>类型是List，如果同时配置了filters和proxyFilters，是组合关系，并非替换关系</td></tr></tbody></table><h2 id="第9章：Apache-DBUtils实现CRUD操作"><a href="#第9章：Apache-DBUtils实现CRUD操作" class="headerlink" title="第9章：Apache-DBUtils实现CRUD操作"></a>第9章：Apache-DBUtils实现CRUD操作</h2><h3 id="9-1-Apache-DBUtils简介"><a href="#9-1-Apache-DBUtils简介" class="headerlink" title="9.1 Apache-DBUtils简介"></a>9.1 Apache-DBUtils简介</h3><ul><li><p>commons-dbutils 是 Apache 组织提供的一个开源 JDBC工具类库，它是对JDBC的简单封装，学习成本极低，并且使用dbutils能极大简化jdbc编码的工作量，同时也不会影响程序的性能。</p></li><li><p>API介绍：</p><ul><li>org.apache.commons.dbutils.QueryRunner</li><li>org.apache.commons.dbutils.ResultSetHandler</li><li>工具类：org.apache.commons.dbutils.DbUtils   </li></ul></li><li><p>API包说明：</p></li></ul><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555595163263.png" alt="1555595163263"></p><p><img src="https://gitee.com/ma_tung_zhou/imageuse1/raw/master/imgg/1555595198644.png" alt="1555595198644"></p><h3 id="9-2-主要API的使用"><a href="#9-2-主要API的使用" class="headerlink" title="9.2 主要API的使用"></a>9.2 主要API的使用</h3><h4 id="9-2-1-DbUtils"><a href="#9-2-1-DbUtils" class="headerlink" title="9.2.1 DbUtils"></a>9.2.1 DbUtils</h4><ul><li>DbUtils ：提供如关闭连接、装载JDBC驱动程序等常规工作的工具类，里面的所有方法都是静态的。主要方法如下：<ul><li><strong>public static void close(…) throws java.sql.SQLException</strong>：　DbUtils类提供了三个重载的关闭方法。这些方法检查所提供的参数是不是NULL，如果不是的话，它们就关闭Connection、Statement和ResultSet。</li><li>public static void closeQuietly(…): 这一类方法不仅能在Connection、Statement和ResultSet为NULL情况下避免关闭，还能隐藏一些在程序中抛出的SQLEeception。</li><li>public static void commitAndClose(Connection conn)throws SQLException： 用来提交连接的事务，然后关闭连接</li><li>public static void commitAndCloseQuietly(Connection conn)： 用来提交连接，然后关闭连接，并且在关闭连接时不抛出SQL异常。 </li><li>public static void rollback(Connection conn)throws SQLException：允许conn为null，因为方法内部做了判断</li><li>public static void rollbackAndClose(Connection conn)throws SQLException</li><li>rollbackAndCloseQuietly(Connection)</li><li>public static boolean loadDriver(java.lang.String driverClassName)：这一方装载并注册JDBC驱动程序，如果成功就返回true。使用该方法，你不需要捕捉这个异常ClassNotFoundException。</li></ul></li></ul><h4 id="9-2-2-QueryRunner类"><a href="#9-2-2-QueryRunner类" class="headerlink" title="9.2.2 QueryRunner类"></a>9.2.2 QueryRunner类</h4><ul><li><p><strong>该类简单化了SQL查询，它与ResultSetHandler组合在一起使用可以完成大部分的数据库操作，能够大大减少编码量。</strong></p></li><li><p>QueryRunner类提供了两个构造器：</p><ul><li>默认的构造器</li><li>需要一个 javax.sql.DataSource 来作参数的构造器</li></ul></li><li><p>QueryRunner类的主要方法：</p><ul><li><strong>更新</strong><ul><li>public int update(Connection conn, String sql, Object… params) throws SQLException:用来执行一个更新（插入、更新或删除）操作。</li><li>……</li></ul></li><li><strong>插入</strong><ul><li>public <t> T insert(Connection conn,String sql,ResultSetHandler<t> rsh, Object… params) throws SQLException：只支持INSERT语句，其中 rsh - The handler used to create the result object from the ResultSet of auto-generated keys.  返回值: An object generated by the handler.即自动生成的键值</t></t></li><li>….</li></ul></li><li><strong>批处理</strong><ul><li>public int[] batch(Connection conn,String sql,Object[][] params)throws SQLException： INSERT, UPDATE, or DELETE语句</li><li>public <t> T insertBatch(Connection conn,String sql,ResultSetHandler<t> rsh,Object[][] params)throws SQLException：只支持INSERT语句</t></t></li><li>…..</li></ul></li><li><strong>查询</strong><ul><li>public Object query(Connection conn, String sql, ResultSetHandler rsh,Object… params) throws SQLException：执行一个查询操作，在这个查询中，对象数组中的每个元素值被用来作为查询语句的置换参数。该方法会自行处理 PreparedStatement 和 ResultSet 的创建和关闭。</li><li>…… </li></ul></li></ul></li><li><p>测试</p></li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试添加</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testInsert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">String sql = <span class="string">"insert into customers(name,email,birth)values(?,?,?)"</span>;</span><br><span class="line"><span class="keyword">int</span> count = runner.update(conn, sql, <span class="string">"何成飞"</span>, <span class="string">"he@qq.com"</span>, <span class="string">"1992-09-08"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"添加了"</span> + count + <span class="string">"条记录"</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试删除</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line">String sql = <span class="string">"delete from customers where id &lt; ?"</span>;</span><br><span class="line"><span class="keyword">int</span> count = runner.update(conn, sql,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"删除了"</span> + count + <span class="string">"条记录"</span>);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h4 id="9-2-3-ResultSetHandler接口及实现类"><a href="#9-2-3-ResultSetHandler接口及实现类" class="headerlink" title="9.2.3 ResultSetHandler接口及实现类"></a>9.2.3 ResultSetHandler接口及实现类</h4><ul><li><p>该接口用于处理 java.sql.ResultSet，将数据按要求转换为另一种形式。</p></li><li><p>ResultSetHandler 接口提供了一个单独的方法：Object handle (java.sql.ResultSet .rs)。</p></li><li><p>接口的主要实现类：</p><ul><li><p>ArrayHandler：把结果集中的第一行数据转成对象数组。</p></li><li><p>ArrayListHandler：把结果集中的每一行数据都转成一个数组，再存放到List中。</p></li><li><p><strong>BeanHandler：</strong>将结果集中的第一行数据封装到一个对应的JavaBean实例中。</p></li><li><p><strong>BeanListHandler：</strong>将结果集中的每一行数据都封装到一个对应的JavaBean实例中，存放到List里。</p></li><li><p>ColumnListHandler：将结果集中某一列的数据存放到List中。</p></li><li><p>KeyedHandler(name)：将结果集中的每一行数据都封装到一个Map里，再把这些map再存到一个map里，其key为指定的key。</p></li><li><p><strong>MapHandler：</strong>将结果集中的第一行数据封装到一个Map里，key是列名，value就是对应的值。</p></li><li><p><strong>MapListHandler：</strong>将结果集中的每一行数据都封装到一个Map里，然后再存放到List</p></li><li><p><strong>ScalarHandler：</strong>查询单个值对象</p></li></ul></li></ul><ul><li>测试</li></ul><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询一条记录</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"select id,name,email,birth from customers where id = ?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">BeanHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanHandler&lt;&gt;(Customer.class);</span><br><span class="line">Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">System.out.println(customer);</span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 测试查询:查询多条记录构成的集合</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用ResultSetHandler的实现类：BeanListHandler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryList</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"select id,name,email,birth from customers where id &lt; ?"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">BeanListHandler&lt;Customer&gt; handler = <span class="keyword">new</span> BeanListHandler&lt;&gt;(Customer.class);</span><br><span class="line">List&lt;Customer&gt; list = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line">list.forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 自定义ResultSetHandler的实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryInstance1</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line">String sql = <span class="string">"select id,name,email,birth from customers where id = ?"</span>;</span><br><span class="line"></span><br><span class="line">ResultSetHandler&lt;Customer&gt; handler = <span class="keyword">new</span> ResultSetHandler&lt;Customer&gt;() {</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Customer <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>{</span><br><span class="line">System.out.println(<span class="string">"handle"</span>);</span><br><span class="line"><span class="comment">//return new Customer(1,"Tom","tom@126.com",new Date(123323432L));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(rs.next()){</span><br><span class="line"><span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);</span><br><span class="line">String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">String email = rs.getString(<span class="string">"email"</span>);</span><br><span class="line">Date birth = rs.getDate(<span class="string">"birth"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> Customer(id, name, email, birth);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line">Customer customer = runner.query(conn, sql, handler, <span class="number">23</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(customer);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如何查询类似于最大的，最小的，平均的，总和，个数相关的数据，</span></span><br><span class="line"><span class="comment"> * 使用ScalarHandler</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testQueryValue</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>{</span><br><span class="line">QueryRunner runner = <span class="keyword">new</span> QueryRunner();</span><br><span class="line"></span><br><span class="line">Connection conn = JDBCUtils.getConnection3();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试一：</span></span><br><span class="line"><span class="comment">//String sql = "select count(*) from customers where id &lt; ?";</span></span><br><span class="line"><span class="comment">//ScalarHandler handler = new ScalarHandler();</span></span><br><span class="line"><span class="comment">//long count = (long) runner.query(conn, sql, handler, 20);</span></span><br><span class="line"><span class="comment">//System.out.println(count);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//测试二：</span></span><br><span class="line">String sql = <span class="string">"select max(birth) from customers"</span>;</span><br><span class="line">ScalarHandler handler = <span class="keyword">new</span> ScalarHandler();</span><br><span class="line">Date birth = (Date) runner.query(conn, sql, handler);</span><br><span class="line">System.out.println(birth);</span><br><span class="line"></span><br><span class="line">JDBCUtils.closeResource(conn, <span class="keyword">null</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="JDBC总结"><a href="#JDBC总结" class="headerlink" title="JDBC总结"></a>JDBC总结</h2><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">总结</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdateWithTx</span><span class="params">()</span> </span>{</span><br><span class="line"></span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//1.获取连接的操作（</span></span><br><span class="line"><span class="comment">//① 手写的连接：JDBCUtils.getConnection();</span></span><br><span class="line"><span class="comment">//② 使用数据库连接池：C3P0;DBCP;Druid</span></span><br><span class="line"><span class="comment">//2.对数据表进行一系列CRUD操作</span></span><br><span class="line"><span class="comment">//① 使用PreparedStatement实现通用的增删改、查询操作（version 1.0 \ version 2.0)</span></span><br><span class="line"><span class="comment">//version2.0的增删改public void update(Connection conn,String sql,Object ... args){}</span></span><br><span class="line"><span class="comment">//version2.0的查询 public &lt;T&gt; T getInstance(Connection conn,Class&lt;T&gt; clazz,String sql,Object ... args){}</span></span><br><span class="line"><span class="comment">//② 使用dbutils提供的jar包中提供的QueryRunner类</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//提交数据</span></span><br><span class="line">conn.commit();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">} <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">e.printStackTrace();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> {</span><br><span class="line"><span class="comment">//回滚数据</span></span><br><span class="line">conn.rollback();</span><br><span class="line">} <span class="keyword">catch</span> (SQLException e1) {</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">}<span class="keyword">finally</span>{</span><br><span class="line"><span class="comment">//3.关闭连接等操作</span></span><br><span class="line"><span class="comment">//① JDBCUtils.closeResource();</span></span><br><span class="line"><span class="comment">//② 使用dbutils提供的jar包中提供的DbUtils类提供了关闭的相关操作</span></span><br><span class="line"></span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDBC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习算法实现</title>
      <link href="/2020/07/16/ji-qi-xue-xi-suan-fa-shi-xian/"/>
      <url>/2020/07/16/ji-qi-xue-xi-suan-fa-shi-xian/</url>
      
        <content type="html"><![CDATA[<h3 id="机器学习算法实现"><a href="#机器学习算法实现" class="headerlink" title="机器学习算法实现"></a>机器学习算法实现</h3><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200716191936979.png" alt="image-20200716191936979"></p><h4 id="smile-本仓库是《scikit-learn-机器学习-常用算法及编程实战》的学习笔记，使用sklearn实现常用的机器学习算法，附有代码、文档以及相关数据集。"><a href="#smile-本仓库是《scikit-learn-机器学习-常用算法及编程实战》的学习笔记，使用sklearn实现常用的机器学习算法，附有代码、文档以及相关数据集。" class="headerlink" title=":smile: 本仓库是《scikit-learn 机器学习 常用算法及编程实战》的学习笔记，使用sklearn实现常用的机器学习算法，附有代码、文档以及相关数据集。"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span> 本仓库是《scikit-learn 机器学习 常用算法及编程实战》的学习笔记，使用sklearn实现常用的机器学习算法，附有代码、文档以及相关数据集。</h4><p>项目地址： <a href="https://github.com/DongZhouGu/scikit-learn-ml">https://github.com/DongZhouGu/scikit-learn-ml</a></p><h4 id="smile-也可以到我的网站上阅读"><a href="#smile-也可以到我的网站上阅读" class="headerlink" title=":smile:也可以到我的网站上阅读"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8">😄</span>也可以到<a href="https://dongzhougu.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">我的网站</a>上阅读</h4><ol><li><a href="https://github.com/DongZhouGu/scikit-learn-ml/tree/master/1.%20K-%E8%BF%91%E9%82%BB">K-近邻算法</a></li><li><a href="https://github.com/DongZhouGu/scikit-learn-ml/tree/master/2.%20%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92">线性回归算法</a></li><li><a href="https://github.com/DongZhouGu/scikit-learn-ml/tree/master/3.%20%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92">逻辑回归算法</a></li><li><a href="https://github.com/DongZhouGu/scikit-learn-ml/tree/master/4.%20%E5%86%B3%E7%AD%96%E6%A0%91">决策树算法</a></li><li><a href="https://github.com/DongZhouGu/scikit-learn-ml/tree/master/5.%20%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM">支持向量机SVM</a></li><li><a href="https://github.com/DongZhouGu/scikit-learn-ml/tree/master/6.%20%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF">朴素贝叶斯算法</a></li><li><a href="https://github.com/DongZhouGu/scikit-learn-ml/tree/master/7.%20PCA">PCA算法</a></li><li><a href="https://github.com/DongZhouGu/scikit-learn-ml/tree/master/8.%20K-%E5%9D%87%E5%80%BC">K-均值算法</a></li></ol><hr><p>scikit-learn是一个开源的Python语言机器学习工具包。它涵盖了几乎所有主流机器学习算法的实现，并且提供了一致的调用接口。它基于Numpy和SciPy等Python数值计算库，提供了高效的算法实现。总结起来，scikit-learn工具包有以下几个优点：</p><ul><li>文档齐全：官方文档齐全，更新及时。</li><li>接口易用：针对所有的算法提供了一致的接口调用规则，不管是KNN、K-Means还是PCA。</li><li>算法全面：涵盖主流机器学习任务的算法，包括回归算法、分类算法、聚类分析、数据降维处理等。</li></ul><p>当然，scikit-learn不支持分布式计算，不适合用来处理超大型数据，但这并不影响scikit-learn作为一个优秀的机器学习工具库这个事实。</p><h3 id="机器学习应用开发的典型步骤"><a href="#机器学习应用开发的典型步骤" class="headerlink" title="机器学习应用开发的典型步骤"></a>机器学习应用开发的典型步骤</h3><p>假设：要开发一个房价评估系统，目标是对一个已知特征的房子价格进行评估预测。</p><p>建立这样一个系统，通常包括以下几个步骤：</p><h5 id="（1）数据采集和标记"><a href="#（1）数据采集和标记" class="headerlink" title="（1）数据采集和标记"></a>（1）数据采集和标记</h5><p>我们需要大量不同特征的房子和所对应的价格信息，可以直接从房产评估中心获取房子的相关信息，如房子的面子、地理位置、朝向、价格等。另外还有一些信息房产评估中心不一定有，比如房子所在地的学校情况，这一特征往往会影响房子的价格，这个时候就需要通过其他途径收集这些数据。以上收集到的所有数据叫做训练样本，或数据集。房子的面积、地理位置等称为特征。在数据采集阶段，需要收集尽量多的特征。特征越全、数据越多，训练出来的模型才会越准确。</p><p>我们的房屋价格信息是从房产评估中心获得的，这一数据可能不准确。因为有时为了避税，房屋的评估价格会比房子的真实交易价格低很多。这时就需要采集房子的实际成交价格，这一过程称为数据标记。数据标记可以是人工标记，比如逐个从房产中介那里打听房子的实际成交价格；也可以是自动标记，比如通过分析数据，找出房产评估中心给的房子评估价格和真实成交价格的匹配关系，然后直接算出来。数据标记对有监督的学习方法是必须的。比如，针对垃圾邮件过滤系统，训练样本必须包含该邮件是否为垃圾邮件的标记数据。</p><h5 id="（2）数据清洗"><a href="#（2）数据清洗" class="headerlink" title="（2）数据清洗"></a>（2）数据清洗</h5><p>假设我们采集到的数据里，关于房子的面积，有按平方米计算的，也有按平方英尺计算的，这时需要对面积单位进行统一。这个过程称为数据清洗。数据清洗还包括去掉重复数据及噪声数据，让数据具备结构化特征，以方便作为机器学习算法的输入。</p><h5 id="（3）特征选择"><a href="#（3）特征选择" class="headerlink" title="（3）特征选择"></a>（3）特征选择</h5><p>假设我们采集到了房子的100个特征，通过逐个分析这些特征，最终选择了30个特征作为输入。这个过程称为特征选择。特征选择的方法之一是人工选择，即对逐个特征进行人工分析，然后选择合适的特征集合。另外一个方法是通过模型来自动选择，如后面将要介绍的主成分分析（PCA）算法。</p><h5 id="（4）模型选择"><a href="#（4）模型选择" class="headerlink" title="（4）模型选择"></a>（4）模型选择</h5><p>房价评估系统是属于有监督学习的回归学习类型，我们可以选择最简单的线性模型来模拟。选择哪个模型，和问题领域、数据量大小、训练时长、模型的准确度等多方面因素有关。这些内容将在第3章进行介绍。</p><h5 id="（5）模型训练和测试"><a href="#（5）模型训练和测试" class="headerlink" title="（5）模型训练和测试"></a>（5）模型训练和测试</h5><p>把数据集分成训练数据集和测试数据集，一般按照8:2或者7:3来划分，然后用训练数据集来训练模型。训练出参数后再使用测试数据集来测试模型的准确度。为什么要分出一个单独的测试数据集来做测试呢？答案是必须保证测试的准确性，即模型的准确性是要用它没见过的数据来测试，而不能用那些用来训练这个模型的数据来测试。理论上更合理的数据集划分方案是分成3个，即再分出一个交叉验证数据集。这些内容将在第3章进行介绍。</p><h5 id="（6）模型性能评估和优化"><a href="#（6）模型性能评估和优化" class="headerlink" title="（6）模型性能评估和优化"></a>（6）模型性能评估和优化</h5><p>模型训练出来后，需要对该模型进行性能评估。性能评估一般包括以下几个方面：</p><p>训练时长：是指需要花多少时间来训练这个模型。对于一些海量数据的机器学习应用，可能需要1个月甚至更长的时间来训练一个模型，这个时候算法的训练性能就变得很重要了。</p><p>另外，还需要判断数据集是否足够多。一般而言，对于复杂特征的系统，训练数据集越大越好。</p><p>然后还需要判断模型的准确性，即对于一个新的数据能否准确的进行预测。</p><p>最后需要判断模型是否能满足应用场景的性能要求，如果不能满足要求，就需要优化，然后继续对模型进行训练和评估，或者更换为其他模型。</p><h5 id="（7）模型使用"><a href="#（7）模型使用" class="headerlink" title="（7）模型使用"></a>（7）模型使用</h5><p>训练出来的模型可以把参数保存起来，下次使用时直接加载即可。一般来讲，模型训练需要的计算量是很大的，也需要较长的时间来训练，这是因为一个好的模型参数，需要对大型数据集进行训练后才能得到。而真正使用模型时，其计算量是比较少的，一般是直接把新样本作为输入，然后调用模型即可得出结果。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 开源项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列九：K-均值</title>
      <link href="/2020/07/16/scikit-learn-xi-lie-jiu-k-jun-zhi/"/>
      <url>/2020/07/16/scikit-learn-xi-lie-jiu-k-jun-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="K-Means聚类算法"><a href="#K-Means聚类算法" class="headerlink" title="K-Means聚类算法"></a>K-Means聚类算法</h2><p>聚类，简单来说，就是将一个庞杂数据集中具有相似特征的数据自动归类到一起，称为一个簇，簇内的对象越相似，聚类的效果越好。它是一种无监督的学习(Unsupervised Learning)方法,不需要预先标注好的训练集。聚类与分类最大的区别就是分类的目标事先已知，例如猫狗识别，你在分类之前已经预先知道要将它分为猫、狗两个种类；而在你聚类之前，你对你的目标是未知的，同样以动物为例，对于一个动物集来说，你并不清楚这个数据集内部有多少种类的动物，你能做的只是利用聚类方法将它自动按照特征分为多类，然后人为给出这个聚类结果的定义（即簇识别）。例如，你将一个动物集分为了三簇（类），然后通过观察这三类动物的特征，你为每一个簇起一个名字，如大象、狗、猫等，这就是聚类的基本思想。     </p><p>至于“相似”这一概念，是利用距离这个评价标准来衡量的，我们通过计算对象与对象之间的距离远近来判断它们是否属于同一类别，即是否是同一个簇。至于距离如何计算，科学家们提出了许多种距离的计算方法，其中欧式距离是最为简单和常用的，除此之外还有曼哈顿距离和余弦相似性距离等。</p><p>欧式距离，我想大家再熟悉不过了，但为免有一些基础薄弱的同学，在此再说明一下，它的定义为:<br>对于x点坐标为(x1,x2,x3,…,xn)和 y点坐标为(y1,y2,y3,…,yn)，两者的欧式距离为:<br>$$<br>d(x,y)<br>    ={\sqrt{<br>            (x_{1}-y_{1})^{2}+(x_{2}-y_{2})^{2} + \cdots +(x_{n}-y_{n})^{2}<br>        }}<br>    ={\sqrt{<br>            \sum_{ {i=1} }^{n}(x_{i}-y_{i})^{2}<br>        }}<br>$$</p><p>在二维平面，它就是我们初中时就学过的两点距离公式</p><h2 id="1-K-Means-算法"><a href="#1-K-Means-算法" class="headerlink" title="1. K-Means 算法"></a>1. K-Means 算法</h2><p>K-Means 是发现给定数据集的 K 个簇的聚类算法, 之所以称之为 <code>K-均值</code> 是因为它可以发现 K 个不同的簇, 且每个簇的中心采用簇中所含值的均值计算而成.<br>簇个数 K 是用户指定的, 每一个簇通过其质心（centroid）, 即簇中所有点的中心来描述.<br>聚类与分类算法的最大区别在于, 分类的目标类别已知, 而聚类的目标类别是未知的. </p><p><strong>优点</strong>:</p><ul><li>属于无监督学习，无须准备训练集</li><li>原理简单，实现起来较为容易</li><li>结果可解释性较好</li></ul><p><strong>缺点</strong>:</p><ul><li><strong>需手动设置k值</strong>。 在算法开始预测之前，我们需要手动设置k值，即估计数据大概的类别个数，不合理的k值会使结果缺乏解释性</li><li>可能收敛到局部最小值, 在大规模数据集上收敛较慢</li><li>对于异常点、离群点敏感</li></ul><p>使用数据类型 : 数值型数据</p><h3 id="1-1-K-Means-场景"><a href="#1-1-K-Means-场景" class="headerlink" title="1.1 K-Means 场景"></a>1.1 K-Means 场景</h3><p>kmeans，如前所述，用于数据集内种类属性不明晰，希望能够通过数据挖掘出或自动归类出有相似特点的对象的场景。其商业界的应用场景一般为挖掘出具有相似特点的潜在客户群体以便公司能够重点研究、对症下药。  </p><p>例如，在2000年和2004年的美国总统大选中，候选人的得票数比较接近或者说非常接近。任一候选人得到的普选票数的最大百分比为50.7%而最小百分比为47.9% 如果1%的选民将手中的选票投向另外的候选人，那么选举结果就会截然不同。 实际上，如果妥善加以引导与吸引，少部分选民就会转换立场。尽管这类选举者占的比例较低，但当候选人的选票接近时，这些人的立场无疑会对选举结果产生非常大的影响。如何找出这类选民，以及如何在有限的预算下采取措施来吸引他们？ 答案就是聚类（Clustering)。</p><p>那么，具体如何实施呢？首先，收集用户的信息，可以同时收集用户满意或不满意的信息，这是因为任何对用户重要的内容都可能影响用户的投票结果。然后，将这些信息输入到某个聚类算法中。接着，对聚类结果中的每一个簇（最好选择最大簇 ）， 精心构造能够吸引该簇选民的消息。最后， 开展竞选活动并观察上述做法是否有效。</p><p>另一个例子就是产品部门的市场调研了。为了更好的了解自己的用户，产品部门可以采用聚类的方法得到不同特征的用户群体，然后针对不同的用户群体可以对症下药，为他们提供更加精准有效的服务。</p><h3 id="1-2-K-Means-术语"><a href="#1-2-K-Means-术语" class="headerlink" title="1.2 K-Means 术语"></a>1.2 K-Means 术语</h3><ul><li>簇: 所有数据的点集合，簇中的对象是相似的。</li><li>质心: 簇中所有点的中心（计算所有点的均值而来）.</li><li>SSE: Sum of Sqared Error（误差平方和）, 它被用来评估模型的好坏，SSE 值越小，表示越接近它们的质心. 聚类效果越好。由于对误差取了平方，因此更加注重那些远离中心的点（一般为边界点或离群点）。详情见kmeans的评价标准。</li></ul><p>有关 <code>簇</code> 和 <code>质心</code> 术语更形象的介绍, 请参考下图:</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/apachecn-k-means-term-1.jpg" alt="K-Means 术语图"></p><h3 id="1-3-K-Means-工作流程"><a href="#1-3-K-Means-工作流程" class="headerlink" title="1.3 K-Means 工作流程"></a>1.3 K-Means 工作流程</h3><ol><li>首先, 随机确定 K 个初始点作为质心（<strong>不必是数据中的点</strong>）。</li><li>然后将数据集中的每个点分配到一个簇中, 具体来讲, 就是为每个点找到距其最近的质心, 并将其分配该质心所对应的簇. 这一步完成之后, 每个簇的质心更新为该簇所有点的平均值.<br>3.重复上述过程直到数据集中的所有点都距离它所对应的质心最近时结束。</li></ol><p>上述过程的 <code>伪代码</code> 如下:</p><ul><li>创建 k 个点作为起始质心（通常是随机选择）</li><li>当任意一个点的簇分配结果发生改变时（不改变时算法结束）<ul><li>对数据集中的每个数据点<ul><li>对每个质心<ul><li>计算质心与数据点之间的距离</li></ul></li><li>将数据点分配到距其最近的簇</li></ul></li><li>对每一个簇, 计算簇中所有点的均值并将均值作为质心</li></ul></li></ul><h2 id="2-sklearn-里的K-均值算法"><a href="#2-sklearn-里的K-均值算法" class="headerlink" title="2. sklearn 里的K-均值算法"></a>2. sklearn 里的K-均值算法</h2><p>cikit-learn里的K-均值算法由sklearn.cluster.KMeans类实现。下面通过一个简单的例子，来学习怎样在scikit-learn里使用K-均值算法。</p><p>我们生成一组包含两个特征的200个样本：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line">X,y = make_blobs(n_samples=<span class="number">200</span>,</span><br><span class="line">                n_features=<span class="number">2</span>,</span><br><span class="line">                centers=<span class="number">4</span>,</span><br><span class="line">                cluster_std=<span class="number">1</span>,</span><br><span class="line">                center_box=(-<span class="number">10.0</span>,<span class="number">10.0</span>),</span><br><span class="line">                shuffle=<span class="literal">True</span>,</span><br><span class="line">                random_state=<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure><p>然后把样本画在二维坐标系上，以便直观地观察：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">4</span>),dpi=<span class="number">144</span>)</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],s=<span class="number">20</span>,marker=<span class="string">'o'</span>)</span><br></pre></td></tr></tbody></table></figure><p>结果如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200716173322275.png" alt="image-20200716173322275"></p><p>接着使用 <code>KMeans</code> 模型来拟合。我们设置类别个数为3，并计算出其拟合后的成本。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line">n_clusters = <span class="number">3</span></span><br><span class="line">kmeans = KMeans(n_clusters=n_clusters)</span><br><span class="line">kmeans.fit(X)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"kmeans: k = {}, cost = {}"</span>.<span class="built_in">format</span>(n_clusters,<span class="built_in">int</span>(kmeans.score(X))))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kmeans: k = <span class="number">3</span>, cost = -<span class="number">668</span></span><br></pre></td></tr></tbody></table></figure><p><code>KMeans.score()</code> 函数计算K-均值算法拟合后的成本，用负数表示，其绝对值越大，说明成本越高。前面介绍过，K-均值算法成本的物理意义为训练样本到其所属的聚类中心的距离平均值，在 <code>scikit-learn</code> 里，其计算成本的方法略有不同，它是计算训练样本到其所属的聚类中心的距离的总和。</p><p>当然我们还可以把分类后的样本及其所属的聚类中心都画出来，这样可以更直观地观察算法的拟合效果。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">labels = kmean.labels_</span><br><span class="line">centers = kmean.cluster_centers_</span><br><span class="line">markers = [<span class="string">'o'</span>, <span class="string">'^'</span>, <span class="string">'*'</span>]</span><br><span class="line">colors = [<span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'y'</span>]</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">4</span>), dpi=<span class="number">144</span>)</span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画样本</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">    cluster = X[labels == c]</span><br><span class="line">    plt.scatter(cluster[:, <span class="number">0</span>], cluster[:, <span class="number">1</span>], </span><br><span class="line">                marker=markers[c], s=<span class="number">20</span>, c=colors[c])</span><br><span class="line"><span class="comment"># 画出中心点</span></span><br><span class="line">plt.scatter(centers[:, <span class="number">0</span>], centers[:, <span class="number">1</span>],</span><br><span class="line">            marker=<span class="string">'o'</span>, c=<span class="string">"white"</span>, alpha=<span class="number">0.9</span>, s=<span class="number">300</span>)</span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(centers):</span><br><span class="line">    plt.scatter(c[<span class="number">0</span>], c[<span class="number">1</span>], marker=<span class="string">'$%d$'</span> % i, s=<span class="number">50</span>, c=colors[i])</span><br></pre></td></tr></tbody></table></figure><p>输出结果如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200716173439992.png" alt="image-20200716173439992"></p><p>前面说过，K-均值算法的一个关键参数是K，即聚类个数。从技术角度来讲，K值越大，算法成本越低，这个很容易理解。但从业务角度来看，不是K值越大越好。针对本节的例子，分别选择K=[2,3,4]这三种不同的聚类个数，来观察一下K-均值算法最终拟合的结果及其成本。</p><p>我们可以把画出K-均值聚类结果的代码稍微改造一下，变成一个函数。这个函数会使用K-均值算法来进行聚类拟合，同时会画出按照这个聚类个数拟合后的分类情况：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_plot_kmean_model</span>(<span class="params">n_clusters, X</span>):</span></span><br><span class="line">    plt.xticks(())</span><br><span class="line">    plt.yticks(())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用 k-均值算法进行拟合</span></span><br><span class="line">    kmean = KMeans(n_clusters=n_clusters)</span><br><span class="line">    kmean.fit_predict(X)</span><br><span class="line"></span><br><span class="line">    labels = kmean.labels_</span><br><span class="line">    centers = kmean.cluster_centers_</span><br><span class="line">    markers = [<span class="string">'o'</span>, <span class="string">'^'</span>, <span class="string">'*'</span>, <span class="string">'s'</span>]</span><br><span class="line">    colors = [<span class="string">'r'</span>, <span class="string">'b'</span>, <span class="string">'y'</span>, <span class="string">'k'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 计算成本</span></span><br><span class="line">    score = kmean.score(X)</span><br><span class="line">    plt.title(<span class="string">"k={}, score={}"</span>.<span class="built_in">format</span>(n_clusters, (<span class="built_in">int</span>)(score)))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 画样本</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">        cluster = X[labels == c]</span><br><span class="line">        plt.scatter(cluster[:, <span class="number">0</span>], cluster[:, <span class="number">1</span>], </span><br><span class="line">                    marker=markers[c], s=<span class="number">20</span>, c=colors[c])</span><br><span class="line">    <span class="comment"># 画出中心点</span></span><br><span class="line">    plt.scatter(centers[:, <span class="number">0</span>], centers[:, <span class="number">1</span>],</span><br><span class="line">                marker=<span class="string">'o'</span>, c=<span class="string">"white"</span>, alpha=<span class="number">0.9</span>, s=<span class="number">300</span>)</span><br><span class="line">    <span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(centers):</span><br><span class="line">        plt.scatter(c[<span class="number">0</span>], c[<span class="number">1</span>], marker=<span class="string">'$%d$'</span> % i, s=<span class="number">50</span>, c=colors[i])</span><br></pre></td></tr></tbody></table></figure><p>函数接受两个参数，一个是聚类个数，即K的值，另一个是数据样本。有了这个函数，接下来就简单了，可以很容易分别对[2,3,4]这三种不同的K值情况进行聚类分析，并把聚类结果可视化。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line">n_clusters = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">3</span>), dpi=<span class="number">144</span>)</span><br><span class="line"><span class="keyword">for</span> i, c <span class="keyword">in</span> <span class="built_in">enumerate</span>(n_clusters):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">3</span>, i + <span class="number">1</span>)</span><br><span class="line">    fit_plot_kmean_model(c, X)</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200716175104911.png" alt="image-20200716175104911"></p><h2 id="3-使用K-均值对文档进行聚类分析"><a href="#3-使用K-均值对文档进行聚类分析" class="headerlink" title="3. 使用K-均值对文档进行聚类分析"></a>3. 使用K-均值对文档进行聚类分析</h2><p>本节介绍如何使用K-均值算法对文档进行聚类分析。假设有一个博客平台，用户在平台上发布博客，我们如何对博客进行聚类分析，以方便展示不同类别下的热门文章呢？</p><h3 id="3-1-加载数据集"><a href="#3-1-加载数据集" class="headerlink" title="3.1 加载数据集"></a>3.1 加载数据集</h3><p>我们的任务就是把数据集目录下<code>data/</code>的文档进行聚类分析。你可能有疑问：这些文档不是按照文件夹已经分好类了吗？是的，这是人工标记了的数据。有了人工标记的数据，就可以检验K-均值算法的性能。</p><p>首先需要导入数据：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from time <span class="keyword">import</span> time</span><br><span class="line">from sklearn.datasets <span class="keyword">import</span> load_files</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"loading documents ..."</span>)</span><br><span class="line">t = time()</span><br><span class="line">docs = load_files(<span class="string">'datasets/clustering/data'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"summary: {0} documents in {1} categories."</span>.format(</span><br><span class="line">    <span class="built_in">len</span>(docs.data), <span class="built_in">len</span>(docs.target_names)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done in {0} seconds"</span>.format(time() - t))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loading documents ...</span><br><span class="line">summary: 3949 documents <span class="keyword">in</span> 4 categories.</span><br><span class="line"><span class="keyword">done</span> <span class="keyword">in</span> 26.920000076293945 seconds</span><br></pre></td></tr></tbody></table></figure><p>总共有3949篇文章，人工标记在4个类别里。接着把文档转化为TF-IDF向量：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"></span><br><span class="line">max_features = <span class="number">20000</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"vectorizing documents ..."</span>)</span><br><span class="line">t = time()</span><br><span class="line">vectorizer = TfidfVectorizer(max_df=<span class="number">0.4</span>, </span><br><span class="line">                             min_df=<span class="number">2</span>, </span><br><span class="line">                             max_features=max_features, </span><br><span class="line">                             encoding=<span class="string">'latin-1'</span>)</span><br><span class="line">X = vectorizer.fit_transform((d <span class="keyword">for</span> d <span class="keyword">in</span> docs.data))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"n_samples: %d, n_features: %d"</span> % X.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"number of non-zero features in sample [{0}]: {1}"</span>.<span class="built_in">format</span>(</span><br><span class="line">    docs.filenames[<span class="number">0</span>], X[<span class="number">0</span>].getnnz()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done in {0} seconds"</span>.<span class="built_in">format</span>(time() - t))</span><br></pre></td></tr></tbody></table></figure><p>这里需要注意TfidfVectorizer的几个参数的选择。max_df=0.4表示如果一个单词在40%的文档里都出现过，则认为是一个高频词，对文档聚类没有帮助，在生成词典时就会剔除这个词。min_df=2表示，如果一个单词的词频太低，小于等于2个，则也把这个单词从词典里剔除。max_features可以进一步过滤词典的大小，它会根据TF-IDF权重从高到低进行排序，然后取前面权重高的单词构成词典。输出如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vectorizing documents ...</span><br><span class="line">n_samples: <span class="number">3949</span>, n_features: <span class="number">20000</span></span><br><span class="line">number of non-zero features in sample [datasets/clustering/data\sci.electronics\<span class="number">11902</span>-<span class="number">54322</span>]: <span class="number">56</span></span><br><span class="line">done in <span class="number">1.9150002002716064</span> seconds</span><br></pre></td></tr></tbody></table></figure><p>从输出可知，每篇文章构成的向量都是一个稀疏向量，其大部分元素都为0。这也容易理解，我们的词典大小为20000个词，而示例文章中不重复的单词却只有56个。</p><h3 id="3-2-文本聚类分析"><a href="#3-2-文本聚类分析" class="headerlink" title="3.2 文本聚类分析"></a>3.2 文本聚类分析</h3><p>接着使用KMeans算法对文档进行聚类分析：</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.cluster <span class="keyword">import</span> KMeans</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"clustering documents ..."</span>)</span><br><span class="line">t = time()</span><br><span class="line">n_clusters = <span class="number">4</span></span><br><span class="line">kmean = KMeans(n_clusters=n_clusters, </span><br><span class="line">               max_iter=<span class="number">100</span>,</span><br><span class="line">               tol=<span class="number">0.01</span>,</span><br><span class="line">               verbose=<span class="number">1</span>,</span><br><span class="line">               n_init=<span class="number">3</span>)</span><br><span class="line">kmean.fit(X);</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"kmean: k={}, cost={}"</span>.format(n_clusters, <span class="built_in">int</span>(kmean.inertia_)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done in {0} seconds"</span>.format(time() - t))</span><br></pre></td></tr></tbody></table></figure><p>选择聚类个数为4个。max_iter=100表示最多进行100次K-均值迭代。tol=0.1表示中心点移动距离小于0.1时就认为算法已经收敛，停止迭代。verbose=1表示输出迭代过程的详细信息。n_init=3表示进行3遍K-均值运算后求平均值。前面介绍过，在算法刚开始迭代时，会随机选择聚类中心点，不同的中心点可能导致不同的收敛效果，因此多次运算求平均值的方法可以提高算法的稳定性。由于开启了迭代过程信息显示，输出了较多的信息：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">clustering documents ...</span><br><span class="line">Initialization complete</span><br><span class="line">Iteration  0, inertia 7488.362</span><br><span class="line">Iteration  1, inertia 3845.708</span><br><span class="line">Iteration  2, inertia 3835.369</span><br><span class="line">Iteration  3, inertia 3828.959</span><br><span class="line">Iteration  4, inertia 3824.555</span><br><span class="line">Iteration  5, inertia 3820.932</span><br><span class="line">Iteration  6, inertia 3818.555</span><br><span class="line">Iteration  7, inertia 3817.377</span><br><span class="line">Iteration  8, inertia 3816.317</span><br><span class="line">Iteration  9, inertia 3815.570</span><br><span class="line">Iteration 10, inertia 3815.351</span><br><span class="line">Iteration 11, inertia 3815.234</span><br><span class="line">Iteration 12, inertia 3815.181</span><br><span class="line">Iteration 13, inertia 3815.151</span><br><span class="line">Iteration 14, inertia 3815.136</span><br><span class="line">Iteration 15, inertia 3815.120</span><br><span class="line">Iteration 16, inertia 3815.113</span><br><span class="line">Iteration 17, inertia 3815.106</span><br><span class="line">Iteration 18, inertia 3815.104</span><br><span class="line">Converged at iteration 18: center <span class="built_in">shift</span> 0.000000e+00 within tolerance 4.896692e-07</span><br><span class="line">Initialization complete</span><br><span class="line">Iteration  0, inertia 7494.329</span><br><span class="line">Iteration  1, inertia 3843.474</span><br><span class="line">Iteration  2, inertia 3835.570</span><br><span class="line">Iteration  3, inertia 3828.511</span><br><span class="line">Iteration  4, inertia 3823.826</span><br><span class="line">Iteration  5, inertia 3819.972</span><br><span class="line">Iteration  6, inertia 3817.714</span><br><span class="line">Iteration  7, inertia 3816.666</span><br><span class="line">Iteration  8, inertia 3816.032</span><br><span class="line">Iteration  9, inertia 3815.778</span><br><span class="line">Iteration 10, inertia 3815.652</span><br><span class="line">Iteration 11, inertia 3815.548</span><br><span class="line">Iteration 12, inertia 3815.462</span><br><span class="line">Iteration 13, inertia 3815.424</span><br><span class="line">Iteration 14, inertia 3815.411</span><br><span class="line">Iteration 15, inertia 3815.404</span><br><span class="line">Iteration 16, inertia 3815.402</span><br><span class="line">Converged at iteration 16: center <span class="built_in">shift</span> 0.000000e+00 within tolerance 4.896692e-07</span><br><span class="line">Initialization complete</span><br><span class="line">Iteration  0, inertia 7538.349</span><br><span class="line">Iteration  1, inertia 3844.796</span><br><span class="line">Iteration  2, inertia 3828.820</span><br><span class="line">Iteration  3, inertia 3822.973</span><br><span class="line">Iteration  4, inertia 3821.341</span><br><span class="line">Iteration  5, inertia 3820.164</span><br><span class="line">Iteration  6, inertia 3819.181</span><br><span class="line">Iteration  7, inertia 3818.546</span><br><span class="line">Iteration  8, inertia 3818.167</span><br><span class="line">Iteration  9, inertia 3817.975</span><br><span class="line">Iteration 10, inertia 3817.862</span><br><span class="line">Iteration 11, inertia 3817.770</span><br><span class="line">Iteration 12, inertia 3817.723</span><br><span class="line">Iteration 13, inertia 3817.681</span><br><span class="line">Iteration 14, inertia 3817.654</span><br><span class="line">Iteration 15, inertia 3817.628</span><br><span class="line">Iteration 16, inertia 3817.607</span><br><span class="line">Iteration 17, inertia 3817.593</span><br><span class="line">Iteration 18, inertia 3817.585</span><br><span class="line">Iteration 19, inertia 3817.580</span><br><span class="line">Converged at iteration 19: center <span class="built_in">shift</span> 0.000000e+00 within tolerance 4.896692e-07</span><br><span class="line">kmean: k=4, cost=3815</span><br><span class="line"><span class="keyword">done</span> <span class="keyword">in</span> 39.484999895095825 seconds</span><br></pre></td></tr></tbody></table></figure><p>我们好奇的是：在进行聚类分析的过程中，哪些单词的权重最高，从而较容易地决定一个文章的类别？我们可以查看每种类别文档中，其权重最高的10个单词分别是什么？</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Top terms per cluster:"</span>)</span><br><span class="line">order_centroids = kmean.cluster_centers_.argsort()[:, ::-<span class="number">1</span>]</span><br><span class="line">terms = vectorizer.get_feature_names()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_clusters):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Cluster %d:"</span> % i, end=<span class="string">''</span>)</span><br><span class="line">    <span class="keyword">for</span> ind <span class="keyword">in</span> order_centroids[i, :<span class="number">10</span>]:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">' %s'</span> % terms[ind], end=<span class="string">''</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></tbody></table></figure><p>理解这段代码的关键在于argsort()函数，它的作用是把一个Numpy数组进行升序排列，返回的是排序后的索引。</p><p>回到我们的代码里，由于 kmean.cluster_centers 是二维数组，因此 kmean.cluster_centers.argsort()[:,::-1] 语句的含义就是把聚类中心点的不同分量，按照从大到小的顺序进行排序，并且把排序后的元素索引保存在二维数组order_centroids里。vectorizer.get_feature_names()将得到我们的词典单词，根据索引即可得到每个类别里权重最高的那些单词了。输出如下：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Top terms per cluster:</span><br><span class="line">Cluster <span class="number">0</span>: space henry nasa toronto moon pat zoo shuttle gov orbit</span><br><span class="line">Cluster <span class="number">1</span>: my any me <span class="keyword">by</span> know your some <span class="keyword">do</span> so has</span><br><span class="line">Cluster <span class="number">2</span>: key clipper encryption chip government will keys escrow we nsa</span><br><span class="line">Cluster <span class="number">3</span>: geb pitt banks gordon shameful dsl n3jxp chastity cadre surrender</span><br></pre></td></tr></tbody></table></figure><h3 id="4-聚类算法性能评估"><a href="#4-聚类算法性能评估" class="headerlink" title="4.聚类算法性能评估"></a>4.聚类算法性能评估</h3><p>聚类性能评估比较复杂，不像分类那样直观。针对分类问题，我们可以直接计算被错误分类的样本数量，这样可以直接算出分类算法的准确率。聚类问题不能使用绝对数量的方法进行性能评估，原因是，聚类分析后的类别与原来已标记的类别之间不存在必然的一一对应关系。更典型的，针对K-均值算法，我们可以选择K的数值不等于已标记的类别个数。</p><p>前面介绍决策树的时候简单介绍过“熵”的概念，它是信息论中最重要的基础概念。熵表示一个系统的有序程度，而聚类问题的性能评估，就是对比经过聚类算法处理后的数据的有序程度，与人工标记的有序程度之间的差异。下面介绍几个常用的聚类算法性能评估指标</p><h6 id="1-Adjust-Rand-Index"><a href="#1-Adjust-Rand-Index" class="headerlink" title="1.Adjust Rand Index"></a><strong>1.Adjust Rand Index</strong></h6><p>Adjust Rand Index是一种衡量两个序列相似性的算法。它的优点是，针对两个随机序列，它的值为负数或接近0。而针对两个结构相同的序列，它的值接近1。而且对类别标签不敏感。</p><h6 id="2-齐次性和完整性"><a href="#2-齐次性和完整性" class="headerlink" title="2.齐次性和完整性"></a><strong>2.齐次性和完整性</strong></h6><p>根据条件熵分析，可以得到另外两个衡量聚类算法性能的指标，分别是齐次性（homogeneity）和完整性（completeness）。齐次性表示一个聚类元素只由一种类别的元素组成。完整性表示给定的已标记的类别，全部分配到一个聚类里。它们的值均介于[0,1]之间。</p><h6 id="3-轮廓系数"><a href="#3-轮廓系数" class="headerlink" title="3.轮廓系数"></a><strong>3.轮廓系数</strong></h6><p>上面介绍的聚类性能评估方法都需要有已标记的类别数据，这个在实践中是很难做到的。如果已经标记了数据，就会直接使用有监督的学习算法，而无监督学习算法的最大优点就是不需要对数据集进行标记。轮廓系数可以在不需要已标记的数据集的前提下，对聚类算法的性能进行评估。</p><p>轮廓系数由以下两个指标构成：</p><ul><li>a：一个样本与其所在相同聚类的点的平均距离；</li><li>b：一个样本与其距离最近的下一个聚类里的点的平均距离。</li></ul><p>针对这个样本，其轮廓系数s的值为：<br>$$<br>s=\frac{b-a}{\max (a, b)}<br>$$<br>针对一个数据集，其轮廓系数s为其所有样本的轮廓系数的平均值。轮廓系数的数值介于[-1,1]之间，-1表示完全错误的聚类，1表示完美的聚类，0表示聚类重叠。</p><p>针对前面的例子，可以分别计算本节介绍的几个聚类算法性能评估指标，综合来看聚类算法的性能：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> metrics</span><br><span class="line">labels = docs.target</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Homogeneity: %0.3f"</span> % metrics.homogeneity_score(labels, kmean.labels_))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Completeness: %0.3f"</span> % metrics.completeness_score(labels, kmean.labels_))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"V-measure: %0.3f"</span> % metrics.v_measure_score(labels, kmean.labels_))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Adjusted Rand-Index: %.3f"</span></span><br><span class="line">      % metrics.adjusted_rand_score(labels, kmean.labels_))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Silhouette Coefficient: %0.3f"</span></span><br><span class="line">      % metrics.silhouette_score(X, kmean.labels_, sample_size=<span class="number">1000</span>))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Homogeneity: <span class="number">0.459</span></span><br><span class="line">Completeness: <span class="number">0.519</span></span><br><span class="line">V-measure: <span class="number">0.487</span></span><br><span class="line">Adjusted Rand-Index: <span class="number">0.328</span></span><br><span class="line">Silhouette Coefficient: <span class="number">0.004</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到模型性能很一般。可能的一个原因是数据集质量不高，当然我们也可以阅读原始的语料库，检验一下如果通过人工标记，是否能够标记出这些文章的正确分类。另外，针对my、any、me、by、know、your、some、do、so、has，这些都是没有特征的单词，即使人工标记，也无法判断这些单词应该属于哪种类别的文章。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列八：PCA</title>
      <link href="/2020/07/15/scikit-learn-xi-lie-ba-pca/"/>
      <url>/2020/07/15/scikit-learn-xi-lie-ba-pca/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="1-PCA概述"><a href="#1-PCA概述" class="headerlink" title="1. PCA概述"></a>1. PCA概述</h2><p>PCA算法全称是 Principal Component Analysis，即主成分分析算法。它是一种维数约减（Dimensionality Reduction）算法，即把高维度数据在损失最小的情况下转换为低维度数据的算法。显然，PCA可以用来对数据进行压缩，可以在可控的失真范围内提高运算速度。。</p><h2 id="2-PCA算法原理"><a href="#2-PCA算法原理" class="headerlink" title="2. PCA算法原理"></a>2. PCA算法原理</h2><p>我们先从最简单的情况谈起，假设需要把一个二维数据降维成一维数据，要怎么做呢？如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-805dbb25ada21691.png" alt="img"></p><p>我们可以想办法找出一个向量 $u^{(1)}$ ，以便让二维数据的点（方形点）到这个向量所在的直线上的平均距离最短，即投射误差最小。</p><p>这样就可以在失真最小的情况下，把二维数据转换为向量 $u^{(1)}$ ，所在直线上的一维数据。再进一步，假设需要把三维数据降为二维数据时，我们需要找出两个向量  $u^{(1)}$  和 $u^{(2)}$ ，以便让三维数据的点在这两个向量决定的平面上的投射误差最小。</p><p>如果从数学角度来一般地描述PCA算法就是：当需要从n维数据降为k维数据时，需要找出k个向量</p><p>  $u^{(1)}$  ，  $u^{(2)}$  ，……  $u^{(k)}$  ，把n维的数据投射到这k个向量决定的线性空间里，最终使投射误差最小化的过程。</p><p>问题来了，<strong>怎样找出投射误差最小的k个向量呢</strong>？要完整的用数学公式推导这个方法，涉及较多高级线性代数的知识，这里不再详述。感兴趣的话可以参考后面扩展部分的内容。下面我们直接介绍PCA算法求解的一般步骤。</p><p>假设有一个数据集，用m x n维的矩阵A表示。矩阵中每一行表示一个样本，每一列表示一个特征，总共有m个样本，每个样本有n个特征。我们的目标是减少特征个数，保留最重要的k个特征。</p><h3 id="2-1数据归一化和缩放"><a href="#2-1数据归一化和缩放" class="headerlink" title="2.1数据归一化和缩放"></a>2.1数据归一化和缩放</h3><p>数据归一化和缩放是一种数学技巧，旨在提高PCA运算时的效率。数据归一化的目标是使特征的均值为0。数据归一化公式为:<br>$$<br>x_{j}^{(i)}=a_{j}^{(i)}-\mu_{j}<br>$$<br>其中，$a_{j}^{(i)}$是指第i个样本的第j个特征的值，$\mu_{j}$表示的是第j个特征的均值。当不同的特征值不在同一个数量级上的时候，还需要对数据进行缩放。数据归一化在缩放的公式为：<br>$$<br>x_{j}^{(i)}=\frac{a_{j}^{(i)}-\mu_{j}}{s_{j}}<br>$$<br>其中，$a_{j}^{(i)}$是指第i个样本的第j个特征的值，$\mu_{j}$表示的是第j个特征的均值。$s_{j}$表示第j个特征的范围，即 $s_{j} = max(a_{j}^{(i)})-min(a_{j}^{(i)})$</p><h3 id="2-2-计算协方差矩阵的特征向量"><a href="#2-2-计算协方差矩阵的特征向量" class="headerlink" title="2.2 计算协方差矩阵的特征向量"></a>2.2 计算协方差矩阵的特征向量</h3><p>针对预处理后的矩阵X，先计算其协方差矩阵（Covariance Matrix）：<br>$$<br>\Sigma=\frac{1}{m} X^{T} X<br>$$<br>其中，$\Sigma $ 表示协方差矩阵，用大写的Sigma表示，是一个n * n维的矩阵。</p><p>接着通过奇异值分解来计算协方差矩阵的特征向量：<br>$$<br>[U, S, V]=s v d(\Sigma)<br>$$<br>其中，svd 是奇异值分解（Singular Value Decomposition）运算，是高级线性代数的内容。经过奇异值分解后，有3个返回值，其中矩阵U是一个n * n的矩阵，如果我们选择U的列作为向量，那么我们将得到n个列向量 $u^{(1)}$  ，  $u^{(2)}$  ，……  $u^{(n)}$  ,这些向量就是协方差矩阵的特征向量。它表示的物理意义是，协方差矩阵  $\Sigma $ 可以由这些特征向量进行线性组合得到。</p><h3 id="2-3-数据降维和恢复"><a href="#2-3-数据降维和恢复" class="headerlink" title="2.3  数据降维和恢复"></a>2.3  数据降维和恢复</h3><p>得到特征矩阵后，就可以对数据进行降维处理了。假设降维前的值是  $x^{(i)}$，降维后是$z^{(i)}$，那么<br>$$<br>z^{(i)}=U_{r e d u c e}^{T} x^{(i)}<br>$$<br>其中，$U_{r e d u c e}=[u^{(1)} ,u^{(2)}，……u^{(k)}]$ ，它选取自矩阵U的前k个向量，$U_{r e d u c e}$</p><p>称为主成分特征矩阵，它是数据降维和恢复的关键中间变量。看一下数据维度，$U_{r e d u c e}$是n * k的矩阵，因此 $U_{r e d u c e}^{T}$是k * n的矩阵.</p><p>也可以用矩阵运算一次性转换多个向量，提高效率。假设X是行向量 $x^{(i)}$组成的矩阵，则<br>$$<br>Z=X U_{\text {reduce}}<br>$$<br>其中，X是m * n的矩阵，降维后的矩阵Z是一个m * k的矩阵。</p><p>数据降维后，怎么恢复呢？从前面的计算公式我们知道，降维后的数据计算公式<br>$ z^{(i)}=U_{r e d u c e}^{T} x^{(i)} $ 。所以如果要还原数据，可以使用下面的公式：<br>$$<br>x_{a p p r o x}^{(i)}=U_{r e d u c e} z^{(i)}<br>$$<br>其中，$U_{r e d u c e}$是n * k的矩阵，$z^{(i)}$是k维列向量。这样算出来的$x^{(i)} $就是n维列向量。</p><p>矩阵化数据恢复运算公式为：<br>$$<br>X_{approx}=Z U_{r e d u c e}^{T}<br>$$<br>其中, $X_{approx}$ 是还原回来的数据，是一个m * n的矩阵，每行表示一个训练样例。Z是一个m * k的矩阵，是降维后的数据。</p><h2 id="3-PCA算法示例"><a href="#3-PCA算法示例" class="headerlink" title="3. PCA算法示例"></a>3. PCA算法示例</h2><p>假设我们的数据集总共有5个记录，每个记录有2个特征，这样构成的矩阵A为：<br>$$<br>A=\left[\begin{array}{ll}<br>3 &amp; 2000 \<br>2 &amp; 3000 \<br>4 &amp; 5000 \<br>5 &amp; 8000 \<br>1 &amp; 2000<br>\end{array}\right]<br>$$<br>我们的目标是把二维数据降为一维数据。为了更好地理解PCA的计算过程，分别使用 Numpy和sklearn 对同一个数据进行PCA降维处理。</p><h3 id="3-1-使用Numpy模拟PCA计算过程"><a href="#3-1-使用Numpy模拟PCA计算过程" class="headerlink" title="3.1 使用Numpy模拟PCA计算过程"></a>3.1 使用Numpy模拟PCA计算过程</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">A = np.array([[<span class="number">3</span>,<span class="number">2000</span>],</span><br><span class="line">             [<span class="number">2</span>,<span class="number">3000</span>],</span><br><span class="line">             [<span class="number">4</span>,<span class="number">5000</span>],</span><br><span class="line">             [<span class="number">5</span>,<span class="number">8000</span>],</span><br><span class="line">             [<span class="number">1</span>,<span class="number">2000</span>]],dtype=<span class="string">'float'</span>)</span><br><span class="line"><span class="comment"># 数据归一化，axis=0表示按列归一化</span></span><br><span class="line">mean = np.mean(A,axis=<span class="number">0</span>)</span><br><span class="line">norm = A - mean</span><br><span class="line"><span class="comment"># 数据缩放</span></span><br><span class="line">score = np.<span class="built_in">max</span>(norm,axis=<span class="number">0</span>)-np.<span class="built_in">min</span>(norm,axis=<span class="number">0</span>)</span><br><span class="line">norm = norm / score</span><br><span class="line"><span class="built_in">print</span>(norm)</span><br></pre></td></tr></tbody></table></figure><p>由于两个特征的均值不在同一个数量级，所以对数据进行了缩放。输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[ <span class="number">0.</span>        , -<span class="number">0.33333333</span>],</span><br><span class="line">       [-<span class="number">0.25</span>      , -<span class="number">0.16666667</span>],</span><br><span class="line">       [ <span class="number">0.25</span>      ,  <span class="number">0.16666667</span>],</span><br><span class="line">       [ <span class="number">0.5</span>       ,  <span class="number">0.66666667</span>],</span><br><span class="line">       [-<span class="number">0.5</span>       , -<span class="number">0.33333333</span>]])</span><br></pre></td></tr></tbody></table></figure><p>接着，对协方差矩阵进行奇异值分解，求解其特征向量：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">U,S,V = np.linalg.svd(np.dot(norm.T,norm))</span><br><span class="line"><span class="built_in">print</span>(U)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[-<span class="number">0.67710949</span>, -<span class="number">0.73588229</span>],</span><br><span class="line">       [-<span class="number">0.73588229</span>,  <span class="number">0.67710949</span>]])</span><br></pre></td></tr></tbody></table></figure><p>由于需要把二维数据降为一维数据，因此只取特征矩阵的第一列（前k列）来构造主成分特征矩阵$U_{reduce}$</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">U_reduce = U[:,<span class="number">0</span>].reshape(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">U_reduce</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([[-<span class="number">0.67710949</span>],</span><br><span class="line">       [-<span class="number">0.73588229</span>]])</span><br></pre></td></tr></tbody></table></figure><p>有了主成分特征矩阵，就可以对数据进行降维了：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">R = np.dot(norm,U_reduce)</span><br><span class="line"><span class="built_in">print</span>(R)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[ <span class="number">0.2452941</span> ],</span><br><span class="line">       [ <span class="number">0.29192442</span>],</span><br><span class="line">       [-<span class="number">0.29192442</span>],</span><br><span class="line">       [-<span class="number">0.82914294</span>],</span><br><span class="line">       [ <span class="number">0.58384884</span>]])</span><br></pre></td></tr></tbody></table></figure><p>这样就把二维的数据降为一维的数据了。如果需要还原数据，依照PCA数据恢复的计算公式，可得：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Z = np.dot(R,U_reduce.T)</span><br><span class="line"><span class="built_in">print</span>(Z)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[-<span class="number">0.16609096</span>, -<span class="number">0.18050758</span>],</span><br><span class="line">       [-<span class="number">0.19766479</span>, -<span class="number">0.21482201</span>],</span><br><span class="line">       [ <span class="number">0.19766479</span>,  <span class="number">0.21482201</span>],</span><br><span class="line">       [ <span class="number">0.56142055</span>,  <span class="number">0.6101516</span> ],</span><br><span class="line">       [-<span class="number">0.39532959</span>, -<span class="number">0.42964402</span>]])</span><br></pre></td></tr></tbody></table></figure><p>由于我们在数据预处理阶段对数据进行了归一化，并且做了缩放处理，所以需要进一步还原才能得到原始数据，这一步是数据预处理的逆运算。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A1 = np.multiply(Z,scope)+mean</span><br><span class="line"><span class="built_in">print</span>(A1)</span><br></pre></td></tr></tbody></table></figure><p>其中，np.multiply是矩阵对应元素相乘，np.dot是矩阵的行乘以矩阵的列。输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">2.33563616e+00</span>, <span class="number">2.91695452e+03</span>],</span><br><span class="line">       [<span class="number">2.20934082e+00</span>, <span class="number">2.71106794e+03</span>],</span><br><span class="line">       [<span class="number">3.79065918e+00</span>, <span class="number">5.28893206e+03</span>],</span><br><span class="line">       [<span class="number">5.24568220e+00</span>, <span class="number">7.66090960e+03</span>],</span><br><span class="line">       [<span class="number">1.41868164e+00</span>, <span class="number">1.42213588e+03</span>]])</span><br></pre></td></tr></tbody></table></figure><p>与原始矩阵A相比，恢复后的数据A1还是存在一定程度的失真，这种失真是不可避免的。</p><h3 id="3-2-使用sklearn进行PCA降维运算"><a href="#3-2-使用sklearn进行PCA降维运算" class="headerlink" title="3.2 使用sklearn进行PCA降维运算"></a>3.2 使用sklearn进行PCA降维运算</h3><p>在 <code>sklearn</code>工具包里，类 <code>sklearn.decomposition.PCA</code> 实现了 PCA 算法，使用方便，不需要了解具体的PCA的运算步骤。但需要注意的是，数据的预处理需要自己完成，其 PCA 算法本身不进行数据预处理（归一化和缩放）。此处，我们选择 <code>MinMaxScaler类</code>进行数据预处理。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> MinMaxScaler</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">std_PCA</span>(<span class="params">**argv</span>):</span></span><br><span class="line">    scaler = MinMaxScaler()</span><br><span class="line">    pca = PCA(**argv)</span><br><span class="line">    pipeline = Pipeline([(<span class="string">'scaler'</span>, scaler),</span><br><span class="line">                         (<span class="string">'pca'</span>, pca)])</span><br><span class="line">    <span class="keyword">return</span> pipeline</span><br><span class="line"></span><br><span class="line">pca = std_PCA(n_components=<span class="number">1</span>)</span><br><span class="line">R2 = pca.fit_transform(A)</span><br><span class="line"><span class="built_in">print</span>(R2)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[-<span class="number">0.2452941</span> ],</span><br><span class="line">       [-<span class="number">0.29192442</span>],</span><br><span class="line">       [ <span class="number">0.29192442</span>],</span><br><span class="line">       [ <span class="number">0.82914294</span>],</span><br><span class="line">       [-<span class="number">0.58384884</span>]])</span><br></pre></td></tr></tbody></table></figure><p>这个输出值就是矩阵A经过预处理以及PCA降维后的数值。我们发现，这里的输出结果和上面使用Numpy方式的输出结果符号相反，这其实不是错误，只是降维后选择的坐标方向不同而已。</p><p>接着把数据恢复回来：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A2 = pca.inverse_transform(R2)</span><br><span class="line"><span class="built_in">print</span>(A2)</span><br></pre></td></tr></tbody></table></figure><p>这里的pca是一个Pipeline实例，其逆运算inverse_transform()是逐级进行的，即先进行PCA还原，再执行预处理的逆运算。即先调用PCA.inverse_transform()，然后再调用MinMaxScaler.inverse_transform()。输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array([[<span class="number">2.33563616e+00</span>, <span class="number">2.91695452e+03</span>],</span><br><span class="line">       [<span class="number">2.20934082e+00</span>, <span class="number">2.71106794e+03</span>],</span><br><span class="line">       [<span class="number">3.79065918e+00</span>, <span class="number">5.28893206e+03</span>],</span><br><span class="line">       [<span class="number">5.24568220e+00</span>, <span class="number">7.66090960e+03</span>],</span><br><span class="line">       [<span class="number">1.41868164e+00</span>, <span class="number">1.42213588e+03</span>]])</span><br></pre></td></tr></tbody></table></figure><p>可以看到，这里还原回来的数据和前面Numpy方式还原回来的数据是一致的。</p><h3 id="3-3-PCA的物理含义"><a href="#3-3-PCA的物理含义" class="headerlink" title="3.3 PCA的物理含义"></a>3.3 PCA的物理含义</h3><p>我们可以把前面例子中的数据在一个坐标轴上全部画出来，从而仔细观察PCA降维过程的物理含义。如下图所示。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw</span>(<span class="params">norm, Z, U, U_reduce</span>):</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">8</span>, <span class="number">8</span>), dpi=<span class="number">144</span>)</span><br><span class="line">    plt.title(<span class="string">'Physcial meanings of PCA'</span>)</span><br><span class="line">    ymin = xmin = -<span class="number">1</span></span><br><span class="line">    ymax = xmax = <span class="number">1</span></span><br><span class="line">    plt.xlim(xmin, xmax)</span><br><span class="line">    plt.ylim(ymin, ymax)</span><br><span class="line">    ax = plt.gca()  <span class="comment"># gca 代表当前坐标轴，即 'get current axis'</span></span><br><span class="line">    ax.spines[<span class="string">'right'</span>].set_color(<span class="string">'none'</span>)  <span class="comment"># 隐藏坐标轴</span></span><br><span class="line">    ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line"></span><br><span class="line">    plt.scatter(norm[:, <span class="number">0</span>], norm[:, <span class="number">1</span>], marker=<span class="string">'s'</span>, c=<span class="string">'b'</span>)</span><br><span class="line">    plt.scatter(Z[:, <span class="number">0</span>], Z[:, <span class="number">1</span>], marker=<span class="string">'o'</span>, c=<span class="string">'r'</span>)</span><br><span class="line">    plt.arrow(<span class="number">0</span>, <span class="number">0</span>, U[<span class="number">0</span>][<span class="number">0</span>], U[<span class="number">1</span>][<span class="number">0</span>], color=<span class="string">'r'</span>, linestyle=<span class="string">'-'</span>)</span><br><span class="line">    plt.arrow(<span class="number">0</span>, <span class="number">0</span>, U[<span class="number">0</span>][<span class="number">1</span>], U[<span class="number">1</span>][<span class="number">1</span>], color=<span class="string">'r'</span>, linestyle=<span class="string">'--'</span>)</span><br><span class="line">    plt.annotate(<span class="string">r'$U_{reduce} = u^{(1)}$'</span>,</span><br><span class="line">                 xy=(U[<span class="number">0</span>][<span class="number">0</span>], U[<span class="number">1</span>][<span class="number">0</span>]), xycoords=<span class="string">'data'</span>,</span><br><span class="line">                 xytext=(U_reduce[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">0.2</span>, U_reduce[<span class="number">1</span>][<span class="number">0</span>] - <span class="number">0.1</span>), fontsize=<span class="number">10</span>,</span><br><span class="line">                 arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">"-&gt;"</span>, connectionstyle=<span class="string">"arc3,rad=.2"</span>))</span><br><span class="line">    plt.annotate(<span class="string">r'$u^{(2)}$'</span>,</span><br><span class="line">                 xy=(U[<span class="number">0</span>][<span class="number">1</span>], U[<span class="number">1</span>][<span class="number">1</span>]), xycoords=<span class="string">'data'</span>,</span><br><span class="line">                 xytext=(U[<span class="number">0</span>][<span class="number">1</span>] + <span class="number">0.2</span>, U[<span class="number">1</span>][<span class="number">1</span>] - <span class="number">0.1</span>), fontsize=<span class="number">10</span>,</span><br><span class="line">                 arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">"-&gt;"</span>, connectionstyle=<span class="string">"arc3,rad=.2"</span>))</span><br><span class="line">    plt.annotate(<span class="string">r'raw data'</span>,</span><br><span class="line">                 xy=(norm[<span class="number">0</span>][<span class="number">0</span>], norm[<span class="number">0</span>][<span class="number">1</span>]), xycoords=<span class="string">'data'</span>,</span><br><span class="line">                 xytext=(norm[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">0.2</span>, norm[<span class="number">0</span>][<span class="number">1</span>] - <span class="number">0.2</span>), fontsize=<span class="number">10</span>,</span><br><span class="line">                 arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">"-&gt;"</span>, connectionstyle=<span class="string">"arc3,rad=.2"</span>))</span><br><span class="line">    plt.annotate(<span class="string">r'projected data'</span>,</span><br><span class="line">                 xy=(Z[<span class="number">0</span>][<span class="number">0</span>], Z[<span class="number">0</span>][<span class="number">1</span>]), xycoords=<span class="string">'data'</span>,</span><br><span class="line">                 xytext=(Z[<span class="number">0</span>][<span class="number">0</span>] + <span class="number">0.2</span>, Z[<span class="number">0</span>][<span class="number">1</span>] - <span class="number">0.1</span>), fontsize=<span class="number">10</span>,</span><br><span class="line">                 arrowprops=<span class="built_in">dict</span>(arrowstyle=<span class="string">"-&gt;"</span>, connectionstyle=<span class="string">"arc3,rad=.2"</span>))</span><br><span class="line">    plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200716110204443.png" alt="image-20200716110204443">图中正方形的点是原始数据经过预处理后（归一化、缩放）的数据，圆形的点是从一维恢复到二维后的数据。同时，我们画出主成分特征向量 $u^{(1)}$ 和  $u^{(2)}$ ，。根据上图，来介绍几个有意思的结论：首先，圆形的点实际上就是方形的点在向量所在 $u^{(1)}$ 直线上的投影。所谓PCA数据恢复，并不是真正的恢复，只是把降维后的坐标转换为原坐标系中的坐标而已。针对我们的例子，只是把由向量 $u^{(1)}$决定的一维坐标系中的坐标转换为原始二维坐标系中的坐标。其次，主成分特征向量 $u^{(1)}$ 和  $u^{(2)}$ 是相互垂直的。再次，方形点和圆形点之间的距离，就是PCA数据降维后的误差。</p><h2 id="4-示例：人脸识别"><a href="#4-示例：人脸识别" class="headerlink" title="4. 示例：人脸识别"></a>4. 示例：人脸识别</h2><p>本节使用英国剑桥AT&amp;T实验室的研究人员自拍的一组照片（AT&amp;TLaboratories Cambridge），来开发一个特定的人脸识别系统。人脸识别，本质上是个分类问题，需要把人脸图片当成训练数据集，对模型进行训练。训练好的模型，就可以对新的人脸照片进行类别预测。这就是人脸识别系统的原理。</p><h3 id="4-1-加载数据集"><a href="#4-1-加载数据集" class="headerlink" title="4.1 加载数据集"></a>4.1 加载数据集</h3><p>查看数据集里所有400张照片的缩略图。数据集总共包含40位人员的照片，每个人10张照片，数据集在仓库<code>dataset</code>文件夹内。</p><p>下载完照片，就可以使用下面的代码来加载这些照片了：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> fetch_olivetti_faces</span><br><span class="line">logging.basicConfig(level=logging.INFO, <span class="built_in">format</span>=<span class="string">'%(asctime)s %(message)s'</span>)</span><br><span class="line">data_home=<span class="string">'datasets/'</span></span><br><span class="line">logging.info(<span class="string">'Start to load dataset'</span>)</span><br><span class="line">faces = fetch_olivetti_faces(data_home=data_home)</span><br><span class="line">logging.info(<span class="string">'Done with load dataset'</span>)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2019</span>-06-<span class="number">23</span> <span class="number">21</span>:<span class="number">45</span>:<span class="number">13</span>,<span class="number">639</span> Start to load dataset</span><br><span class="line"><span class="number">2019</span>-06-<span class="number">23</span> <span class="number">21</span>:<span class="number">45</span>:<span class="number">13</span>,<span class="number">666</span> Done <span class="keyword">with</span> load dataset</span><br></pre></td></tr></tbody></table></figure><p>加载的图片数据集保存在faces变量里，<code>scikit-learn</code> 已经替我们把每张照片做了初步的处理，剪裁成64×64大小且人脸居中显示。这一步至关重要，否则我们的模型将被大量的噪声数据，即图片背景干扰。因为人脸识别的关键是五官纹理和特征，每张照片的背景都不同，人的发型也可能经常变化，这些特征都应该尽量排除在输入特征之外。</p><p>成功加载数据后，其data里保存的就是按照scikit-learn要求的训练数据集，target里保存的就是类别目标索引。我们通过下面的代码，将数据集的概要信息显示出来：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">X = faces.data</span><br><span class="line">y = faces.target</span><br><span class="line">targets = np.unique(faces.target)</span><br><span class="line">target_names = np.array([<span class="string">"c%d"</span> % t <span class="keyword">for</span> t <span class="keyword">in</span> targets])</span><br><span class="line">n_targets = target_names.shape[<span class="number">0</span>]</span><br><span class="line">n_samples, h, w = faces.images.shape</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Sample count: {}\nTarget count: {}'</span>.<span class="built_in">format</span>(n_samples, n_targets))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Image size: {}x{}\nDataset shape: {}\n'</span>.<span class="built_in">format</span>(w, h, X.shape))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sample count: <span class="number">400</span></span><br><span class="line">Target count: <span class="number">40</span></span><br><span class="line">Image size: 64x64</span><br><span class="line">Dataset shape: (<span class="number">400</span>, <span class="number">4096</span>)</span><br></pre></td></tr></tbody></table></figure><p>从输出可知，总共有40位人物的照片，图片总数是400张，输入特征有4096个。为了后续区分不同的人物，我们用索引号给目标人物命名，并保存在变量target_names里。为了更直观地观察数据，从每个人物的照片里随机选择一张显示出来。先定义一个函数来显示照片阵列：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_gallery</span>(<span class="params">images,titles,h,w,n_row=<span class="number">2</span>,n_col=<span class="number">5</span></span>):</span></span><br><span class="line">    <span class="string">"""显示图片阵列"""</span></span><br><span class="line">    plt.figure(figsize=(<span class="number">2</span>*n_col,<span class="number">2</span>*n_row),dpi=<span class="number">144</span>)</span><br><span class="line">    plt.subplots_adjust(bottom=<span class="number">0</span>,left=<span class="number">0.01</span>,right=<span class="number">0.99</span>,top=<span class="number">0.90</span>,hspace=<span class="number">0.01</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_row*n_col):</span><br><span class="line">        plt.subplot(n_row,n_col,i+<span class="number">1</span>)</span><br><span class="line">        plt.imshow(images[i].reshape((h,w)), cmap=plt.cm.gray)</span><br><span class="line">        plt.title(titles[i])</span><br><span class="line">        plt.axis(<span class="string">'off'</span>)</span><br></pre></td></tr></tbody></table></figure><p>输入参数images是一个二维数据，每一行都是一个图片数据。在加载数据时，fetch_olivetti_faces()函数已经帮我们做了预处理，图片的每个像素的RGB值都转换成了[0,1]的浮点数。因此，我们画出来的照片将是黑白的，而不是彩色的。在图片识别领域，一般情况下用黑白照片就可以了，可以减少计算量，也会让模型更准确。</p><p>接着分成两行显示出这些人物的照片：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">n_row = <span class="number">2</span></span><br><span class="line">n_col = <span class="number">6</span></span><br><span class="line">sample_images = <span class="literal">None</span></span><br><span class="line">sample_titles = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_targets):</span><br><span class="line">    people_images = X[y==i]</span><br><span class="line">    people_sample_index = np.random.randint(<span class="number">0</span>, people_images.shape[<span class="number">0</span>], <span class="number">1</span>)</span><br><span class="line">    people_sample_image = people_images[people_sample_index, :]</span><br><span class="line">    <span class="keyword">if</span> sample_images <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        sample_images = np.concatenate((sample_images, people_sample_image), axis=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sample_images = people_sample_image</span><br><span class="line">    sample_titles.append(target_names[i])</span><br><span class="line"></span><br><span class="line">plot_gallery(sample_images, sample_titles, h, w, n_row, n_col)</span><br></pre></td></tr></tbody></table></figure><p>代码中，X[y==i]可以选择出属于特定人物的所有照片，随机选择出来的照片都放在sample_images数组对象里，最后使用我们之前定义的函数plot_gallery()把照片画出来，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200716162800005.png" alt="image-20200716162800005"></p><p>从图片中可以看到，fetch_olivetti_faces()函数帮我们剪裁了中间部分，只留下脸部特征。</p><p>最后，把数据集划分成训练数据集和测试数据集：</p><figure class="highlight jsx"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.2</span>,random_state=<span class="number">4</span>)</span><br></pre></td></tr></tbody></table></figure><h3 id="4-2-一次失败的尝试"><a href="#4-2-一次失败的尝试" class="headerlink" title="4.2 一次失败的尝试"></a>4.2 一次失败的尝试</h3><p>我们使用支持向量机来实现人脸识别：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line">start = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Fitting train datasets ...'</span>)</span><br><span class="line">clf = SVC(class_weight=<span class="string">'balanced'</span>)</span><br><span class="line">clf.fit(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Done in {0:.2f}s'</span>.<span class="built_in">format</span>(time()-start))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fitting train datasets ...</span><br><span class="line">Done <span class="keyword">in</span> <span class="number">0.92</span>s</span><br></pre></td></tr></tbody></table></figure><p>指定SVC的class_weight参数，让SVC模型能根据训练样本的数量来均衡地调整权重，这对不均匀的数据集，即目标人物的照片数量相差较大的情况是非常有帮助的。由于总共只有400张照片，数据规模较小，模型很快就运行完了。</p><p>接着，针对测试数据集进行预测：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Predicting test dataset ...'</span>)</span><br><span class="line">y_pred = clf.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Done in {0:.2f}s'</span>.<span class="built_in">format</span>(time()-start))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Predicting <span class="built_in">test</span> dataset ...</span><br><span class="line">Done <span class="keyword">in</span> 0.10s</span><br></pre></td></tr></tbody></table></figure><p>最后，分别使用 <code>confusion_matrix</code> 和 <code>classification_report</code> 来查看模型分类的准确性。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">cm = confusion_matrix(y_test,y_pred,labels=<span class="built_in">range</span>(n_targets))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'confusion matrix:\n'</span>)</span><br><span class="line">np.set_printoptions(threshold=sys.maxsize)</span><br><span class="line"><span class="built_in">print</span>(cm)</span><br></pre></td></tr></tbody></table></figure><p><code>np.set_printoptions()</code> 是为了确保完整地输出cm数组的内容，这是因为这个数组是40×40的，默认情况下不会全部输出。输出如下：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">confusion matrix:</span><br><span class="line"></span><br><span class="line">[<span class="meta">[0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0</span>]</span><br><span class="line"> [<span class="meta">0 0 0 0 0 0 0 0 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0</span>]]</span><br></pre></td></tr></tbody></table></figure><p><code>confusion matrix</code> 理想的输出，是矩阵的对角线上有数字，其他地方都没有数字。但我们的结果显示不是这样的。可以明显看出，很多图片都被预测成索引为12的类别了。结果看起来完全不对，这是怎么回事呢？我们再看一下classification_report的结果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test,y_pred))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">             precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">         c0       0.00      0.00      0.00         1</span><br><span class="line">         c1       0.00      0.00      0.00         3</span><br><span class="line">         c2       0.00      0.00      0.00         2</span><br><span class="line">         c3       0.00      0.00      0.00         1</span><br><span class="line">         c4       0.00      0.00      0.00         1</span><br><span class="line">         c5       0.00      0.00      0.00         1</span><br><span class="line">         c6       0.00      0.00      0.00         4</span><br><span class="line">         c7       0.00      0.00      0.00         2</span><br><span class="line">         c8       0.00      0.00      0.00         4</span><br><span class="line">         c9       0.00      0.00      0.00         2</span><br><span class="line">        c10       0.00      0.00      0.00         1</span><br><span class="line">        c11       0.00      0.00      0.00         0</span><br><span class="line">        c12       0.00      0.00      0.00         4</span><br><span class="line">        c13       0.00      0.00      0.00         4</span><br><span class="line">        c14       0.00      0.00      0.00         1</span><br><span class="line">        c15       0.00      0.00      0.00         1</span><br><span class="line">        c16       0.00      0.00      0.00         3</span><br><span class="line">        c17       0.00      0.00      0.00         2</span><br><span class="line">        c18       0.00      0.00      0.00         2</span><br><span class="line">        c19       0.00      0.00      0.00         2</span><br><span class="line">        c20       0.00      0.00      0.00         1</span><br><span class="line">        c21       0.00      0.00      0.00         2</span><br><span class="line">        c22       0.00      0.00      0.00         3</span><br><span class="line">        c23       0.00      0.00      0.00         2</span><br><span class="line">        c24       0.00      0.00      0.00         3</span><br><span class="line">        c25       0.00      0.00      0.00         3</span><br><span class="line">        c26       0.00      0.00      0.00         2</span><br><span class="line">        c27       0.00      0.00      0.00         2</span><br><span class="line">        c28       0.00      0.00      0.00         0</span><br><span class="line">        c29       0.00      0.00      0.00         2</span><br><span class="line">        c30       0.00      0.00      0.00         2</span><br><span class="line">        c31       0.00      0.00      0.00         3</span><br><span class="line">        c32       0.00      0.00      0.00         2</span><br><span class="line">        c33       0.00      0.00      0.00         2</span><br><span class="line">        c34       0.00      0.00      0.00         0</span><br><span class="line">        c35       0.00      0.00      0.00         2</span><br><span class="line">        c36       0.00      0.00      0.00         3</span><br><span class="line">        c37       0.00      0.00      0.00         1</span><br><span class="line">        c38       0.00      0.00      0.00         2</span><br><span class="line">        c39       0.00      0.00      0.00         2</span><br><span class="line"></span><br><span class="line">avg / total       0.00      0.00      0.00        80</span><br></pre></td></tr></tbody></table></figure><p>40个类别里，查准率、召回率、F1 Score全为0，不能有更差的预测结果了。为什么？哪里出了差错？</p><p>答案是，我们把每个像素都作为一个输入特征来处理，这样的数据噪声太严重了，模型根本没有办法对训练数据集进行拟合。想想看，我们总共有4096个特征，可是数据集大小才400个，比特征个数还少，而且我们还需要把数据集分出20%来作为测试数据集，这样训练数据集就更小了。这样的状况下，模型根本无法进行准确地训练和预测。</p><h3 id="4-3-使用PCA来处理数据集"><a href="#4-3-使用PCA来处理数据集" class="headerlink" title="4.3 使用PCA来处理数据集"></a>4.3 使用PCA来处理数据集</h3><p>解决上述问题的一个办法是使用 PCA 来给数据降维，只选择前k个最重要的特征。问题来了，选择多少个特征合适呢？即怎么确定k的值？PCA 算法可以通过下面的公式来计算失真幅度：<br>$$<br>\frac{\frac{1}{m} \sum_{i=1}^{m}\left|x^{(i)}-x_{a p p r o x}^{(i)}\right|^{2}}{\frac{1}{m} \sum_{i=1}^{m}\left|x^{(i)}\right|}<br>$$<br>在scikit-learn里，可以从PCA模型的explained_variance_ratio_变量里获取经PCA处理后的数据还原率。这是一个数组，所有元素求和即可知道我们选择的k值的数据还原率，数值越大说明失真越小，随着k值的增大，数值会无限接近于1。</p><p>利用这一特性，可以让k取值10~300之间，每隔30进行一次取样。在所有的k值样本下，计算经过PCA算法处理后的数据还原率。然后根据数据还原率要求，来确定合理的k值。针对我们的情况，选择失真度小于5%，即PCA处理后能保留95%的原数据信息。其代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Exploring explained variance ratio for dataset ..."</span>)</span><br><span class="line">candidate_components = <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">300</span>,<span class="number">30</span>)</span><br><span class="line">explained_ratios = []</span><br><span class="line">start = time()</span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> candidate_components:</span><br><span class="line">    pca = PCA(n_components=c)</span><br><span class="line">    X_pca = pca.fit_transform(X)</span><br><span class="line">    explained_ratios.append(np.<span class="built_in">sum</span>(pca.explained_variance_ratio_))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'Done in {0:.2f}s'</span>.<span class="built_in">format</span>(time()-start))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Exploring explained variance ratio <span class="keyword">for</span> dataset ...</span><br><span class="line">Done <span class="keyword">in</span> <span class="number">0.75</span>s</span><br></pre></td></tr></tbody></table></figure><p>根据不同的k值，构建PCA模型，然后调用fit_transform()函数来处理数据集，再把模型处理后数据还原率，放入explained_ratios数组。接着把这个数组画出来：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>),dpi=<span class="number">144</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.plot(candidate_components,explained_ratios)</span><br><span class="line">plt.xlabel(<span class="string">'Number of PCA Components'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'Explained Variance Ratio'</span>)</span><br><span class="line">plt.title(<span class="string">'Explained variance ratio for PCA'</span>)</span><br><span class="line">plt.yticks(np.arange(<span class="number">0.5</span>,<span class="number">1.05</span>,<span class="number">0.05</span>))</span><br><span class="line">plt.xticks(np.arange(<span class="number">0</span>,<span class="number">300</span>,<span class="number">20</span>))</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200716163203114.png" alt="image-20200716163203114"></p><p>上图中横坐标表示k值，纵坐标表示数据还原率。从图中可以看出，要保留95%以上的数据还原率，k值选择140即可。根据上图，也可以非常容易地找出不同的数据还原率所对应的k值。为了更直观地观察和对比在不同数据还原率下的数据，我们选择数据还原率分别在95%、90%、80%、70%、60%的情况下，这些数据还原率对应的k值分别是140、75、37、19、8，画出经PCA处理后的图片。</p><h3 id="4-4-最终结果"><a href="#4-4-最终结果" class="headerlink" title="4.4 最终结果"></a>4.4 最终结果</h3><p>接下来问题就变得简单了。我们选择k=140作为PCA参数，对训练数据集和测试数据集进行特征提取。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">n_components = <span class="number">140</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Fitting PCA by using training data ..."</span>)</span><br><span class="line">start = time()</span><br><span class="line">pca = PCA(n_components=n_components, svd_solver=<span class="string">'randomized'</span>, whiten=<span class="literal">True</span>).fit(X_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Done in {0:.2f}s"</span>.<span class="built_in">format</span>(time() - start))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Projecting input data for PCA ..."</span>)</span><br><span class="line">start = time()</span><br><span class="line">X_train_pca = pca.transform(X_train)</span><br><span class="line">X_test_pca = pca.transform(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Done in {0:.2f}s"</span>.<span class="built_in">format</span>(time() - start))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Fitting PCA by using training data ...</span><br><span class="line">Done <span class="keyword">in</span> <span class="number">0.08</span>s</span><br><span class="line">Projecting <span class="built_in">input</span> data <span class="keyword">for</span> PCA ...</span><br><span class="line">Done <span class="keyword">in</span> <span class="number">0.01</span>s</span><br></pre></td></tr></tbody></table></figure><p>接着使用 <code>GridSearchCV</code> 来选择一个最佳的SVC模型参数，然后使用最佳参数对模型进行训练。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Searching the best parameters for SVC ..."</span>)</span><br><span class="line">param_grid = {<span class="string">'C'</span>: [<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">50</span>, <span class="number">100</span>],</span><br><span class="line">              <span class="string">'gamma'</span>: [<span class="number">0.0001</span>, <span class="number">0.0005</span>, <span class="number">0.001</span>, <span class="number">0.005</span>, <span class="number">0.01</span>]}</span><br><span class="line">clf = GridSearchCV(SVC(kernel=<span class="string">'rbf'</span>, class_weight=<span class="string">'balanced'</span>), param_grid, verbose=<span class="number">2</span>, n_jobs=<span class="number">4</span>)</span><br><span class="line">clf = clf.fit(X_train_pca, y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Best parameters found by grid search:"</span>)</span><br><span class="line"><span class="built_in">print</span>(clf.best_params_)</span><br></pre></td></tr></tbody></table></figure><p>这一步执行时间比较长，因为GridSearchCV使用矩阵式搜索法，对每组参数组合进行一次训练，然后找出最好的参数的模型。我们通过设置n_jobs=4来启动4个线程并发执行，同时设置verbose=2来输出一些过程信息。最终选择出来的最佳模型参数如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Best parameters found by grid search:</span><br><span class="line">{<span class="string">'C'</span>: <span class="number">5</span>, <span class="string">'gamma'</span>: <span class="number">0.001</span>}</span><br></pre></td></tr></tbody></table></figure><p>接着使用这一模型对测试样本进行预测，并且使用confusion_matrix输出预测准确性信息。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">start = time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Predict test dataset ..."</span>)</span><br><span class="line">y_pred = clf.best_estimator_.predict(X_test_pca)</span><br><span class="line">cm = confusion_matrix(y_test, y_pred, labels=<span class="built_in">range</span>(n_targets))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"Done in {0:.2f}.\n"</span>.<span class="built_in">format</span>(time()-start))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"confusion matrix:"</span>)</span><br><span class="line">np.set_printoptions(threshold=np.nan)</span><br><span class="line"><span class="built_in">print</span>(cm)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Predict test dataset ...</span><br><span class="line">Done in <span class="number">0.01</span>.</span><br><span class="line"></span><br><span class="line">confusion matrix:</span><br><span class="line">[[<span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">1</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">4</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span>]</span><br><span class="line"> [<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span>]]</span><br></pre></td></tr></tbody></table></figure><p>从输出的对角线上的数据可以看出，大部分预测结果都正确。我们再使用classification_report输出分类报告，查看测准率，召回率及F1 Score。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(classification_report(y_test, y_pred))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">             precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">          <span class="number">0</span>       <span class="number">0.50</span>      <span class="number">1.00</span>      <span class="number">0.67</span>         <span class="number">1</span></span><br><span class="line">          <span class="number">1</span>       <span class="number">1.00</span>      <span class="number">0.67</span>      <span class="number">0.80</span>         <span class="number">3</span></span><br><span class="line">          <span class="number">2</span>       <span class="number">1.00</span>      <span class="number">0.50</span>      <span class="number">0.67</span>         <span class="number">2</span></span><br><span class="line">          <span class="number">3</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">1</span></span><br><span class="line">          <span class="number">4</span>       <span class="number">0.50</span>      <span class="number">1.00</span>      <span class="number">0.67</span>         <span class="number">1</span></span><br><span class="line">          <span class="number">5</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">1</span></span><br><span class="line">          <span class="number">6</span>       <span class="number">1.00</span>      <span class="number">0.75</span>      <span class="number">0.86</span>         <span class="number">4</span></span><br><span class="line">          <span class="number">7</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">          <span class="number">8</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">4</span></span><br><span class="line">          <span class="number">9</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">10</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">1</span></span><br><span class="line">         <span class="number">12</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">4</span></span><br><span class="line">         <span class="number">13</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">4</span></span><br><span class="line">         <span class="number">14</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">1</span></span><br><span class="line">         <span class="number">15</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">1</span></span><br><span class="line">         <span class="number">16</span>       <span class="number">0.75</span>      <span class="number">1.00</span>      <span class="number">0.86</span>         <span class="number">3</span></span><br><span class="line">         <span class="number">17</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">18</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">19</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">20</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">1</span></span><br><span class="line">         <span class="number">21</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">22</span>       <span class="number">0.75</span>      <span class="number">1.00</span>      <span class="number">0.86</span>         <span class="number">3</span></span><br><span class="line">         <span class="number">23</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">24</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">3</span></span><br><span class="line">         <span class="number">25</span>       <span class="number">1.00</span>      <span class="number">0.67</span>      <span class="number">0.80</span>         <span class="number">3</span></span><br><span class="line">         <span class="number">26</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">27</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">29</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">30</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">31</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">3</span></span><br><span class="line">         <span class="number">32</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">33</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">35</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">36</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">3</span></span><br><span class="line">         <span class="number">37</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">1</span></span><br><span class="line">         <span class="number">38</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line">         <span class="number">39</span>       <span class="number">1.00</span>      <span class="number">1.00</span>      <span class="number">1.00</span>         <span class="number">2</span></span><br><span class="line"></span><br><span class="line">avg / total       <span class="number">0.97</span>      <span class="number">0.95</span>      <span class="number">0.95</span>        <span class="number">80</span></span><br></pre></td></tr></tbody></table></figure><p>在总共只有400张图片，每位目标人物只有10张图片的情况下，测准率和召回率平均达到了0.95以上，这是一个非常了不起的性能。</p><h2 id="5-拓展阅读"><a href="#5-拓展阅读" class="headerlink" title="5. 拓展阅读"></a>5. 拓展阅读</h2><p>PCA算法的推导涉及大量的线性代数的知识。张洋先生的一篇博客<a href="http://blog.codinglabs.org/articles/pca-tutorial.html">《PCA的数学原理》</a>，基本上做到了从最基础的内容谈起，一步步地推导出PCA算法，值得一读。</p><p>此外，孟岩先生的几篇博客中也介绍了矩阵及其相关运算的物理含义，深入浅出，读后犹如醍醐灌顶，这些博文是<a href="https://blog.csdn.net/myan/article/details/647511">《理解矩阵》</a>三篇文章</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列七：朴素贝叶斯</title>
      <link href="/2020/07/02/scikit-learn-xi-lie-qi-po-su-bei-xie-si/"/>
      <url>/2020/07/02/scikit-learn-xi-lie-qi-po-su-bei-xie-si/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="1-朴素贝叶斯概述"><a href="#1-朴素贝叶斯概述" class="headerlink" title="1. 朴素贝叶斯概述"></a>1. 朴素贝叶斯概述</h2><p>贝叶斯分类是一类分类算法的总称，这类算法均以贝叶斯定理为基础，故统称为贝叶斯分类。朴素贝叶斯（Naive Bayers）算法是一种基于概率统计的分类方法。它在条件独立假设的基础上，使用贝叶斯定理构建算法，在文本处理领域有广泛的应用。</p><h2 id="2-贝叶斯理论-amp-条件概率"><a href="#2-贝叶斯理论-amp-条件概率" class="headerlink" title="2. 贝叶斯理论 &amp; 条件概率"></a>2. 贝叶斯理论 &amp; 条件概率</h2><h3 id="2-1-贝叶斯理论"><a href="#2-1-贝叶斯理论" class="headerlink" title="2.1 贝叶斯理论"></a>2.1 贝叶斯理论</h3><p>我们现在有一个数据集，它由两类数据组成，数据分布如下图所示: </p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE%E5%88%86%E5%B8%83.png" alt="朴素贝叶斯示例数据分布" title="参数已知的概率分布"></p><p>我们现在用 p1(x,y) 表示数据点 (x,y) 属于类别 1（图中用圆点表示的类别）的概率，用 p2(x,y) 表示数据点 (x,y) 属于类别 2（图中三角形表示的类别）的概率，那么对于一个新数据点 (x,y)，可以用下面的规则来判断它的类别: </p><ul><li>如果 p1(x,y) &gt; p2(x,y) ，那么类别为1</li><li>如果 p2(x,y) &gt; p1(x,y) ，那么类别为2</li></ul><p>也就是说，我们会选择高概率对应的类别。这就是贝叶斯决策理论的核心思想，即选择具有最高概率的决策。</p><h3 id="2-2-条件概率"><a href="#2-2-条件概率" class="headerlink" title="2.2 条件概率"></a>2.2 条件概率</h3><p>如果你对 p(x,y|c1) 符号很熟悉，那么可以跳过本小节。</p><p>有一个装了 7 块石头的罐子，其中 3 块是白色的，4 块是黑色的。如果从罐子中随机取出一块石头，那么是白色石头的可能性是多少？由于取石头有 7 种可能，其中 3 种为白色，所以取出白色石头的概率为 3/7 。那么取到黑色石头的概率又是多少呢？很显然，是 4/7 。我们使用 P(white) 来表示取到白色石头的概率，其概率值可以通过白色石头数目除以总的石头数目来得到。</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/NB_2.png" alt="包含 7 块石头的集合"></p><p>如果这 7 块石头如下图所示，放在两个桶中，那么上述概率应该如何计算？</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/NB_5.png" alt="7块石头放入两个桶中"></p><p>计算 P(white) 或者 P(black) ，如果事先我们知道石头所在桶的信息是会改变结果的。这就是所谓的条件概率（conditional probablity）。假定计算的是从 B 桶取到白色石头的概率，这个概率可以记作 P(white|bucketB) ，我们称之为“在已知石头出自 B 桶的条件下，取出白色石头的概率”。很容易得到，P(white|bucketA) 值为 2/4 ，P(white|bucketB) 的值为 1/3 。</p><p>条件概率的计算公式如下: </p><p>P(white|bucketB) = P(white and bucketB) / P(bucketB)</p><p>首先，我们用 B 桶中白色石头的个数除以两个桶中总的石头数，得到 P(white and bucketB) = 1/7 .其次，由于 B 桶中有 3 块石头，而总石头数为 7 ，于是 P(bucketB) 就等于 3/7 。于是又 P(white|bucketB) = P(white and bucketB) / P(bucketB) = (1/7) / (3/7) = 1/3 。</p><p>另外一种有效计算条件概率的方法称为贝叶斯准则。贝叶斯准则告诉我们如何交换条件概率中的条件与结果，即如果已知 P(x|c)，要求 P(c|x)，那么可以使用下面的计算方法: </p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/NB_3.png" alt="计算p(c|x)的方法"></p><h3 id="2-3-使用条件概率来分类"><a href="#2-3-使用条件概率来分类" class="headerlink" title="2.3 使用条件概率来分类"></a>2.3 使用条件概率来分类</h3><p>上面我们提到贝叶斯决策理论要求计算两个概率 p1(x, y) 和 p2(x, y):</p><ul><li>如果 p1(x, y) &gt; p2(x, y), 那么属于类别 1;</li><li>如果 p2(x, y) &gt; p1(X, y), 那么属于类别 2.</li></ul><p>这并不是贝叶斯决策理论的所有内容。使用 p1() 和 p2() 只是为了尽可能简化描述，而真正需要计算和比较的是 p(c1|x, y) 和 p(c2|x, y) .这些符号所代表的具体意义是: 给定某个由 x、y 表示的数据点，那么该数据点来自类别 c1 的概率是多少？数据点来自类别 c2 的概率又是多少？注意这些概率与概率 p(x, y|c1) 并不一样，不过可以使用贝叶斯准则来交换概率中条件与结果。具体地，应用贝叶斯准则得到: </p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/NB_4.png" alt="应用贝叶斯准则"></p><p>使用上面这些定义，可以定义贝叶斯分类准则为:</p><ul><li>如果 P(c1|x, y) &gt; P(c2|x, y), 那么属于类别 c1;</li><li>如果 P(c2|x, y) &gt; P(c1|x, y), 那么属于类别 c2.</li></ul><p>在文档分类中，整个文档（如一封电子邮件）是实例，而电子邮件中的某些元素则构成特征。我们可以观察文档中出现的词，并把每个词作为一个特征，而每个词的出现或者不出现作为该特征的值，这样得到的特征数目就会跟词汇表中的词的数目一样多。</p><p>我们假设特征之间  <strong>相互独立</strong> 。所谓 <b>独立(independence)</b> 指的是统计意义上的独立，即一个特征或者单词出现的可能性与它和其他单词相邻没有关系，比如说，“我们”中的“我”和“们”出现的概率与这两个字相邻没有任何关系。这个假设正是朴素贝叶斯分类器中 朴素(naive) 一词的含义。朴素贝叶斯分类器中的另一个假设是，<b>每个特征同等重要</b>。</p><blockquote><p><b>Note:</b> 朴素贝叶斯分类器通常有两种实现方式: 一种基于伯努利模型实现，一种基于多项式模型实现。前者中并不考虑词在文档中出现的次数，只考虑出不出现，因此在这个意义上相当于假设词是等权重的。</p></blockquote><h2 id="3-一个简单的例子"><a href="#3-一个简单的例子" class="headerlink" title="3. 一个简单的例子"></a>3. 一个简单的例子</h2><p>我们先通过一个简单的例子，来看怎样应用朴素贝叶斯分类算法。假设有以下关于驾龄、平均车速和性别的统计数据：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-28f863c2b8a241e7.png" alt="img"></p><blockquote><p>现在观察到一个驾龄为2年的人，平均车速为80。问：这个人的性别是什么？</p></blockquote><p>假设 $C_{0}$ 表示女  $C_{1}$ 表示男，$x_{0}$ 表示驾龄，$x_{1}$ 表示平均车速。我们先来计算这个人为女性的概率相对值。根据统计数据，女性司机的概率 $P\left(C_{0}\right)=5 / 10=0.5$ ，。驾龄为2年的女性司机的概率即 $P\left(x_{0} \mid C_{0}\right)=1 / 5=0.2$ 。平均车速为80的女性司机的概率  $P\left(x_{1} \mid C_{0}\right)=1 / 5=0.2$，根据朴素贝叶斯分类算法的数学公式：</p><p>$$<br>P\left(C_{0}\right) \prod_{i=1}^{n} P\left(x_{i} \mid C_{0}\right)=0.5 \times 0.2 \times 0.2=0.02<br>$$<br>接着计算这个人为男性的概率相对值。根据统计数据，不难得出男性司机的概率 $P\left(C_{1}\right)=5 / 10=0.5$ 。驾龄为2年的男性司机的概率 $P\left(x_{0} \mid C_{1}\right)=2 / 5=0.4$ 。平均车速为80的男性司机的概率 $P\left(x_{1} \mid C_{1}\right)=3 / 5=0.6$<br>$$<br>P\left(C_{1}\right) \prod_{i=1}^{n} P\left(x_{i} \mid C_{1}\right)=0.5 \times 0.4 \times 0.6=0.12<br>$$<br>从相对概率来看，这个人是男性的概率是女性的概率的6倍，据此判断这个人是男性。我们也可以从相对概率中算出绝对概率，即这个人是男性的绝对概率是0.12/(0.12+0.02)=0.857。</p><h2 id="4-概率分布"><a href="#4-概率分布" class="headerlink" title="4.概率分布"></a>4.概率分布</h2><p>到目前为止，我们介绍的朴素贝叶斯分类算法是根据数据集里的数据，计算出绝对概率来进行求解。再看一遍朴素贝叶斯分类算法的数学公式：<br>$$<br>P\left(C_{k} \mid x\right) \propto P\left(C_{k}\right) \prod_{i=1}^{n} P\left(x_{i} \mid C_{k}\right)<br>$$<br>其中， $P\left(C_{k} \mid x\right) $表示在类别$C_{k}$ 里特征$x_{i}$ 出现的概率。这里有个最大的问题，如果数据集太小，那么从数据集里计算出来的概率偏差将非常严重。例如，观察一个质地均匀的骰子投掷6次的结果是[1,3,1,5,3,3]。质地均匀的骰子每个点出现的概率都是1/6，如果根据观察到的数据集去计算每个点的概率，和真实的概率相差将是非常大的。</p><p>怎么解决这个问题呢？答案是使用概率分布来计算概率，而不是从数据集里计算概率。</p><h3 id="4-1-概率统计的基本概念"><a href="#4-1-概率统计的基本概念" class="headerlink" title="4.1 概率统计的基本概念"></a>4.1 概率统计的基本概念</h3><p>人的身高是一个连续的随机变量，而投掷一个骰子得到的点数则是一个离散的随机变量。我们闭着眼睛随便找一个人，问这个人的身高是170cm的可能性是多大呢？如果有一个函数，能描述人类身高的可能性，那么直接把170cm代入即可求出这个可能性。这个函数就是概率密度函数，也称为<code>PDF（Probability Density Function）</code>。典型的概率密度函数是高斯分布函数，如人类的身高就满足高斯分布的规律。</p><p>再例如，投掷一个质地均匀的骰子，得到6的概率是多少呢？大家都知道答案是1/6。假如有一个函数f(x)，能描述骰子出现x点数的概率，那么把x代入即可得到概率，这个函数称为概率质量函数，即PMF（Probability Mass Function）。那么，为什么还有使用概率质量函数呢？一是在数学上追求统一性，二是并不是所有的离散随机变量的概率分布都像掷一次骰子这个直观。例如，投掷6次质地均匀的骰子，得到4个4的概率是多少？这个时候如果有概率质量函数，就可以轻松求解了。</p><blockquote><p>总结一下，随机变量分成两种，一种是连续随机变量，另外一种是离散随机变量。概率密度函数描述的是连续随机变量在某个特定值的可能性，概率质量函数描述的是离散随机变量在某个特定值的可能性。而概率分布则是描述随机变量取值的概率规律。</p></blockquote><h3 id="4-2-多项式分布"><a href="#4-2-多项式分布" class="headerlink" title="4.2 多项式分布"></a>4.2 多项式分布</h3><p> 抛一枚硬币，要么出现正面，要么出现反面（假设硬币不会立起来）。假如出现正面的概率是p，则出现反面的概率就是1-p。符合这个规律的概率分布，称为 <code>伯努利分布（Bernoulli Distribution）</code>。其概率质量函数为：<br>$$<br>f(k ; p)=p^{k}(1-p)^{1-k}<br>$$<br>p是出现1的概率。例如，一枚质地均匀的硬币被抛一次，得到正面的概率为0.5。我们代入上述公式，也可以得到相同的结果，即f(1;0.5)=0.5。</p><p>更一般的情况，即不止两种可能性时，假设每种可能性是$p_{i}$, 则满足  $\sum_{i}^{n} p_{i}=1$， 条件的概率分布，称为<code>类别分布（Categorical Distribution）</code>。例如，投掷一枚骰子，则会出现6中可能性，所有的可能性加起来的概率为1。类别分布的概率质量函数为：<br>$$<br>f(x \mid p)=\prod_{i=1}^{k} p_{i}^{x_{i}}<br>$$<br>那么，一枚质地均匀的硬币被抛10次，出现3次正面的概率是多少呢？这是个典型的二项式分布问题。二项式分布指的是把符号伯努利分布的实验做了n次，结果1出现0次、1次、2次……n次的概率分别是多少，它的概率质量函数为：<br>$$<br>f(k ; n, p)=C_{n}^{k} p^{k}(1-p)^{n-k}<br>$$<br>枚质地均匀的硬币被抛10次，出现3次正面的概率是多少？代入二项式分布的概率质量函数，得到：<br>$$<br>f(3 ; 10,0.5)=\frac{10 !}{3 ! \times(10-3) !} \times 0.5^{3} \times(1-0.5)^{10-3}=0.1171875<br>$$<br>其中，0的阶乘为1，即0!=1。结果跟我们预期的相符。当实验只做一次时，二项式分布退化为伯努利分布。</p><p>简单总结一下，二项式分布描述的是多次伯努利实验中，某个结果出现次数的概率。多项式分布描述的是多次进行满足类别分布的实验中，所有类别出现的次数组合的分布。</p><p>二项式分布和多项式分布结合朴素贝叶斯算法，经常被用来实现文章分类算法。例如，有一个论坛需要对用户的评论进行过滤，屏蔽不文明的评论。首先要有一个经过标记的数据集，我们称为语料库。假设使用人工标记的方法对评论进行标记，1表示不文明的评论，0表示正常评论。</p><p>假设我们的词库大小为 k ，则评论中出现某个词可以看成是一次满足k个类别的类别分布实验。我们知道，一篇评论是由n个词组成的，因此一篇评论可以看出是进行n次类别分布实验后的产物。由此得知，一篇评论服从多项式分布，它是词库里的所有词语出现的次数组合构成的随机向量。</p><p>一般情况下，词库比较大，评论只是由少量词组成，所以这个随机向量是很稀疏的，即大部分元素为0。通过分析预料库，我们容易统计出每个词出现在不文明评论及正常评论的概率，即 $p_{i}$的值。同时针对待预测的评论，我们可以统计词库里的所有词在这篇评论里出现的次数即  $x_{i}$ 的值，及评论的词语个数。代入多项式分布的概率质量函数：<br>$$<br>f(X, n, P)=\frac{n !}{\prod_{i=1}^{k} x_{i} !} \prod_{i=1}^{k} p_{i}^{x_{i}}<br>$$<br>我们可以求出，待预测评论构成的随机向量x，其为不文明评论的相对概率。同理也可以求出其为正常评论的相对概率。通过比较两个相对概率，就可以对这篇评论输出一个预测值。当然，实际应用中，涉及大量的自然语言处理的手段，包括中文分词技术、词的数学表示等，这里不再展开。</p><h3 id="4-3-高斯分布"><a href="#4-3-高斯分布" class="headerlink" title="4.3 高斯分布"></a>4.3 高斯分布</h3><p>在前面的车速和性别预测的例子里，对于平均车速，给出的是离散值，实际上它是一个连续值。这个时候怎么使用贝叶斯算法来处理呢？答案是，可以用区间把连续值转换成离散值。例如，我们可以把平均车速[0,40]作为一个级别，[40-80]，等等。这样就可以把连续值变成离散值，从而使用贝叶斯算法进行处理。另外一个方法，是使用连续随机变量的概率密度函数，把数值转换为一个相对概率。高斯分布就是这样一种方法。</p><p><code>高斯分布（Gaussian Distribution）</code>也称为 <code>正态分布（Normal Distribution）</code>，是最常见的一种分布。例如人的身高满足高斯分布，特别高和特别矮的人出现的相对概率都很低，大部分人身高都处在中间水平。还有人的智商也符合高斯分布，特别聪明的天才和特别笨的人出现的相对概率都很低，大部分人的智力都差不多。高斯分布的概率密度函数为：<br>$$<br>f(x)=\frac{1}{\sqrt{2 \pi \sigma^{2}}} \exp \left(-\frac{(x-\mu)^{2}}{2 \sigma^{2}}\right)<br>$$<br>其中，$x$ 为随机变量的值，$f(x)$ 为随机变量的相对概率，$\mu$为样本的平均值，其决定了高斯分布曲线的位置，<img src="https://math.jianshu.com/math?formula=%5Csigma" alt="\sigma">为标准差，其决定了高斯分布的幅度，$\sigma$ 值越大，分布越分散，<img src="https://math.jianshu.com/math?formula=%5Csigma" alt="\sigma">$\sigma$值越小，分布越集中。典型的高斯分布如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-e4f8952fc25052e3.png" alt="img"></p><p>这里需要注意的是：高斯分布的概率密度函数和支持向量机里的高斯核函数的区别。二者的核心数学模型是相同的，但是目的不同。</p><h3 id="4-4-连续值得处理"><a href="#4-4-连续值得处理" class="headerlink" title="4.4 连续值得处理"></a>4.4 连续值得处理</h3><p>假设，有一组身体特征的统计数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-ab2a72e2cf69b3f1.png" alt="img"></p><p>假设某人身高6英尺，体重130榜，脚掌8英寸，请问此人的性别是什么？</p><p>根据朴素贝叶斯公式：<br>$$<br>P\left(C_{k} \mid x\right) \propto P\left(C_{k}\right) \prod_{i=1}^{n} P\left(x_{i} \mid C_{k}\right)<br>$$<br>针对待预测的这个人的数据$x$ ，我们只需要分别求出男性和女性的相对概率<br>$$<br>P(\text {Gender}) \times P(\text {Height} \mid \text {Gender}) \times P(\text {Weight} \mid \text {Gender}) \times P(\text {Feet} \mid \text {Gender})<br>$$<br>然后取相对概率较高的性别为预测值即可。这里的困难在于，所有的特征都是连续变量，无法根据统计数据计算概率。当然，这里我们可以使用区间法，把连续变量变为离散变量，然后再计算概率。但由于数据量较小，这显然不是一个好办法。由于人类身高、体重、脚掌尺寸满足高斯分布，因此更好的办法是使用高斯分布的概率密度函数来求相对概率。</p><p>首先，针对男性和女性，分别求出特征的平均值和方差：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-4755f7b16509dc1d.png" alt="img"></p><p>接着利用高斯分布的概率密度函数，来求解男性身高为6英尺的相对概率：<br>$$<br>P(\text {Height}=6 \mid \text {Male})=\frac{1}{\sqrt{2 \pi \times 0.035033^{2}}} \exp \left(-\frac{(6-5.855)^{2}}{2 \times 0.035033^{2}}\right) \approx 1.5789<br>$$<br>这里的关键是把连续值（身高）作为输入，通过高斯分布的概率密度函数的处理，直接转换为相对概率。注意这里是相对概率，所以其值大于1并未违反概率论规则。</p><h2 id="5-示例：文档分类"><a href="#5-示例：文档分类" class="headerlink" title="5. 示例：文档分类"></a>5. 示例：文档分类</h2><p>在 <code>scikit-learn</code>里，朴素贝叶斯算法在 <code>sklearn.naive_bayes</code> 包里实现，包含本文介绍的几种典型的概率分布算法。其中 <code>GaussianNB</code> 实现了高斯分布的朴素贝叶斯算法，<code>MultinomialNB</code> 实现了多项式分布的朴素贝叶斯算法，<code>BernoulliNB</code>实现了伯努利分布的朴素贝叶斯算法。朴素贝叶斯算法在自然语言处理领域有着广泛的应用，这里我们使用 <code>MultinomialNB</code> 来实现文档的自动分类。</p><h3 id="5-1-获取数据集"><a href="#5-1-获取数据集" class="headerlink" title="5.1 获取数据集"></a>5.1 获取数据集</h3><p>这里使用的数据集来自 mlcomp.org上的20news-18828，可以直接访问<a href="https://links.jianshu.com/go?to=http%3A%2F%2Fmlcomp.org%2Fdatasets%2F379">http://mlcomp.org/datasets/379</a>下载。其目录下包含3个子目录和一个名为metadata的介绍文件，数据集也可在百度网盘下载。，已分享。</p><blockquote><p>链接：<a href="https://pan.baidu.com/s/1uQNkLWIN0niz8-p8BppRJg">https://pan.baidu.com/s/1uQNkLWIN0niz8-p8BppRJg</a><br>提取码：bvhe<br>复制这段内容后打开百度网盘手机App，操作更方便哦</p></blockquote><p>我们将使用 <code>train</code> 子目录下的文档进行模型训练，然后使用 <code>test</code> 子目录下的文档进行模型测试。<code>train</code> 子目录下包含 20 个子目录，每个子目录代表一种文档的类型，子目录下的所有文档都是属于目录名称所标识的文档类型。可以随意浏览数据集，以便对数据集有一个感性的认识。例如，datasets/mlcomp/379/train/rec.autos/6652-103421是一个讨论汽车主题的帖子：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Hahahahahaha. gasp pant Hm, I’m not sure whether the above was just a silly </span><br><span class="line">    remark or a serious remark. But <span class="keyword">in</span> case there are some misconceptions,</span><br><span class="line">I think Henry Robertson hasn’t updated his <span class="keyword">data</span> file on Korea since…mid 1970s. </span><br><span class="line">Owning a car <span class="keyword">in</span> Korea <span class="keyword">is</span> no longer a luxury. Most middle <span class="class"><span class="keyword">class</span> <span class="title">people</span> </span></span><br><span class="line"><span class="keyword">in</span> Korea can afford a car and <span class="keyword">do</span> have at least one car. The problem <span class="keyword">in</span> Korea,</span><br><span class="line">especially <span class="keyword">in</span> Seoul, <span class="keyword">is</span> that there are just so many privately-owned cars,</span><br><span class="line"><span class="keyword">as</span> well <span class="keyword">as</span> taxis and buses, the rush-hour has become a <span class="number">24</span> hour phenomenon </span><br><span class="line">    and that there <span class="keyword">is</span> no place to park. Last time I heard, back <span class="keyword">in</span> January, </span><br><span class="line">the Kim Administration wanted to legislate a law requireing a potential </span><br><span class="line">car owner to provide his or her own parking area, just like they <span class="keyword">do</span> <span class="keyword">in</span> Japan.</span><br><span class="line">Also, Henry would be glad to know that Hyundai isn’t the only car manufacturer </span><br><span class="line"><span class="keyword">in</span> Korea. Daewoo has always manufactured cars and I believe Kia <span class="keyword">is</span> back <span class="keyword">in</span> </span><br><span class="line">business <span class="keyword">as</span> well. Imported cars, such <span class="keyword">as</span> Mercury Sable are becoming quite </span><br><span class="line">popular <span class="keyword">as</span> well, though they are still quite expensive.</span><br><span class="line">Finally, please ignore Henry’s posting about Korean politics and bureaucracy. </span><br><span class="line">    He’s quite uninformed.</span><br></pre></td></tr></tbody></table></figure><h3 id="5-2-文档的数学表达"><a href="#5-2-文档的数学表达" class="headerlink" title="5.2 文档的数学表达"></a>5.2 文档的数学表达</h3><p>怎样把一个文档表达为计算机可以理解并处理的信息，是自然语言处理中的一个重要课题，完整内容可以写成鸿篇巨著。本节简单介绍TF-IDF的原理，以便更好地理解本文介绍的实例。</p><p><code>TF-IDF</code> 是一种统计方法，用以评估一个词语对于一份文档的重要程度。<code>TF（Term Frequency）</code>表示词频，对于一份文档而言，词频是指特定词语在这篇文档里出现的次数除以该文档总词数。例如，一篇文档一共有1000个词，其中“朴素贝叶斯”出现了5次，“的”出现了25次，“应用”出现了12次，那么它们的词频分别是0.005，0.025和0.012。</p><p><code>IDF（Inverse Document Frequency）</code>表示一个词的逆向文档频率，由总文档数除以包含该词的文档数的商再取对数得到。例如：我们的数据集一共10000篇文档，其中“朴素贝叶斯”只出现在10篇文档中，则其<code>IDF=log(10000/10)=3</code>；“的”在所有文档中都出现过，则其 <code>IDF=log(10000/10000)=0</code>；“应用”在1000篇文档中出现过，则其 <code>IDF=log(10000/1000)=1</code>。</p><p>计算出每个词的TF和IDF之后，两者相乘，即可得到这个词在文档中的重要程度。词语的重要性与它在该文档中出现的次数成正比，与它在语料库中出现的文档数成反比。</p><p>有了TF-IDF这个工具，我们就可以把一篇文档转换为一个向量。首先，可以从数据集<code>（在自然语言处理领域也称corpus，即语料库）</code>里提取出所有出现的词，我们称为词典。假设词典里总共有10000个词语，则每个文档都可以转化为一个10000维的向量。其次，针对我们要转换的文档里出现的每个词语，都去计算其TF-IDF，并把这个值填入文档向量里这个词对应的元素上。这样就完成了把一篇文档转换为一个向量的过程。一个文档往往只会由词典里的一小部分词语构成，这就意味着这个向量里的大部分元素都是0。</p><p>所幸，上述过程不需要我们自己写代码去完成，<code>scikit-learn</code> 软件包里实现了把文档转换为向量的过程。首先，把训练用的语料库读入内存：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_files</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"loading train dataset ..."</span>)</span><br><span class="line">t = time()</span><br><span class="line">news_train = load_files(<span class="string">'datasets/mlcomp/379/train'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"summary: {0} documents in {1} categories."</span></span><br><span class="line">      .<span class="built_in">format</span>(<span class="built_in">len</span>(news_train.data),<span class="built_in">len</span>(news_train.target_names)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done in {0} seconds"</span>.<span class="built_in">format</span>(time()-t))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loading train dataset ...</span><br><span class="line">summary: 13180 documents <span class="keyword">in</span> 20 categories.</span><br><span class="line"><span class="keyword">done</span> <span class="keyword">in</span> 1.2616519927978516 seconds</span><br></pre></td></tr></tbody></table></figure><p>其中，<code>datasets/mlcomp/379/train</code>目录下放的就是我们的语料库，其中包含20个子目录，每个子目录的名字表示的是文档的类别，子目录下包含这种类别的所有文档。<code>load_files()</code> 函数会从这个目录里把所有的文档都读入内存，并且自动根据所在的子目录名称打上标签。其中，<code>news_train.data</code>是一个数组，里面包含了所有文档的文本信息。<code>news_train.target</code>也是一个数组，包含了所有文档所属的类别，而<code>news_train.target_names</code>则是类别的名称，因此，如果我们想知道第一篇文档所属的类别名称，只需要通过代码<code>news_train.target_names[news_train.target[0]]</code>即可得到。</p><p>该语料库里总共有13180个文档，分成20个类别。接着需要把这些文档全部转换为由TF-IDF表达的权重信息构成的向量：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"vectorizing train dataset ..."</span>)</span><br><span class="line">t = time()</span><br><span class="line">vectorizer = TfidfVectorizer(encoding=<span class="string">'latin-1'</span>)</span><br><span class="line">X_train = vectorizer.fit_transform((d <span class="keyword">for</span> d <span class="keyword">in</span> news_train.data))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"n_samples: %d, n_features: %d"</span> % X_train.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"number of non-zero features in samples [{0}]:{1}"</span></span><br><span class="line">      .<span class="built_in">format</span>(news_train.filenames[<span class="number">0</span>],X_train[<span class="number">0</span>].getnnz()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done in {0} seconds"</span>.<span class="built_in">format</span>(time()-t))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vectorizing train dataset ...</span><br><span class="line">n_samples: <span class="number">13180</span>, n_features: <span class="number">130274</span></span><br><span class="line">number of non-zero features in samples [datasets/mlcomp/<span class="number">379</span>/train\talk.politics.misc\<span class="number">17860</span>-<span class="number">178992</span>]:<span class="number">108</span></span><br><span class="line">done in <span class="number">2.6174726486206055</span> seconds</span><br></pre></td></tr></tbody></table></figure><p>其中，<code>TfidfVectorizer</code>类是用来把所有的文档转换为矩阵，该矩阵每行都代表一个文档，一行中的每个元素代表一个对应的词语的重要性，词语的重要性由<code>TF-IDF</code>来表示。其 <code>fit_transform()</code> 方法是 fit() 和transform()合并起来。其中，fit()  会先完成语料库分析、提取词典等操作，transform()会把对每篇文档转换为向量，最终构成一个矩阵，保存在X_train变量里。</p><p>由输出可以知道，我们的词典总共有 130274 个词语，即每篇文档都可转换为一个 130274 维的向量。第一篇文档中，只有108个非零元素，即这篇文档总共由108个不重复的单词组成，在这篇文档中出现的这108个单词的TF-IDF值会被计算出来，并保存在向量中的指定位置上。X_train是一个维度为13180*130274的稀疏矩阵。</p><p>X_train稀疏矩阵由一个三元组(row,col,score)构成：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(X_train[0])</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0</span>, <span class="number">56813</span>)    <span class="number">0.014332663773643272</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">45689</span>)    <span class="number">0.08373343949755</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">46084</span>)    <span class="number">0.08109733529789522</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">125882</span>)   <span class="number">0.0873157704840211</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">50150</span>)    <span class="number">0.020654313721609956</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">87702</span>)    <span class="number">0.04643235585055511</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">33334</span>)    <span class="number">0.1025405658189532</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">111805</span>)   <span class="number">0.014332663773643272</span></span><br><span class="line">: :</span><br><span class="line">(<span class="number">0</span>, <span class="number">67768</span>)    <span class="number">0.08982314745972582</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">41790</span>)    <span class="number">0.09260592033433869</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">105800</span>)   <span class="number">0.08713990737243116</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">37075</span>)    <span class="number">0.10018566542781165</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">23162</span>)    <span class="number">0.08920437523600384</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">124699</span>)   <span class="number">0.06257976758779137</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">94119</span>)    <span class="number">0.1159317059788844</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">56555</span>)    <span class="number">0.06984885482106491</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">62776</span>)    <span class="number">0.10474995568339582</span></span><br></pre></td></tr></tbody></table></figure><h3 id="5-3-模型训练"><a href="#5-3-模型训练" class="headerlink" title="5.3 模型训练"></a>5.3 模型训练</h3><p>使用 <code>MultinomialNB</code> 对数据集进行训练：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.naive_bayes <span class="keyword">import</span> MultinomialNB</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"training models ..."</span>)</span><br><span class="line">t = time()</span><br><span class="line">y_train = news_train.target</span><br><span class="line">clf = MultinomialNB(alpha=<span class="number">0.0001</span>)</span><br><span class="line">clf.fit(X_train,y_train)</span><br><span class="line">train_score = clf.score(X_train,y_train)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"train score: {0}"</span>.<span class="built_in">format</span>(train_score))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done in {0} seconds"</span>.<span class="built_in">format</span>(time()-t))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">training models ...</span><br><span class="line">train score: <span class="number">0.9978755690440061</span></span><br><span class="line">done in <span class="number">0.15497064590454102</span> seconds</span><br></pre></td></tr></tbody></table></figure><p>其中，alpha表示平滑参数，其值越小，越容易造成过拟合，值太大，容易造成欠拟合。</p><p>接着，我们加载测试数据集，并用一篇文档来预测其是否准确。测试数据集在<code>datasets/mlcomp/379/test</code>目录下，我们用前面介绍的相同的方法先加载数据集：</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"loading test dataset ..."</span>)</span><br><span class="line">t = time()</span><br><span class="line">news_test = load_files(<span class="string">'datasets/mlcomp/379/test'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"summary: {0} documents in {1} categories."</span></span><br><span class="line">      .format(<span class="built_in">len</span>(news_test.data),<span class="built_in">len</span>(news_test.target_names)))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done in {0} seconds"</span>.format(time()-t))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loading <span class="built_in">test</span> dataset ...</span><br><span class="line">summary: 5648 documents <span class="keyword">in</span> 20 categories.</span><br><span class="line"><span class="keyword">done</span> <span class="keyword">in</span> 0.3548290729522705 seconds</span><br></pre></td></tr></tbody></table></figure><p>测试数据集共有5648篇文档。接着，我们把文档向量化：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"vectorizing test dataset ..."</span>)</span><br><span class="line">t = time()</span><br><span class="line">X_test = vectorizer.transform((d <span class="keyword">for</span> d <span class="keyword">in</span> news_test.data))</span><br><span class="line">y_test = news_test.target</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"n_samples: %d, n_features: %d"</span> % X_test.shape)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"number of non-zero features in sample [{0}]: {1}"</span></span><br><span class="line">      .format(news_test.filenames[0],X_test[0].getnnz()))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done in {0} seconds"</span>.format(time()-t))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vectorizing <span class="built_in">test</span> dataset ...</span><br><span class="line">n_samples: 5648, n_features: 130274</span><br><span class="line">number of non-zero features <span class="keyword">in</span> sample [datasets/mlcomp/379/<span class="built_in">test</span>\rec.autos\7429-103268]: 61</span><br><span class="line"><span class="keyword">done</span> <span class="keyword">in</span> 0.9695498943328857 seconds</span><br></pre></td></tr></tbody></table></figure><p>注意，vectorizer变量是我们处理训练数据集时用到的向量化的类的实例，此处我们只需要调用transform()进行TF-IDF数值计算即可，不需要再调用fit()进行语料库分析了。</p><p>这样，我们的测试数据集也转换为了一个维度为5648*130274的稀疏矩阵。可以取测试数据集里的第一篇文档初步验证一下，看看训练出来的模型能否正确地预测这个文档所属的类别：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pred = clf.predict(X_test[0])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"predict: {0} is in category {1}"</span></span><br><span class="line">      .format(news_test.filenames[0],news_test.target_names[pred[0]]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"actually: {0} is in category {1}"</span></span><br><span class="line">      .format(news_test.filenames[0],news_test.target_names[news_test.target[0]]))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">predict: datasets/mlcomp/379/<span class="built_in">test</span>\rec.autos\7429-103268 is <span class="keyword">in</span> category rec.autos</span><br><span class="line">actually: datasets/mlcomp/379/<span class="built_in">test</span>\rec.autos\7429-103268 is <span class="keyword">in</span> category rec.autos</span><br></pre></td></tr></tbody></table></figure><p>看来预测的结果和实际结果是相符的。</p><h3 id="5-4-模型评价"><a href="#5-4-模型评价" class="headerlink" title="5.4 模型评价"></a>5.4 模型评价</h3><p>虽然通过验证，说明我们训练的模型是可用的，但是不能通过一个样本的预测来评价模型的准确性。我们需要对模型有个全方位的评价，所幸 <code>scikit-learn</code> 软件包提供了全方位的模型评价工具。</p><p>首先需要对测试数据集进行预测：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">"predicting test dataset ..."</span>)</span><br><span class="line">t = time()</span><br><span class="line">pred_test = clf.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"done in %fs"</span> % (time()-t))</span><br></pre></td></tr></tbody></table></figure><p>接着使用 <code>classification_report()</code> 函数来查看一下针对每个类别的预测准确性：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> classification_report</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"classification report on test set for classifier:"</span>)</span><br><span class="line"><span class="built_in">print</span>(clf)</span><br><span class="line"><span class="built_in">print</span>(classification_report(y_test,pred_test,target_names=news_test.target_names))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">classification report on <span class="built_in">test</span> <span class="built_in">set</span> <span class="keyword">for</span> classifier:</span><br><span class="line">MultinomialNB(alpha=0.0001, class_prior=None, fit_prior=True)</span><br><span class="line">                          precision    recall  f1-score   support</span><br><span class="line"></span><br><span class="line">             alt.atheism       0.90      0.91      0.91       245</span><br><span class="line">           comp.graphics       0.80      0.90      0.85       298</span><br><span class="line"> comp.os.ms-windows.misc       0.82      0.79      0.80       292</span><br><span class="line">comp.sys.ibm.pc.hardware       0.81      0.80      0.81       301</span><br><span class="line">   comp.sys.mac.hardware       0.90      0.91      0.91       256</span><br><span class="line">          comp.windows.x       0.88      0.88      0.88       297</span><br><span class="line">            misc.forsale       0.87      0.81      0.84       290</span><br><span class="line">               rec.autos       0.92      0.93      0.92       324</span><br><span class="line">         rec.motorcycles       0.96      0.96      0.96       294</span><br><span class="line">      rec.sport.baseball       0.97      0.94      0.96       315</span><br><span class="line">        rec.sport.hockey       0.96      0.99      0.98       302</span><br><span class="line">               sci.crypt       0.95      0.96      0.95       297</span><br><span class="line">         sci.electronics       0.91      0.85      0.88       313</span><br><span class="line">                 sci.med       0.96      0.96      0.96       277</span><br><span class="line">               sci.space       0.94      0.97      0.96       305</span><br><span class="line">  soc.religion.christian       0.93      0.96      0.94       293</span><br><span class="line">      talk.politics.guns       0.91      0.96      0.93       246</span><br><span class="line">   talk.politics.mideast       0.96      0.98      0.97       296</span><br><span class="line">      talk.politics.misc       0.90      0.90      0.90       236</span><br><span class="line">      talk.religion.misc       0.89      0.78      0.83       171</span><br><span class="line"></span><br><span class="line">             avg / total       0.91      0.91      0.91      5648</span><br></pre></td></tr></tbody></table></figure><p>从输出结果中可以看出，针对每种类别都统计了<code>查准率</code>、<code>召回率</code>和<code>F1-Score</code>。此外，还可以通过confusion_matrix()函数生成混淆矩阵，观察每种类别被错误分类的情况。例如，这些被错误分类的文档是被错误分类到哪些类别里的：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> confusion_matrix</span><br><span class="line">cm = confusion_matrix(y_test,pred_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"confusion matrix:\n"</span>)</span><br><span class="line"><span class="built_in">print</span>(cm)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">confusion matrix:</span><br><span class="line"></span><br><span class="line">[<span class="meta">[224   0   0   0   0   0   0   0   0   0   0   0   0   0   2   5   0   0    1  13</span>]</span><br><span class="line"> [<span class="meta">  1 267   5   5   2   8   1   1   0   0   0   2   3   2   1   0   0   0    0   0</span>]</span><br><span class="line"> [<span class="meta">  1  13 230  24   4  10   5   0   0   0   0   1   2   1   0   0   0   0    1   0</span>]</span><br><span class="line"> [<span class="meta">  0   9  21 242   7   2  10   1   0   0   1   1   7   0   0   0   0   0    0   0</span>]</span><br><span class="line"> [<span class="meta">  0   1   5   5 233   2   2   2   1   0   0   3   1   0   1   0   0   0    0   0</span>]</span><br><span class="line"> [<span class="meta">  0  20   6   3   1 260   0   0   0   2   0   1   0   0   2   0   2   0    0   0</span>]</span><br><span class="line"> [<span class="meta">  0   2   5  12   3   1 235  10   2   3   1   0   7   0   2   0   2   1    4   0</span>]</span><br><span class="line"> [<span class="meta">  0   1   0   0   1   0   8 300   4   1   0   0   1   2   3   0   2   0    1   0</span>]</span><br><span class="line"> [<span class="meta">  0   1   0   0   0   2   2   3 283   0   0   0   1   0   0   0   0   0    1   1</span>]</span><br><span class="line"> [<span class="meta">  0   1   1   0   1   2   1   2   0 297   8   1   0   1   0   0   0   0    0   0</span>]</span><br><span class="line"> [<span class="meta">  0   0   0   0   0   0   0   0   2   2 298   0   0   0   0   0   0   0    0   0</span>]</span><br><span class="line"> [<span class="meta">  0   1   2   0   0   1   1   0   0   0   0 284   2   1   0   0   2   1    2   0</span>]</span><br><span class="line"> [<span class="meta">  0  11   3   5   4   2   4   5   1   1   0   4 266   1   4   0   1   0    1   0</span>]</span><br><span class="line"> [<span class="meta">  1   1   0   1   0   2   1   0   0   0   0   0   1 266   2   1   0   0    1   0</span>]</span><br><span class="line"> [<span class="meta">  0   3   0   0   1   1   0   0   0   0   0   1   0   1 296   0   1   0    1   0</span>]</span><br><span class="line"> [<span class="meta">  3   1   0   1   0   0   0   0   0   0   1   0   0   2   1 280   0   1    1   2</span>]</span><br><span class="line"> [<span class="meta">  1   0   2   0   0   0   0   0   1   0   0   0   0   0   0   0 236   1    4   1</span>]</span><br><span class="line"> [<span class="meta">  1   0   0   0   0   1   0   0   0   0   0   0   0   0   0   3   0 290    1   0</span>]</span><br><span class="line"> [<span class="meta">  2   1   0   0   1   1   0   1   0   0   0   0   0   0   0   1  10   7  212   0</span>]</span><br><span class="line"> [<span class="meta"> 16   0   0   0   0   0   0   0   0   0   0   0   0   0   0  12   4   1    4 134</span>]]</span><br></pre></td></tr></tbody></table></figure><p>例如：从第一行可以看出，类别0（alt.atheism）的文档，有13个被错误地分类到类别19（talk.religion.misc）里。当然，我们还可以把混淆矩阵进行数据可视化：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show confusion matrix</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">8</span>),dpi=<span class="number">144</span>)</span><br><span class="line">plt.title(<span class="string">'Confusion matrix of the classifier'</span>)</span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">'right'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'top'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'bottom'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.spines[<span class="string">'left'</span>].set_color(<span class="string">'none'</span>)</span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">'none'</span>)</span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">'none'</span>)</span><br><span class="line">ax.set_xticklabels([])</span><br><span class="line">ax.set_yticklabels([])</span><br><span class="line">plt.matshow(cm,fignum=<span class="number">1</span>,cmap=<span class="string">'gray'</span>)</span><br><span class="line">plt.colorbar()</span><br></pre></td></tr></tbody></table></figure><p>输出图形如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200702160731221.png" alt="image-20200702160731221">除对角线外，其他地方颜色越浅，说明此处错误越多。通过这些数据，我们可以详细分析样本数据，找出为什么某种类别会被错误地分类到另一种类别里，从而进一步优化模型。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列六：SVM</title>
      <link href="/2020/07/01/scikit-learn-xi-lie-liu-svm/"/>
      <url>/2020/07/01/scikit-learn-xi-lie-liu-svm/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="1-SVM概述"><a href="#1-SVM概述" class="headerlink" title="1. SVM概述"></a>1. SVM概述</h2><p>支持向量机(Support Vector Machines, SVM): 是一种监督学习算法。在工业界和学术界都有广泛的应用。特别是针对数据集较小的情况下，往往其分类效果比神经网络好。</p><ul><li>支持向量(Support Vector) 就是离分隔超平面最近的那些点。</li><li>机(Machine) 就是表示一种算法，而不是表示机器。</li></ul><h2 id="2-SVM原理"><a href="#2-SVM原理" class="headerlink" title="2. SVM原理"></a>2. SVM原理</h2><p>SVM的原理就是使用分隔超平面来划分数据集，并使得支持向量（数据集中离分隔超平面最近的点）到该分隔超平面的距离最大。其最大特点是能构造出最大间距的决策边界，从而提高分类算法的鲁棒性。</p><p>要给左右两边的点进行分类，明显发现: 选择D会比B、C分隔的效果要好很多。</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/SVM_3_linearly-separable.jpg" alt="线性可分"></p><h3 id="2-1-寻找最大间隔"><a href="#2-1-寻找最大间隔" class="headerlink" title="2.1 寻找最大间隔"></a>2.1 寻找最大间隔</h3><h4 id="点到超平面的距离"><a href="#点到超平面的距离" class="headerlink" title="点到超平面的距离"></a>点到超平面的距离</h4><ul><li><p>分隔超平面<code>函数间距</code>:  $y(x)=w^Tx+b$</p></li><li><p>分类的结果:  $f(x)=sign(w^Tx+b)$   (sign表示&gt;0为1，&lt;0为-1，=0为0) </p></li><li><p>点到超平面的<code>几何间距</code>: $d(x)=(w^Tx+b)/||w||$  （$||w||$表示w矩阵的二范数=&gt; $\sqrt{w^T*w}$, 点到超平面的距离也是类似的）</p></li></ul><p>$$<br>d=\left|\frac{A x_{0}+B y_{0}+C}{\sqrt{A^{2}+B^{2}}}\right|<br>$$</p><h4 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h4><ul><li>类别标签用-1、1，是为了后期方便 $ label<em>(w^Tx+b)$ 的标识和距离计算；如果 $label</em>(w^Tx+b)&gt;0$ 表示预测正确，否则预测错误。</li><li>现在目标很明确，就是要找到<code>w</code>和<code>b</code>，因此我们必须要找到最小间隔的数据点，也就是前面所说的<code>支持向量</code>。<ul><li>也就说，让最小的距离取最大.(最小的距离: 就是最小间隔的数据点；最大: 就是最大间距，为了找出最优超平面–最终就是支持向量)</li><li>目标函数: $arg: max_{关于w, b} \left( min[label<em>(w^Tx+b)]</em>\frac{1}{||w||} \right) $<ol><li>如果 $label*(w^Tx+b)&gt;0$ 表示预测正确，也称<code>函数间隔</code>，$||w||$ 可以理解为归一化，也称<code>几何间隔</code>。</li><li>令 $label<em>(w^Tx+b)&gt;=1$， 因为0～1之间，得到的点是存在误判的可能性，所以要保障 $min[label</em>(w^Tx+b)]=1$，才能更好降低噪音数据影响。</li><li>所以本质上是求 $arg: max_{关于w, b}  \frac{1}{||w||} $；也就说，我们约束(前提)条件是: $label*(w^Tx+b)=1$</li></ol></li></ul></li><li>新的目标函数求解:  $arg: max_{关于w, b}  \frac{1}{||w||} $<ul><li>=&gt; 就是求: $arg: min_{关于w, b} ||w|| $ (求矩阵会比较麻烦，如果x只是 $\frac{1}{2}*x^2$ 的偏导数，那么。。同样是求最小值)</li><li>=&gt; 就是求: $arg: min_{关于w, b} (\frac{1}{2}*||w||^2)$ (二次函数求导，求极值，平方也方便计算)</li><li>本质上就是求线性不等式的二次优化问题(求分隔超平面，等价于求解相应的凸二次规划问题)</li></ul></li><li>通过拉格朗日乘子法，求二次优化问题<ul><li>假设需要求极值的目标函数 (objective function) 为 f(x,y)，限制条件为 φ(x,y)=M  # M=1</li><li>设g(x,y)=M-φ(x,y)   # 临时φ(x,y)表示下文中 $label*(w^Tx+b)$</li><li>定义一个新函数: F(x,y,λ)=f(x,y)+λg(x,y)</li><li>a为λ（a&gt;=0），代表要引入的拉格朗日乘子(Lagrange multiplier)</li><li>那么:  $L(w,b,\alpha)=\frac{1}{2} * ||w||^2 + \sum_{i=1}^{n} \alpha_i * [1 - label * (w^Tx+b)]$</li><li>因为: $label<em>(w^Tx+b)&gt;=1, \alpha&gt;=0$ , 所以 $\alpha</em>[1-label<em>(w^Tx+b)]&lt;=0$ , $\sum_{i=1}^{n} \alpha_i * [1-label</em>(w^Tx+b)]&lt;=0$ </li><li>当 $label*(w^Tx+b)&gt;1$ 则 $\alpha=0$ ，表示该点为<font color="red">非支持向量</font></li><li>相当于求解:  $max_{关于\alpha} L(w,b,\alpha) = \frac{1}{2} *||w||^2$ </li><li>如果求:  $min_{关于w, b} \frac{1}{2} *||w||^2$ , 也就是要求:  $min_{关于w, b} \left( max_{关于\alpha} L(w,b,\alpha)\right)$ </li></ul></li><li>现在转化到对偶问题的求解<ul><li>$min_{关于w, b} \left(max_{关于\alpha} L(w,b,\alpha) \right) $ &gt;= $max_{关于\alpha} \left(min_{关于w, b}\ L(w,b,\alpha) \right) $ </li><li>现在分2步</li><li>先求:  $min_{关于w, b} L(w,b,\alpha)=\frac{1}{2} * ||w||^2 + \sum_{i=1}^{n} \alpha_i * [1 - label * (w^Tx+b)]$</li><li>就是求<code>L(w,b,a)</code>关于[w, b]的偏导数, 得到<code>w和b的值</code>，并化简为: <code>L和a的方程</code>。</li><li>参考:  如果公式推导还是不懂，也可以参考《统计学习方法》李航-P103&lt;学习的对偶算法&gt;<br><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/SVM_%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F.jpg" alt="计算拉格朗日函数的对偶函数"></li></ul></li><li>终于得到课本上的公式:  $max_{关于\alpha} \left( \sum_{i=1}^{m} \alpha_i - \frac{1}{2} \sum_{i, j=1}^{m} label_i·label_j·\alpha_i·\alpha_j·&lt;x_i, x_j&gt; \right) $</li><li>约束条件:  $a&gt;=0$ 并且 $\sum_{i=1}^{m} a_i·label_i=0$</li></ul><h3 id="2-2-松弛变量-slack-variable"><a href="#2-2-松弛变量-slack-variable" class="headerlink" title="2.2 松弛变量(slack variable)"></a>2.2 松弛变量(slack variable)</h3><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E6%9D%BE%E5%BC%9B%E5%8F%98%E9%87%8F.png" alt="松弛变量公式"></p><ul><li>我们知道几乎所有的数据都不那么干净, 通过引入松弛变量来 <code>允许数据点可以处于分隔面错误的一侧</code>。</li><li>约束条件:  $C&gt;=a&gt;=0$ 并且 $\sum_{i=1}^{m} a_i·label_i=0$</li><li>总的来说: <ul><li><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/SVM_5_Lagrangemultiplier.png" alt="松弛变量"> 表示 <code>松弛变量</code></li><li>常量C是 <code>惩罚因子</code>, 表示离群点的权重（用于控制“最大化间隔”和“保证大部分点的函数间隔小于1.0” ）<ul><li>$label*(w^Tx+b) &gt; 1$ and alpha = 0 (在边界外，就是非支持向量)</li><li>$label*(w^Tx+b) = 1$ and 0&lt; alpha &lt; C (在分割超平面上，就支持向量)</li><li>$label*(w^Tx+b) &lt; 1$ and alpha = C (在分割超平面内，是误差点 -&gt; C表示它该受到的惩罚因子程度)</li><li>参考地址: <a href="https://www.zhihu.com/question/48351234/answer/110486455">https://www.zhihu.com/question/48351234/answer/110486455</a></li></ul></li><li>C值越大，表示离群点影响越大，就越容易过度拟合；反之有可能欠拟合。</li><li>我们看到，目标函数控制了离群点的数目和程度，使大部分样本点仍然遵守限制条件。</li><li>例如: 正类有10000个样本，而负类只给了100个（C越大表示100个负样本的影响越大，就会出现过度拟合，所以C决定了负样本对模型拟合程度的影响！，C就是一个非常关键的优化点！）</li></ul></li><li>这一结论十分直接，SVM中的主要工作就是要求解 alpha.</li></ul><h3 id="2-3-核函数"><a href="#2-3-核函数" class="headerlink" title="2.3 核函数"></a>2.3 核函数</h3><ul><li>对于线性可分的情况，效果明显</li><li>对于非线性的情况也一样，此时需要用到一种叫<code>核函数(kernel)</code>的工具将数据转化为分类器易于理解的形式。</li></ul><blockquote><p>利用核函数将数据映射到高维空间</p></blockquote><ul><li>使用核函数: 可以将数据从某个特征空间到另一个特征空间的映射。（通常情况下: 这种映射会将低维特征空间映射到高维空间。）</li><li>如果觉得特征空间很装逼、很难理解。</li><li>可以把核函数想象成一个包装器(wrapper)或者是接口(interface)，它能将数据从某个很难处理的形式转换成为另一个较容易处理的形式。</li><li>经过空间转换后: 低维需要解决的非线性问题，就变成了高维需要解决的线性问题。</li><li>SVM 优化特别好的地方，在于所有的运算都可以写成内积(inner product: 是指2个向量相乘，得到单个标量 或者 数值)；内积替换成核函数的方式被称为<code>核技巧(kernel trick)</code>或者<code>核"变电"(kernel substation)</code></li><li>核函数并不仅仅应用于支持向量机，很多其他的机器学习算法也都用到核函数。最流行的核函数: 径向基函数(radial basis function)hecn/AiLearning/blob/master/src/py2.x/ml/6.SVM/svm-complete.py</li></ul><h2 id="3-scikit-learn里的SVM"><a href="#3-scikit-learn里的SVM" class="headerlink" title="3. scikit-learn里的SVM"></a>3. scikit-learn里的SVM</h2><p>在scikit-learn里对SVM的算法实现都在包sklearn.svm下面，其中SVC类是用来进行分类任务的，SVR类是用来进行数值回归任务的。我们可能会有疑问，SVM不是用来进行分类的算法吗，为什么可以用来进行数值回归？实际上这只是数学上的一些扩展而已，在计算机里，可以用离散的数值计算来代替连续的数值回归。我们在K-近邻算法中已经看到过这种扩展实现。</p><p>我们以 SVC 为例。首先需要选择 SVM 的核函数，由参数 kernel 来指定，其中值 linea r表示线性核函数，它只能产生直线形状的分隔超平面；值 poly 表示多项式核函数，用它可以构建出复杂形状的分隔超平面；值 rbf 表示径向基核函数，即高斯核函数。</p><p>不同的核函数需要指定不同的参数。针对线性核函数，只需要指定参数 C，它表示对不符合最大间距规则的样本的惩罚力度，即前面介绍的松弛系数。针对多项式核函数，除了参数 C 之外，还需要指定 degree，它表示多项式的阶数。针对高斯核函数，除了参数C之外，还需要指定 gamma 值，这个值对应的是高斯核函数公式中的$\frac{1}{2 \sigma^{2}}$</p><p>下面先来看一个最简单的例子。我们生成一个有两个特征、包含两种类别的数据，然后用线性核函数的SVM算法进行分类：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_hyperplane</span>(<span class="params">clf, X, y, </span></span></span><br><span class="line"><span class="params"><span class="function">                    h=<span class="number">0.02</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                    draw_sv=<span class="literal">True</span>, </span></span></span><br><span class="line"><span class="params"><span class="function">                    title=<span class="string">'hyperplan'</span></span>):</span></span><br><span class="line">    <span class="comment"># create a mesh to plot in</span></span><br><span class="line">    x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">    y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">1</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">1</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, h),</span><br><span class="line">                         np.arange(y_min, y_max, h))</span><br><span class="line"></span><br><span class="line">    plt.title(title)</span><br><span class="line">    plt.xlim(xx.<span class="built_in">min</span>(), xx.<span class="built_in">max</span>())</span><br><span class="line">    plt.ylim(yy.<span class="built_in">min</span>(), yy.<span class="built_in">max</span>())</span><br><span class="line">    plt.xticks(())</span><br><span class="line">    plt.yticks(())</span><br><span class="line">    </span><br><span class="line">    Z = clf.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">    <span class="comment"># Put the result into a color plot</span></span><br><span class="line">    Z = Z.reshape(xx.shape)</span><br><span class="line">    plt.contourf(xx, yy, Z, cmap=<span class="string">'hot'</span>, alpha=<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line">markers = [<span class="string">'o'</span>, <span class="string">'s'</span>, <span class="string">'^'</span>]</span><br><span class="line">    colors = [<span class="string">'b'</span>, <span class="string">'r'</span>, <span class="string">'c'</span>]</span><br><span class="line">    labels = np.unique(y)</span><br><span class="line">    <span class="keyword">for</span> label <span class="keyword">in</span> labels:</span><br><span class="line">        plt.scatter(X[y==label][:, <span class="number">0</span>], </span><br><span class="line">                    X[y==label][:, <span class="number">1</span>], </span><br><span class="line">                    c=colors[label], </span><br><span class="line">                    marker=markers[label])</span><br><span class="line">    <span class="keyword">if</span> draw_sv:</span><br><span class="line">        sv = clf.support_vectors_</span><br><span class="line">        plt.scatter(sv[:, <span class="number">0</span>], sv[:, <span class="number">1</span>], c=<span class="string">'y'</span>, marker=<span class="string">'x'</span>)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">2</span>, </span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.3</span>)</span><br><span class="line">clf = svm.SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'linear'</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">4</span>), dpi=<span class="number">144</span>)</span><br><span class="line">plot_hyperplane(clf, X, y, h=<span class="number">0.01</span>, </span><br><span class="line">                title=<span class="string">'Maximum Margin Hyperplan'</span>)</span><br></pre></td></tr></tbody></table></figure><p>输出的图形如下所示，其中带有x标记的点即为支持向量，它保存在模型的 <code>support_vector</code></p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701095026364.png" alt="image-20200701095026364"></p><p>此处需要注意的是 <code>plot_hyperplane()</code> 函数，其主要功能是画出样本点，同时画出分类区间。它的主要原理是使用 <code>numpy.meshgrid()</code> 生成一个坐标矩阵，最后用 <code>contourf()</code> 函数为坐标矩阵中不同类别的点填充不同的颜色。其中，<code>contourf()</code>函数是画等高线并填充颜色的函数。</p><p>接着来看另外一个例子。我们生成一个有两个特征、包含三种类别的数据集，然后分别构造出4个SVM算法来拟合数据集，分别是线性核函数、三阶多项式核函数、gamma=0.5的高斯核函数，以及gamma=0.1的高斯核函数。最后把这4个SVM算法拟合出来的分隔超平面画出来。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> svm</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">100</span>, centers=<span class="number">3</span>, </span><br><span class="line">                  random_state=<span class="number">0</span>, cluster_std=<span class="number">0.8</span>)</span><br><span class="line">clf_linear = svm.SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'linear'</span>)</span><br><span class="line">clf_poly = svm.SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'poly'</span>, degree=<span class="number">3</span>)</span><br><span class="line">clf_rbf = svm.SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.5</span>)</span><br><span class="line">clf_rbf2 = svm.SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>), dpi=<span class="number">144</span>)</span><br><span class="line"></span><br><span class="line">clfs = [clf_linear, clf_poly, clf_rbf, clf_rbf2]</span><br><span class="line">titles = [<span class="string">'Linear Kernel'</span>, </span><br><span class="line">          <span class="string">'Polynomial Kernel with Degree=3'</span>, </span><br><span class="line">          <span class="string">'Gaussian Kernel with $\gamma=0.5$'</span>, </span><br><span class="line">          <span class="string">'Gaussian Kernel with $\gamma=0.1$'</span>]</span><br><span class="line"><span class="keyword">for</span> clf, i <span class="keyword">in</span> <span class="built_in">zip</span>(clfs, <span class="built_in">range</span>(<span class="built_in">len</span>(clfs))):</span><br><span class="line">    clf.fit(X, y)</span><br><span class="line">    plt.subplot(<span class="number">2</span>, <span class="number">2</span>, i+<span class="number">1</span>)</span><br><span class="line">    plot_hyperplane(clf, X, y, title=titles[i])</span><br></pre></td></tr></tbody></table></figure><p>输出的图形如下所示，其中带有 x 标记的点即为支持向量。</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_2.jpg" alt="image-20200701101406980"></p><p>左上角是线性核函数，它只能拟合出直线分隔超平面。右上角是三阶多项式核函数，它能拟合出复杂曲线分隔超平面。左下角是 <code>gamma=0.5</code> 的高斯核函数，右下角是 <code>gamma=0.1</code> 的高斯核函数，通过调整参数 <code>gamma</code> 的值，可以调整分隔超平面的形状。典型地，<code>gamma</code>值太大，越容易造成过拟合，<code>gamma</code> 值太小，高斯核函数会退化成线性核函数。我们把代码中的 <code>gamma</code>值 改为 100 和 0.01 后看一下输出图形是什么样的。</p><p>思考：左下角 gamma=0.5 的高斯核函数的图片，带有 x 标记的点是支持向量。我们之前介绍过，离分隔超平面最近的点是支持向量，为什么很多离分隔超平面很远的点，也是支持向量呢？</p><p>原因是高斯核函数把输入特征向量映射到了无限维的向量空间里，在映射后的高维向量空间里，这些点其实是离分隔超平面最近的点。当回到二维向量空间中时，这些点“看起来”就不像是距离分隔超平面最近的点了，但实际上它们就是支持向量。</p><h2 id="4-示例：乳腺癌检测"><a href="#4-示例：乳腺癌检测" class="headerlink" title="4.示例：乳腺癌检测"></a>4.示例：乳腺癌检测</h2><p>之前我们使用逻辑回归算法进行过乳腺癌检测模型的学习和训练。这里我们再使用支持向量机算法来解决这个问题。首先我们载入数据：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="comment"># 载入数据</span></span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X = cancer.data</span><br><span class="line">y = cancer.target</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'data shape: {0}; no. positive: {1}; no. negative: {2}'</span>.<span class="built_in">format</span>(</span><br><span class="line">    X.shape, y[y==<span class="number">1</span>].shape[<span class="number">0</span>], y[y==<span class="number">0</span>].shape[<span class="number">0</span>]))</span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight kotlin"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> shape: (<span class="number">569</span>, <span class="number">30</span>); no. positive: <span class="number">357</span>; no. negative: <span class="number">212</span></span><br></pre></td></tr></tbody></table></figure><p>可以看出，我们的数据集很小。高斯核函数太复杂，容易造成过拟合，模型效果应该不会太好。我们先用高斯核函数来试一下，看与我们的猜测是否一致。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">clf = SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.1</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">train_score = clf.score(X_train, y_train)</span><br><span class="line">test_score = clf.score(X_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'train score: {0}; test score: {1}'</span>.<span class="built_in">format</span>(train_score, test_score))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train score: <span class="number">1.0</span>; test score: <span class="number">0.6491228070175439</span></span><br></pre></td></tr></tbody></table></figure><p>训练数据集分数为1.0，交叉验证数据集分数只有0.65，这是典型的过拟合现象。这里 gamma=0.1，这个值相对已经比较小了。我们可以把gamma改的更小如0.0001看看什么结果。</p><p>当然，我们完全可以使用前面介绍过的 <code>GridSearchCV</code> 来自动选择最优参数。我们看看如果使用高斯模型，最优的gamma参数值是多少，其对应的模型交叉验证评分是多少。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> plot_param_curve</span><br><span class="line"> gammas = np.linspace(<span class="number">0</span>, <span class="number">0.0003</span>, <span class="number">30</span>)</span><br><span class="line">param_grid = {<span class="string">'gamma'</span>: gammas}</span><br><span class="line"> clf = GridSearchCV(SVC(), param_grid, cv=<span class="number">5</span>,return_train_score=<span class="literal">True</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"best param: {0}\nbest score: {1}"</span>.<span class="built_in">format</span>(clf.best_params_,clf.best_score_))</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">4</span>), dpi=<span class="number">144</span>)</span><br><span class="line">plot_param_curve(plt, gammas, clf.cv_results_, xlabel=<span class="string">'gamma'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">best param: {<span class="string">'gamma'</span>: <span class="number">0.00011379310344827585</span>}</span><br><span class="line">best score: <span class="number">0.9367334264865704</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701101406980.png" alt="image-20200701102906477"></p><p>由此可见，即使在最好的 gamma 参数下，其平均最优得分也只是0.9367311072056239。我们选择在gamma为0.01时，画出学习曲线，更直观地观察模型拟合情况。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ShuffleSplit</span><br><span class="line">cv = ShuffleSplit(n_splits=<span class="number">10</span>, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line">title = <span class="string">'Learning Curves for Gaussian Kernel'</span></span><br><span class="line">start = time.clock()</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">4</span>), dpi=<span class="number">144</span>)</span><br><span class="line">plot_learning_curve(plt, SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'rbf'</span>, gamma=<span class="number">0.01</span>), title, X, y, ylim=(<span class="number">0.5</span>, <span class="number">1.01</span>), cv=cv)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'elaspe: {0:.6f}'</span>.<span class="built_in">format</span>(time.clock()-start))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elaspe: <span class="number">0.687500</span></span><br></pre></td></tr></tbody></table></figure><p>画出来的图形如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_7.png" alt="image-20200701103141555"></p><p>这是明显的过拟合现象，交叉验证数据集的评分非常低，且离训练数据集评分非常远。</p><hr><p><strong>接下来换一个模型，使用二阶多项式核函数的SVM来拟合模型，看看结果如何。</strong></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVC</span><br><span class="line">clf = SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'poly'</span>, degree=<span class="number">2</span>)</span><br><span class="line">clf.fit(X_train, y_train)</span><br><span class="line">train_score = clf.score(X_train, y_train)</span><br><span class="line">test_score = clf.score(X_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'train score: {0}; test score: {1}'</span>.<span class="built_in">format</span>(train_score, test_score))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train score: <span class="number">0.9098901098901099</span>; test score: <span class="number">0.9210526315789473</span></span><br></pre></td></tr></tbody></table></figure><p>看起来结果好多了。作为对比，我们画出一阶多项式核函数的SVM和二阶多项式核函数的SVM的学习曲线，观察模型的拟合情况。</p><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">from sklearn.model_selection <span class="keyword">import</span> ShuffleSplit</span><br><span class="line">cv = ShuffleSplit(n_splits=<span class="number">5</span>, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line">title = <span class="string">'Learning Curves with degree={0}'</span></span><br><span class="line">degrees = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">start = time.clock()</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">4</span>), dpi=<span class="number">144</span>)</span><br><span class="line"><span class="keyword">for</span> i in <span class="keyword">range</span>(<span class="built_in">len</span>(degrees)):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="built_in">len</span>(degrees), i + <span class="number">1</span>)</span><br><span class="line">    plot_learning_curve(plt, SVC(C=<span class="number">1.0</span>, kernel=<span class="string">'poly'</span>, degree=degrees[i]),</span><br><span class="line">                        title.format(degrees[i]), X, y, ylim=(<span class="number">0.8</span>, <span class="number">1.01</span>), cv=cv, n_jobs=<span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'elaspe: {0:.6f}'</span>.format(time.clock()-start))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elaspe: <span class="number">0.281250</span></span><br></pre></td></tr></tbody></table></figure><p>输出的图形如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701102906477.png" alt="image-20200701103641519"></p><p>前面我们使用逻辑回归算法来处理乳腺癌检测问题时，使用二阶多项式增加特征，同时使用L1范数作为正则项，其拟合效果比这里的支持向量机效果好。更重要的是，逻辑回归算法的运算效率远远高于二阶多项式核函数的支持向量机算法。当然，这里的支持向量机算法的效果还是比使用L2范数作为正则项的逻辑回归算法好的。由此可见，模型选择和模型参数调优，在工程实践中有着非常重要的作用的。</p><h2 id="5-拓展SVM的理解"><a href="#5-拓展SVM的理解" class="headerlink" title="5. 拓展SVM的理解"></a>5. 拓展SVM的理解</h2><h3 id="什么是-SVM-？"><a href="#什么是-SVM-？" class="headerlink" title="什么是 SVM ？"></a>什么是 SVM ？</h3><p>Support Vector Machine, 一个普通的 SVM 就是一条直线罢了，用来完美划分 linearly separable 的两类。但这又不是一条普通的直线，这是无数条可以分类的直线当中最完美的，因为它恰好在两个类的中间，距离两个类的点都一样远。而所谓的 Support vector 就是这些离分界线最近的『点』。如果去掉这些点，直线多半是要改变位置的。可以说是这些 vectors （主，点点） support （谓，定义）了 machine （宾，分类器）…</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_8.png" alt="k_2" title="k_2"></p><p>所以谜底就在谜面上啊朋友们，只要找到了这些最靠近的点不就找到了 SVM 了嘛。</p><p>如果是高维的点，SVM 的分界线就是平面或者超平面。其实没有差，都是一刀切两块，我就统统叫直线了。</p><h3 id="怎么求解-SVM-？"><a href="#怎么求解-SVM-？" class="headerlink" title="怎么求解 SVM ？"></a>怎么求解 SVM ？</h3><p>关于这条直线，我们知道 </p><p>(1)它离两边一样远，(2)最近距离就是到support vector的距离，其他距离只能更远。</p><p>于是自然而然可以得到重要表达 <b>I. direct representation</b></p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701103141555.png" alt="k_7" title="k_7"></p><p>（可以把 margin 看作是 boundary 的函数，并且想要找到使得是使得 margin 最大化的boundary，而 margin(*) 这个函数是: 输入一个 boundary ，计算（正确分类的）所有苹果和香蕉中，到 boundary 的最小距离。）</p><p>又有最大又有最小看起来好矛盾。实际上『最大』是对这个整体使用不同 boundary 层面的最大，『最小』是在比较『点』的层面上的最小。外层在比较 boundary 找最大的 margin ，内层在比较点点找最小的距离。</p><p>其中距离，说白了就是点到直线的距离；只要定义带正负号的距离，是 {苹果+1} 面为正 {香蕉-1} 面为负的距离，互相乘上各自的 label <img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200701103641519.png" alt="k_8" title="k_8"> ，就和谐统一民主富强了。</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_9.png" alt="k_9" title="k_9"></p><p>到这里为止已经说完了所有关于SVM的直观了解，如果不想看求解，可以跳过下面一大段直接到 objective function 。</p><p>直接表达虽然清楚但是求解无从下手。做一些简单地等价变换（分母倒上来）可以得到 <b>II. canonical representation </b> （敲黑板）</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_10.png" alt="k_10" title="k_10"></p><p>要得到 <b>III. dual representation</b> 之前需要大概知道一下拉格朗日乘子法 (method of lagrange multiplier)，它是用在有各种约束条件(各种 “subject to” )下的目标函数，也就是直接可以求导可以引出 dual representation（怎么还没完摔）</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_11.png" alt="k_11" title="k_11"></p><p>稍微借用刚刚数学表达里面的内容看个有趣的东西: </p><p>还记得我们怎么预测一个新的水果是苹果还是香蕉吗？我们代入到分界的直线里，然后通过符号来判断。</p><p>刚刚w已经被表达出来了也就是说这个直线现在变成了:  <img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_12.png" alt="k_12" title="k_12"></p><p>看似仿佛用到了所有的训练水果，但是其中 <img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_13.png" alt="k_13" title="k_13"> 的水果都没有起到作用，剩下的就是小部分靠边边的 Support vectors 呀。</p><p><b>III. dual representation</b></p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_14.png" alt="k_14" title="k_14"></p><p><b>如果香蕉和苹果不能用直线分割呢？</b></p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_15.png" alt="k_3" title="k_3"></p><p>Kernel trick. </p><p>其实用直线分割的时候我们已经使用了 kernel ，那就是线性 kernel , <img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_3.jpg" alt="k_15" title="k_15"></p><p>如果要替换 kernel 那么把目标函数里面的内积全部替换成新的 kernel function 就好了，就是这么简单。</p><p>第一个武侠大师的比喻已经说得很直观了，低维非线性的分界线其实在高维是可以线性分割的，可以理解为——『你们是虫子！』分得开个p…（大雾）</p><p><b>如果香蕉和苹果有交集呢？</b></p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_4.jpg" alt="k_4" title="k_4"></p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_16.png" alt="k_16" title="k_16"></p><p><b>如果还有梨呢？</b></p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/k_5.jpg" alt="k_5" title="k_5"></p><p>可以每个类别做一次 SVM: 是苹果还是不是苹果？是香蕉还是不是香蕉？是梨子还是不是梨子？从中选出可能性最大的。这是 one-versus-the-rest approach。</p><p>也可以两两做一次 SVM: 是苹果还是香蕉？是香蕉还是梨子？是梨子还是苹果？最后三个分类器投票决定。这是 one-versus-one approace。</p><p>但这其实都多多少少有问题，比如苹果特别多，香蕉特别少，我就无脑判断为苹果也不会错太多；多个分类器要放到一个台面上，万一他们的 scale 没有在一个台面上也未可知。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列五：决策树</title>
      <link href="/2020/06/30/scikit-learn-xi-lie-wu-jue-ce-shu/"/>
      <url>/2020/06/30/scikit-learn-xi-lie-wu-jue-ce-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="1-决策树概述"><a href="#1-决策树概述" class="headerlink" title="1. 决策树概述"></a>1. 决策树概述</h2><p>决策树（Decision Tree）算法是一种基本的分类与回归方法，是最经常使用的数据挖掘算法之一，它的预测结果容易理解，易于向业务部门解释，预测速度快，可以处理离散型数据和连续型数据。</p><p>决策树模型呈树形结构，在分类问题中，表示基于特征对实例进行分类的过程。它可以认为是 if-then 规则的集合，也可以认为是定义在特征空间与类空间上的条件概率分布。</p><p>决策树学习通常包括 3 个步骤: 特征选择、决策树的生成和决策树的修剪。</p><hr><h2 id="2-决策树原理"><a href="#2-决策树原理" class="headerlink" title="2. 决策树原理"></a>2. 决策树原理</h2><p>一个叫做 “二十个问题” 的游戏，游戏的规则很简单: 参与游戏的一方在脑海中想某个事物，其他参与者向他提问，只允许提 20 个问题，问题的答案也只能用对或错回答。问问题的人通过推断分解，逐步缩小待猜测事物的范围，最后得到游戏的答案。</p><p>一个邮件分类系统，大致工作流程如下: </p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E5%86%B3%E7%AD%96%E6%A0%91-%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt="决策树-流程图" title="决策树示例流程图"></p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先检测发送邮件域名地址。如果地址为 myEmployer.com, 则将其放在分类 "无聊时需要阅读的邮件"中。</span><br><span class="line">如果邮件不是来自这个域名，则检测邮件内容里是否包含单词 "曲棍球" , 如果包含则将邮件归类到 "需要及时处理的朋友邮件", </span><br><span class="line">如果不包含则将邮件归类到 "无需阅读的垃圾邮件" 。</span><br></pre></td></tr></tbody></table></figure><p>问题来了，在创建决策树的过程中，要先对哪个特征进行分裂？比如上图中的例子，先判断域名地址进行分裂还是先判断包含 “曲棍球” 进行分裂？要回答这个问题，我们需要从信息的量化谈起。</p><h3 id="2-1-信息熵-amp-信息增益"><a href="#2-1-信息熵-amp-信息增益" class="headerlink" title="2.1 信息熵 &amp; 信息增益"></a>2.1 信息熵 &amp; 信息增益</h3><p><code>熵（entropy）:</code><br>熵指的是体系的混乱的程度，在不同的学科中也有引申出的更为具体的定义，是各领域十分重要的参量。</p><p><code>信息论（information theory）中的熵（香农熵）:</code><br>是一种信息的度量方式，表示信息的混乱程度，也就是说: 信息越有序，信息熵越低。例如: 火柴有序放在火柴盒里，熵值很低，相反，熵值很高。</p><p><code>信息增益（information gain）:</code><br>在划分数据集前后信息发生的变化称为信息增益。</p><h3 id="2-2-决策树的创建"><a href="#2-2-决策树的创建" class="headerlink" title="2.2 决策树的创建"></a>2.2 决策树的创建</h3><p>决策树的构建过程，就是从训练数据集中归纳出一组分类规则，使它与训练数据矛盾较小的同时具有较强的泛化能力。有了信息增益来量化地选择数据集的划分特征，使决策树的创建过程变得容易了。决策树的创建基本上分为以下几个步骤：</p><p> （1）计算数据集划分前的信息熵。<br> （2）遍历所有未作为划分条件的特征，分别计算根据每个特征划分数据集后的信息熵。<br> （3）选择信息增益最大的特征，并使用这个特征作为数据划分节点来划分数据。<br> （4）递归地处理被划分后的所有子数据集，从未被选择的特征里继续选择最优数据划分特征来划分子数据集。</p><p>问题来了，递归过程什么时候结束呢？一般来讲，有两个终止条件：一是所有的特征都用完了，即没有新的特征可以用来进一步划分数据集。二是划分后的信息增益足够小了，这个时候就可以停止递归划分了。针对这个停止条件，需要事先选择信息增益的阈值来作为结束递归地条件。</p><p>使用信息增益作为特征选择指标的决策树构建算法，称为ID3算法。</p><h3 id="2-3-剪枝算法"><a href="#2-3-剪枝算法" class="headerlink" title="2.3 剪枝算法"></a>2.3 剪枝算法</h3><p>使用决策树模型拟合数据时，容易造成过拟合。解决过拟合的方法是对决策树进行剪枝处理。决策树的剪枝有两种思路：前剪枝（Pre-Pruning）和后剪枝（Post-Pruning）。</p><h4 id="前剪枝（Pre-Pruning）"><a href="#前剪枝（Pre-Pruning）" class="headerlink" title="前剪枝（Pre-Pruning）"></a>前剪枝（Pre-Pruning）</h4><p> 前剪枝是在构造决策树的同时进行剪枝。在决策树的构建过程中，如果无法进一步降低信息熵，就会停止创建分支。为了避免过拟合，可以设定一个阈值，即使可以继续降低信息熵，也停止继续创建分支。这种方法称为前剪枝。还有一些简单的前剪枝方法，如限制叶子节点的样本个数，当样本个数小于一定的阈值时，即不再继续创建分支。</p><h4 id="后剪枝（Post-Pruning）"><a href="#后剪枝（Post-Pruning）" class="headerlink" title="后剪枝（Post-Pruning）"></a>后剪枝（Post-Pruning）</h4><p> 后剪枝是指决策树构建完成之后进行剪枝。剪枝的过程是对拥有同样父节点的一组节点进行检查，判断如果将其合并，信息熵的增加量是否小于某一阈值。如果小于阈值，则这一组节点可以合并成一个节点。后剪枝是目前较普遍的做法。后剪枝的过程是删除一些子树，然后用子树的根节点代替，来作为新的叶子结点。这个新的叶子节点所标识的类别通过大多数原则来确定，即把这个叶子节点里样本最多的类别，作为这个叶子节点的类别。</p><p>后剪枝算法有很多种，其中常用的一种称为 <code>降低错误率剪枝法（Reduced-Error Pruning）</code>。其思路是，自底向上，从已经构建好的完全决策树中找出一棵子树，然后用子树的根代替这棵子树，作为新的叶子节点。叶子节点所标识的类别通过大多数原则来确定。这样就构建出了一个新的简化版的决策树。然后使用交叉验证数据集来检测这棵简化版的决策树，看其错误率是否降低了。如果错误率降低了，则可以使用这个简化版的决策树代替完全决策树。否则，还是采用原来的决策树。通过遍历所有的子树，直到针对交叉验证数据集，无法进一步降低错误率为止。</p><hr><h2 id="3-决策树算法参数"><a href="#3-决策树算法参数" class="headerlink" title="3. 决策树算法参数"></a>3. 决策树算法参数</h2><p><code>scikit-learn</code>使用 <code>sklearn.tree.DecisionTreeClassifier</code> 类来实现决策树分类算法。其中几个典型的参数如下：</p><ul><li><code>criterion：特征选择算法。</code>一种是基于信息熵，另外一种是基于基尼不纯度。研究表明，这两种算法的差异性不大，对模型准确性没有太大的影响。相对而言，信息熵运算效率会低一些，因为它有对数运算。</li><li><code>splitter：创建决策树分支的选项。</code>一种是选择最优的分支创建原则。另外一种是从排名靠前的特征中，随机选择一个特征来创建分支，这个方法和正则项的效果类似，可以避免过拟合。</li><li><code>max_depth：</code>指定决策树的最大深度。通过指定该参数，用来解决模型过拟合问题。</li><li><code>min_samples_split：</code>这个参数指定能创建分支的数据集的大小，默认是2。如果一个节点的数据样本个数小于这个数值，则不再创建分支。这就是上面介绍的前剪枝的一种方法。</li><li><code>min_samples_leaf：</code>叶子节点的最小样本数量，叶子节点的样本数量必须大于等于这个值。这也是上面介绍的另一种前剪枝的方法。</li><li><code>max_leaf_nodes：</code>最大叶子节点个数，即数据集最多能划分成几个类别。</li><li><code>min_impurity_split：</code>信息增益必须大于等于这个阈值才可以继续分支，否则不创建分支。<br> 从这些参数可以看出，<code>scikit-learn</code>有一系列的参数用来控制决策树的生成过程，从而解决过拟合问题。</li></ul><hr><h2 id="4-示例：预测泰坦尼克号幸存者"><a href="#4-示例：预测泰坦尼克号幸存者" class="headerlink" title="4. 示例：预测泰坦尼克号幸存者"></a>4. 示例：预测泰坦尼克号幸存者</h2><p>众所周知，泰坦尼克号是历史上最严重的一起海难事故。我们通过决策树模型，来预测哪些人可能成为幸存者。<a href="https://www.kaggle.com/c/titanic">数据集下载</a>，也可以去<a href="https://github.com/DongZhouGu/scikit-learn-ml">仓库地址</a></p><p>数据集中总共有两个文件，都是 csv 格式的数据。其中，train.csv 是训练数据集，包含已标注的训练样本数据。test.csv 是模型进行幸存者预测的测试数据。我们的任务就是根据 train.csv 里的数据训练出决策树模型，然后使用该模型来预测test.csv里的数据，并查看模型的预测效果。</p><h3 id="4-1-数据分析"><a href="#4-1-数据分析" class="headerlink" title="4.1 数据分析"></a>4.1 数据分析</h3><p>train.csv 是一个892行、12列的数据表格。意味着我们有 891 个训练样本（扣除表头），每个样本有12个特征。我们需要先分析这些特征，以便决定哪些特征可以用来进行模型训练。</p><ul><li><code>PassengerId：</code>乘客的ID号，这个是顺序编号，用来唯一地标识一名乘客。这个特征和幸存与否无关，丢弃这个特征。</li><li><code>Survived</code>：1表示幸存，0表示遇难。这是标注数据。</li><li><code>Pclass</code>：仓位等级。这是个很重要的特征，高仓位的乘客能更快的到达甲板，从而更容易获救。</li><li><code>Name</code>：乘客的名字，这个特征和幸存与否无关，丢弃这个特征。</li><li><code>Sex</code>：乘客性别。由于救生艇数量不够，船长让妇女和儿童先上救生艇。所以这也是个很重要的特征。</li><li><code>Age</code>：乘客的年龄。儿童会优先上救生艇，身强力壮者幸存概率也会高一些。所以这也是个很重要的特征。</li><li><code>SibSp</code>：兄弟姐妹同在船上的数量。</li><li><code>Parch</code>：同船的父辈人员的数量。</li><li><code>Ticket</code>：乘客的票号。这个特征和幸存与否无关，丢弃这个特征。</li><li><code>Fare</code>：乘客的体热指标。</li><li><code>Cabin</code>：乘客所在的船舱号。实际上这个特征和幸存与否有一定的关系，比如最早被水淹没的船舱位置，其乘客的幸存概率要低一些。但由于这个特征有大量的丢失数据，而且没有更多的数据来对船舱进行归类，因此我们丢弃这个特征的数据。</li><li><code>Embarked</code>：乘客登船的港口。我们需要把港口数据转换为数值类型的数据。</li></ul><p>我们需要加载csv数据。并做一些预处理，包括：</p><ul><li>提取Survived列的数据作为模型的标注数据。</li><li>丢弃不需要的特征数据。</li><li>对数据进行转换，以便模型处理。比如把性别数据转换为0和1.</li><li>处理缺失的数据。比如年龄这个特征，有很多缺失的数据。</li></ul><p><code>Pandas</code> 是完成这些任务的理想软件包，我们先把数据从文件里读取出来：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_dataset</span>(<span class="params">fname</span>):</span></span><br><span class="line">    <span class="comment"># 指定第一列作为行索引</span></span><br><span class="line">    data = pd.read_csv(fname,index_col=<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># 丢弃无用的数据</span></span><br><span class="line">    data.drop([<span class="string">'Name'</span>,<span class="string">'Ticket'</span>,<span class="string">'Cabin'</span>],axis=<span class="number">1</span>,inplace=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 处理性别数据</span></span><br><span class="line">    data[<span class="string">'Sex'</span>] = (data[<span class="string">'Sex'</span>]==<span class="string">'male'</span>).astype(<span class="string">'int'</span>)</span><br><span class="line">    <span class="comment"># 处理登船港口数据</span></span><br><span class="line">    labels = data[<span class="string">'Embarked'</span>].unique().tolist()</span><br><span class="line">    data[<span class="string">'Embarked'</span>] = data[<span class="string">'Embarked'</span>].apply(<span class="keyword">lambda</span> n:labels.index(n))</span><br><span class="line">    <span class="comment"># 处理缺失数据</span></span><br><span class="line">    data = data.fillna(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">train = read_dataset(<span class="string">'./titanic/train.csv'</span>)</span><br><span class="line">train.head()</span><br></pre></td></tr></tbody></table></figure><p>处理完的数据如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630171531856.png" alt="img"></p><h3 id="4-2-模型训练"><a href="#4-2-模型训练" class="headerlink" title="4.2 模型训练"></a>4.2 模型训练</h3><p>首先需要把 <code>Survived</code> 列提取出来作为标签，并在原数据集中删除这一列。然后把数据集划分成训练数据集和交叉验证数据集。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">y = train[<span class="string">'Survived'</span>].values</span><br><span class="line">X = train.drop([<span class="string">'Survived'</span>],axis=<span class="number">1</span>).values</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'train dataset: {0}; test dataset: {1}'</span>.<span class="built_in">format</span>(X_train.shape,X_test.shape))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train dataset: (<span class="number">712</span>, <span class="number">7</span>); test dataset: (<span class="number">179</span>, <span class="number">7</span>)</span><br></pre></td></tr></tbody></table></figure><p>接着，使用 <code>scikit-learn</code> 的决策树模型对数据集进行拟合，并观察模型的性能：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> DecisionTreeClassifier</span><br><span class="line">clf = DecisionTreeClassifier()</span><br><span class="line">clf.fit(X_train,y_train)</span><br><span class="line">train_score = clf.score(X_train,y_train)</span><br><span class="line">test_score = clf.score(X_test,y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'train score: {0}; test score: {1}'</span>.<span class="built_in">format</span>(train_score,test_score))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train score: <span class="number">0.9859550561797753</span>; test score: <span class="number">0.7877094972067039</span></span><br></pre></td></tr></tbody></table></figure><p>从输出结果可以看出，针对训练样本评分很高，但是针对交叉验证数据集评分较低，两者差距较大。没错，这是过拟合现象。解决决策树过拟合的方法是剪枝，包括前剪枝和后剪枝。不幸的是 <code>scikit-learn</code> 不支持后剪枝，但是提供了一系列模型参数进行前剪枝。例如，可以通过 <code>max_depth</code> 参数限定决策树的深度，当决策树达到限定的深度时，就不再进行分裂了。这样就可以在一定程度上避免过拟合。</p><h3 id="4-3-优化模型参数"><a href="#4-3-优化模型参数" class="headerlink" title="4.3 优化模型参数"></a>4.3 优化模型参数</h3><p>我们可以选择一系列的参数值，然后分别计算指定参数训练出来的模型的评分。还可以把参数值和模型评分通过图形画出来，以便直观地发现两者之间的关系。</p><p>这里以限制决策树深度 <code>max_depth</code> 为了来介绍模型参数的优化过程。我们先创建一个函数，它使用不同的<code>max_depth</code> 来训练模型，并计算模型评分。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数选择 max_depth</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv_score</span>(<span class="params">d</span>):</span></span><br><span class="line">    clf = DecisionTreeClassifier(max_depth=d)</span><br><span class="line">    clf.fit(X_train,y_train)</span><br><span class="line">    tr_score = clf.score(X_train,y_train)</span><br><span class="line">    cv_score = clf.score(X_test,y_test)</span><br><span class="line">    <span class="keyword">return</span> (tr_score,cv_score)</span><br></pre></td></tr></tbody></table></figure><p>接着构造参数范围，在这个范围内分别计算模型评分，并找出评分最高的模型所对应的参数。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">depths = range(<span class="number">2</span>,<span class="number">15</span>)</span><br><span class="line">scores = [cv_score(d) <span class="keyword">for</span> d <span class="keyword">in</span> depths]</span><br><span class="line">tr_scores = [s[<span class="number">0</span>] <span class="keyword">for</span> s <span class="keyword">in</span> scores]</span><br><span class="line">cv_scores = [s[<span class="number">1</span>] <span class="keyword">for</span> s <span class="keyword">in</span> scores]</span><br><span class="line">best_score_index = np.argmax(cv_scores)</span><br><span class="line">best_score = cv_scores[best_score_index]</span><br><span class="line">best_param = depths[best_score_index]</span><br><span class="line"><span class="built_in">print</span>(scores)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'best param: {0}； best score： {1}'</span>.format(best_param,best_score))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">best param: <span class="number">4</span>； best score： <span class="number">0.8212290502793296</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，针对模型深度这个参数，最优的值是4，其对应的交叉验证数据集评分为0.82。我们还可以把模型参数和对应的模型评分画出来，更直观地观察其变化规律。</p><figure class="highlight dart"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.figure(figsize=(<span class="number">6</span>,<span class="number">4</span>),dpi=<span class="number">144</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.xlabel(<span class="string">'max depth of decision tree'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'score'</span>)</span><br><span class="line">plt.plot(depths,cv_scores,<span class="string">'.g-'</span>,label=<span class="string">'cross-validation score'</span>)</span><br><span class="line">plt.plot(depths,tr_scores,<span class="string">'.r--'</span>,label=<span class="string">'training score'</span>)</span><br><span class="line">plt.legend()</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-8536c1c2cfda1d0f.png" alt="image-20200630171531856"></p><p>使用同样的方式，我们可以考察参数 m<code>in_impurity_split</code> 。这个参数用来指定信息熵或基尼不纯度的阈值。当决策树分裂后，其信息增益低于这个阈值，则不再分裂。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练模型，并计算评分</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cv_score</span>(<span class="params">val</span>):</span></span><br><span class="line">    clf = DecisionTreeClassifier(criterion=<span class="string">'gini'</span>, min_impurity_decrease=val)</span><br><span class="line">    clf.fit(X_train, y_train)</span><br><span class="line">    tr_score = clf.score(X_train, y_train)</span><br><span class="line">    cv_score = clf.score(X_test, y_test)</span><br><span class="line">    <span class="keyword">return</span> (tr_score, cv_score)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定参数范围，分别训练模型，并计算评分</span></span><br><span class="line">values = np.linspace(<span class="number">0</span>, <span class="number">0.005</span>, <span class="number">50</span>)</span><br><span class="line">scores = [cv_score(v) <span class="keyword">for</span> v <span class="keyword">in</span> values]</span><br><span class="line">tr_scores = [s[<span class="number">0</span>] <span class="keyword">for</span> s <span class="keyword">in</span> scores]</span><br><span class="line">cv_scores = [s[<span class="number">1</span>] <span class="keyword">for</span> s <span class="keyword">in</span> scores]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找出评分最高的模型参数</span></span><br><span class="line">best_score_index = np.argmax(cv_scores)</span><br><span class="line">best_score = cv_scores[best_score_index]</span><br><span class="line">best_param = values[best_score_index]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'best param: {0}; best score: {1}'</span>.<span class="built_in">format</span>(best_param, best_score))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 画出模型参数与模型评分的关系</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>), dpi=<span class="number">144</span>)</span><br><span class="line">plt.grid()</span><br><span class="line">plt.xlabel(<span class="string">'threshold of entropy'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'score'</span>)</span><br><span class="line">plt.plot(values, cv_scores, <span class="string">'.g-'</span>, label=<span class="string">'cross-validation score'</span>)</span><br><span class="line">plt.plot(values, tr_scores, <span class="string">'.r--'</span>, label=<span class="string">'training score'</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">best param: <span class="number">0.0005102040816326531</span>; best score: <span class="number">0.8100558659217877</span></span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630181702264.png" alt="image-20200630174835975"></p><p>这里把[0,0.005]等分50份，以每个等分点作为信息增益阈值来训练一次模型。可以看到，训练数据集的评分急速下降，且训练评分和测试评分都保持较低水平，说明模型欠拟合。我们可以把决策树特征选择的基尼不纯度改为信息熵，即把参数<code>criterion</code>的值改为<code>'entropy'</code>观察图形的变化。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">clf = DecisionTreeClassifier(criterion=<span class="string">'entropy'</span>, min_impurity_decrease=val)</span><br><span class="line">...</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630174835975.png" alt="image-20200630175057127"></p><h3 id="4-4-模型参数选择工具包"><a href="#4-4-模型参数选择工具包" class="headerlink" title="4.4 模型参数选择工具包"></a>4.4 模型参数选择工具包</h3><p>上面的模型参数优化过程存在两个问题。其一，数据不稳定，即数据集每次都是随机划分的，选择出来的最优参数在下一次运行时就不是最优的了。其二，不能一次选择多个参数，例如，想要考察 <code>max_depth</code>和<code>min_samples_leaf</code>两个结合起来的最优参数就无法实现。</p><p>问题一的原因是，每次把数据集划分为训练样本和交叉验证样本时，是随机划分的，这样导致每次的训练数据集是有差异的，训练出来的模型也有差异。解决这个问题的方法是多次计算，求平均值。具体来讲，就是针对模型的某个特定的参数，多次划分数据集，多次训练模型，计算出这个参数对应的模型的最低评分、最高评分以及评价评分。问题二的解决办法比较简单，把代码再优化一下，能处理多个参数组合即可。</p><p>所幸，我们不需要从头实现这些代码。<code>scikit-learn</code>在 <code>sklearn.model_selection</code>包里提供了大量模型选择和评估工具供我们使用。针对以上问题，可以使用 <code>GridSearchCV</code> 类来解决。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">thresholds = np.linspace(<span class="number">0</span>, <span class="number">0.5</span>, <span class="number">50</span>)</span><br><span class="line">param_grid = {<span class="string">'min_impurity_split'</span>: thresholds}</span><br><span class="line">clf = GridSearchCV(DecisionTreeClassifier(), param_grid, cv=<span class="number">5</span>,return_train_score=<span class="literal">True</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"best param: {0}\nbest score: {1}"</span>.<span class="built_in">format</span>(clf.best_params_, clf.best_score_))</span><br><span class="line">plot_curve(thresholds, clf.cv_results_, xlabel=<span class="string">'gini thresholds'</span>)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">best param: {<span class="string">'min_impurity_split'</span>: <span class="number">0.19387755102040816</span>}</span><br><span class="line">best score: <span class="number">0.82045069361622</span></span><br></pre></td></tr></tbody></table></figure><p>其中关键的参数是<code>param_grid</code>，它是一个字典，键对应的值是一个列表。<code>GridSearchCV</code>会枚举列表里的所有值来构建模型，最终得出指定参数值的平均评分及标准差。另外一个关键参数是cv，它用来指定交叉验证数据集的生成规则，代码中的 cv=5 ，表示每次计算都把数据集分成 5 份，拿其中一份作为交叉验证数据集，其他的作为训练数据集。最终得出的最优参数及最优评分保存在 <code>clf.best_params</code> 和 <code>clf.best_score</code>里。此外，<code>clf.cv_results_</code>保存了计算过程的所有中间结果。我们可以拿这个数据来画出模型参数与模型评分的关系图，如下所示:</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630175057127.png" alt="image-20200630181702264"></p><p>接下来看一下如何在多组参数之间选择最优的参数组合：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line">entropy_thresholds = np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line">gini_thresholds = np.linspace(<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">50</span>)</span><br><span class="line">param_grid = [{<span class="string">'criterion'</span>:[<span class="string">'entropy'</span>],<span class="string">'min_impurity_split'</span>:entropy_thresholds},</span><br><span class="line">              {<span class="string">'criterion'</span>:[<span class="string">'gini'</span>],<span class="string">'min_impurity_split'</span>:gini_thresholds},</span><br><span class="line">              {<span class="string">'max_depth'</span>:<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">10</span>)},</span><br><span class="line">              {<span class="string">'min_samples_split'</span>:<span class="built_in">range</span>(<span class="number">2</span>,<span class="number">30</span>,<span class="number">2</span>)}]</span><br><span class="line">clf=GridSearchCV(DecisionTreeClassifier(),param_grid,cv=<span class="number">5</span>)</span><br><span class="line">clf.fit(X,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'best param: {0}\nbest score: {1}'</span>.<span class="built_in">format</span>(clf.best_params_,clf.best_score_))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">best param: {<span class="string">'criterion'</span>: <span class="string">'entropy'</span>, <span class="string">'min_impurity_split'</span>: <span class="number">0.5306122448979591</span>}</span><br><span class="line">best score: <span class="number">0.8305818843763729</span></span><br></pre></td></tr></tbody></table></figure><p>代码关键部分还是<code>param_grid</code>参数，它是一个列表，列表中的每个元素都是字典。例如：针对列表中的第一个字典，选择信息熵作为决策树特征选择的判断标准，同时其阈值范围是[0,1]之间分了50等份。<code>GridSearchCV</code>会针对列表中的每个字典进行迭代，最终比较列表中每个字典所对应的参数组合，选择出最优的参数。关于<code>GridSearchCV</code>的更多详情可参考<a href="http://lijiancheng0614.github.io/scikit-learn/modules/generated/sklearn.grid_search.GridSearchCV.html">官方文档</a>。</p><p>最后基于好奇，使用最优参数的决策树到底是什么样呢？我们可以使用 <code>sklearn.tree.export_graphviz()</code> 函数把决策树模型导出到文件中，然后使用<code>graphviz</code>工具包生成决策树示意图。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.tree <span class="keyword">import</span> export_graphviz</span><br><span class="line"></span><br><span class="line">columns = train.columns[<span class="number">1</span>:]</span><br><span class="line"><span class="comment"># 导出 titanic.dot 文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">"E:/titanic.dot"</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f = export_graphviz(clf, out_file=f,feature_names=columns)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. conda安装 graphviz ：conda install python-graphviz </span></span><br><span class="line"><span class="comment"># 2. 运行 `dot -Tpdf titanic.dot -o titanic.pdf` </span></span><br><span class="line"><span class="comment"># 3. 在当前目录查看生成的决策树 titanic.png</span></span><br></pre></td></tr></tbody></table></figure><p>最优参数的决策树就长这个样子</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630185703496.png" alt="image-20200630185703496"></p><hr><h2 id="5-集合算法"><a href="#5-集合算法" class="headerlink" title="5.集合算法"></a>5.集合算法</h2><p>集合算法（Ensemble）是一种元算法（Meta-algorithm），它利用统计学采样原理，训练出成百上千个不同的算法模型。当需要预测一个新样本时，使用这些模型分别对这个样本进行预测，然后采样少数服从多数的原则，决定新样本的类别。集合算法可以有效地解决过拟合问题。在scikit-learn 里，所有的集合算法都实现在<code>sklearn.ensemble</code>包里。</p><h3 id="5-1-自助聚合算法Bagging"><a href="#5-1-自助聚合算法Bagging" class="headerlink" title="5.1 自助聚合算法Bagging"></a>5.1 自助聚合算法Bagging</h3><p>自助聚合（Bagging，Bootstrap Aggregating的缩写）的核心思想是，采用有放回的采样规则，从m个样本的原数据集里进行n次采样（n&lt;=m），构成一个包含n个样本的新训练数据集。重复这个过程B次，得到B个模型，当有新样本需要预测时，拿这B个模型分别对这个样本进行预测，然后采用投票方式（回归问题）得到新样本的预测值。</p><p>所谓的有放回采样规则是指，在m个数据集里，随机取出一个样本放到新数据集里，然后把这个样本放回到原数据集里，继续随机采样，直到到达采样次数n为止。由此可见，随机采样出的数据集里可能有重复数据，并且原数据集的每一个数据不一定都出现在新数据集里。</p><p>单一模型往往容易对数据噪声敏感，从而造成高方差（High Variance）。自助聚合算法可以降低对数据噪声的敏感性，从而提高模型准确性和稳定性。这种方法不需要额外的输入，只是简单地对同一个数据集训练出多个模型即可实现。当然这并不是说没有代价，自助聚合算法一般会增加模型训练的计算量。</p><p>在<code>scikit-learn</code>里，由<code>BaggingClassifier</code>类和B<code>aggingRegressor</code>类分别实现了分类和回归的Bagging算法。</p><h3 id="5-2-正向激励算法Boosting"><a href="#5-2-正向激励算法Boosting" class="headerlink" title="5.2 正向激励算法Boosting"></a>5.2 正向激励算法Boosting</h3><p>正向激励算法（Boosting）的基本原理是，初始化时，针对有m个训练样本的数据集，给每个样本都分配一个初始权重，然后使用这个带有权重的数据集来训练模型。训练出模型之后，针对这个模型预测错误的那些样本，增加其权重，然后拿这个更新过权重的数据集来训练出一个新的模型。重复这个过程B次，就可以训练出B个模型。</p><p>Boosting算法和Bagging算法的区别如下：</p><ul><li>采样规则不同：Bagging算法是采样有放回的随机采样规则。而Boosting算法是使用增加预测错误样本权重的方法，相当于加强了对预测错误的样本的学习力度，从而提高模型的准确性。</li><li>训练方式不同：Bagging算法可以并行训练多个模型。而Boosting算法只能串行训练，因为下一个模型依赖上一个模型的预测结果。</li><li>模型权重不同：Bagging算法训练出来的B个模型的权重是一样的。而Boosting算法训练出来的B个模型本身带有权重信息，在对新样本进行预测时，每个模型的权重是不一样的。单个模型的权重由模型训练的效果来决定，即准确性高的模型权重更高。</li></ul><p>Boosting算法有很多种实现，其中最著名的是 <code>AdaBoosting</code> 算法。在 <code>scikit-learn</code> 里由<code>AdaBoostingClassifier</code>类和 <code>AdaBoostingRegression</code>类分别实现Boosting分类和Boosting回归。</p><h3 id="5-3-随机森林"><a href="#5-3-随机森林" class="headerlink" title="5.3 随机森林"></a>5.3 随机森林</h3><p>随机森林（RF，Random Forest）在自助聚合算法（Bagging）的基础上更进一步，对特征应用自助聚合算法。即，每次训练时，不拿所有的特征来训练，而是随机选择一个特征的子集来进行训练。随机森林算法有两个关键参数，一是构建的决策树的个数t，二是构建单棵决策树特征的个数f。</p><p>假设，针对一个有m个样本、n个特征的数据集，则其算法原理如下：</p><h4 id="单棵决策树的构建"><a href="#单棵决策树的构建" class="headerlink" title="单棵决策树的构建"></a>单棵决策树的构建</h4><ul><li>采用有放回采样，从原数据集中经过m次采样，获取到一个m个样本的数据集（这个数据集里可能有重复的样本）</li><li>从n个特征里，采用无放回采样规则，从中取出f个特征作为输入特征。</li><li>重复上述过程t次，构建出t棵决策树。</li></ul><h4 id="随机森林的分类结果"><a href="#随机森林的分类结果" class="headerlink" title="随机森林的分类结果"></a>随机森林的分类结果</h4><p> 生成t棵决策树之后，对于每个新的测试样例，集合多棵决策树的预测结果来作为随机森林的预测结果。具体为，如果是回归问题，取t棵决策树的预测值的平均值作为随机森林的预测结果；如果是分类问题，采取少数服从多数的原则，取单棵决策树预测最多的那个类别作为随机森林的分类结果。</p><blockquote><p>思考：为什么随机森林要选取特征的子集来构建决策树？</p></blockquote><p> 假如某个输入特征对预测结果是强关联的，那么如果选择全部的特征来构建决策树，这个特征都会体现在所有的决策树里面。由于这个特征和预测结果强关联，会造成所有的决策树都强烈地反映这个特征的“倾向性”，从而导致无法很好地解决过拟合问题。我们在讨论线性回归算法时，通过增加正则项来解决过拟合，它的原理就是确保每个特征都对预测结果有少量的贡献，从而避免单个特征对预测结果有过大贡献导致的过拟合问题。这里的原理是一样的。</p><p>在 <code>scikit-learn</code> 里由 <code>RandomForestClassifier</code> 类和 <code>RandomForestRegression</code> 类分别实现随机森林的分类算法和随机森林的回归算法。</p><h3 id="5-4-ExtraTrees算法"><a href="#5-4-ExtraTrees算法" class="headerlink" title="5.4 ExtraTrees算法"></a>5.4 ExtraTrees算法</h3><p>ExtraTrees，叫做极限树或者极端随机树。随机森林在构建决策树的过程中，会使用信息熵或者基尼不纯度，然后选择信息增益最大的特征来进行分裂。而 <code>ExtraTrees</code> 是直接从所有特征里随机选择一个特征来分裂，从而避免了过拟合问题。</p><p>在<code>scikit-learn</code>里，由<code>ExtraTreesClassifier</code>类和 <code>ExtraTreesRegression</code> 类分别实现 <code>ExtraTrees</code> 的分类算法和 ExtraTrees 的回归算法。</p><hr><h2 id="6-扩展阅读"><a href="#6-扩展阅读" class="headerlink" title="6. 扩展阅读"></a>6. 扩展阅读</h2><h3 id="6-1-熵和条件熵"><a href="#6-1-熵和条件熵" class="headerlink" title="6.1 熵和条件熵"></a>6.1 熵和条件熵</h3><p>在决策树创建过程中，我们会计算以某个特征创建分支后的子数据集的信息熵。用数学语言描述实际上是计算条件熵，即满足某个条件的信息熵。</p><p>关于信息熵和条件熵的相关概念，可以阅读吴军老师的<a href="https://baike.baidu.com/item/%E6%95%B0%E5%AD%A6%E4%B9%8B%E7%BE%8E/1580521?fr=aladdin">《数学之美》</a>里”信息的度量和作用”一文。《数学之美》这本书，吴军老师用平实的语言，把复杂的数学概念解释的入木三分，即使你只有高中的数学水平，也可以领略到数学的“优雅”和“威力”。</p><h3 id="6-2-决策树的构建算法"><a href="#6-2-决策树的构建算法" class="headerlink" title="6.2 决策树的构建算法"></a>6.2 决策树的构建算法</h3><p>本文重点介绍的决策树构建算法是ID3算法，它是1986年由Ross Quinlan提出的。1993年，该算法作者发布了新的决策树构建算法C4.5，作为ID3算法的改进，主要体现在：</p><ul><li>增加了对连续值的处理，方法是使用一个阈值作为连续值的划分条件，从而把数据离散化。</li><li>自动处理特征值缺失问题，处理方法是直接把这个特征抛弃，不参与计算信息增益比。</li><li>使用信息增益比作为特征选择标准。</li><li>采用后剪枝算法处理过拟合，即在决策树创建完成之后，再通过合并叶子节点的方式进行剪枝。</li></ul><p>此后，该算法作者又发布了改进的商业版本C5.0，它运算效率更高，使用内存更小，创建出来的决策树更小，并且准确性更高，适合大数据集的决策树构建。</p><p>除了前面介绍的使用基尼不纯度来构建决策树的CART算法之外，还有其他知名的决策树构建算法，如CHAID算法、MARS算法等。这里不再详述。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列四：逻辑回归</title>
      <link href="/2020/06/30/scikit-learn-xi-lie-si-luo-ji-hui-gui/"/>
      <url>/2020/06/30/scikit-learn-xi-lie-si-luo-ji-hui-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="1-Logistic-回归概述"><a href="#1-Logistic-回归概述" class="headerlink" title="1. Logistic 回归概述"></a>1. Logistic 回归概述</h2><p>Logistic 回归 或者叫逻辑回归，虽然名字有回归，但是它是用来做分类的。其主要思想是: 根据现有数据对分类边界线 (Decision Boundary) 建立回归公式，以此进行分类。</p><h2 id="2-算法原理"><a href="#2-算法原理" class="headerlink" title="2. 算法原理"></a>2. 算法原理</h2><p>假设有一场足球赛，我们有两支球队的所有出场球员信息、历史交锋成绩、比赛时间、主客场、裁判和天气等信息，根据这些信息预测球队的输赢。假设比赛结果记为y，赢球标记为1，输球标记为0，这就是典型的二元分类问题，可以用逻辑回归算法来解决。</p><p>与线性回归算法的最大区别是，逻辑回归算法的输出是个离散值。</p><h3 id="2-1-预测函数"><a href="#2-1-预测函数" class="headerlink" title="2.1 预测函数"></a>2.1 预测函数</h3><p>需要找出一个预测函数模型，使其值输出在[0,1]之间。然后选择一个基准值，如0.5，如果算出来的预测值大于0.5，就认为其预测值为1，反之，则其预测值为0。</p><p>选择Sigmoid函数（也称为Logistic函数，逻辑回归的名字由此而来）<br>$$<br>g(z)=\frac{1}{1+e^{-z}}<br>$$<br>来作为预测函数，其中e是自然对数的底数。以z为横坐标，以g(z)为纵坐标，画出的图形如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/LR_3.png" alt="Sigmoid 函数在不同坐标下的图片"></p><p>从图中可以看出，当z=0时，g(z)=0.5；当z&gt;0时，g(z)&gt;0.5，当z越来越大时，g(z)无限接近于1；当z&lt;0时，g(z)&lt;0.5，当z越来越小时，g(z)无限接近于0。这正是我们想要的针对二元分类算法的预测函数。</p><h3 id="2-2-判定边界"><a href="#2-2-判定边界" class="headerlink" title="2.2 判定边界"></a>2.2 判定边界</h3><p>逻辑回归算法的预测函数由下面两个公式给出：<br>$$<br>h_{\theta}(x)=g\left(\theta^{T} x\right)<br>$$</p><p>$$<br>g(z)=\frac{1}{1+e^{-z}}<br>$$</p><p>下面给出两个判定边界的例子。假设有两个变量x1，x2，其逻辑回归预测函数是$h_{\theta}(x)=g\left(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}\right)$</p><p>假设给定参数：<br>$$<br>\theta=\left[\begin{array}{c}<br>-3 \<br>1 \<br>1<br>\end{array}\right]<br>$$<br>那么，可以得到判定边$-3+x_{1}+x_{2}=0$ ，如果以 $x_{1}$ 为横坐标， $x_{2}$  为纵坐标，则这个函数画出来就是一条通过(0,3)和(3,0)两点的直线。这条线就是判定边界，其中，直线左下方为y=0，直线右上方为y=1，如图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-0bf913a36c2847a8.png" alt="img"></p><p>如果预测函数是多项式 $h_{\theta}(x)=g\left(\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\theta_{3} x_{1}^{2}+\theta_{4} x_{2}^{2}\right)$，且给定</p><p>$$<br>\theta=\left[\begin{array}{c}<br>-1 \<br>0 \<br>0 \<br>1 \<br>1<br>\end{array}\right]<br>$$<br>则可以得到判定边界函数$x_{1}^{2}+x_{2}^{2}=1$ 则这是一个半径为1的圆。圆内部是y=0，圆外部是y=1，如上图所示。</p><h3 id="2-3-损失函数"><a href="#2-3-损失函数" class="headerlink" title="2.3 损失函数"></a>2.3 损失函数</h3><p>我们不能使用线性回归模型的损失函数来推导逻辑回归的损失函数，因为那样的损失函数太复杂，最终很可能会导致无法通过迭代找到损失函数值最小的点。</p><p>为了容易地求出损失函数的最小值，我们分成 y=1 和 y=0 两种情况来分别考虑其预测值和真实值的误差。我们先考虑最简单的情况，即计算某个样本 x，y=1 和 y=0 两种情况下的预测值与真实值的误差，我们选择的损失公式如下：</p><p>$\operatorname{cost}\left(h_{\theta}(x), y\right)=\left{\begin{array}{ccc}-\log \left(h_{\theta}(x)\right), &amp; \text { if } &amp; y=1 \ -\log \left(1-h_{\theta}(x)\right), &amp; \text { if } &amp; y=0\end{array}\right.$</p><p>其中， $h_{\theta}(x)$ 表示预测为1的概率，log(x)为自然对数。如图所示</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630141514106.png" alt="img"></p><p>根据损失函数的定义，损失是预测值与真实值的差异。当差异越大时，损失越大，模型受到的“惩罚”也越严重。在左图中，当 y=1 时，随着（预测为1的概率）越来越大，预测值越来越接近真实值，其损失越来越小；在右图中，当 y=0 时，随着（预测为1的概率）越来越大，预测值越来越偏离真实值，其损失越来越大。</p><h3 id="2-4-梯度下降算法"><a href="#2-4-梯度下降算法" class="headerlink" title="2.4 梯度下降算法"></a>2.4 梯度下降算法</h3><p>和线性回归类似，这里使用梯度下降算法来求解逻辑回归模型参数。具体可见上一节 <a href="https://dongzhougu.github.io/2020/06/30/scikit-learn-xi-lie-san-xian-xing-hui-gui/">线性回归回归算法</a>。</p><h2 id="3-多元分类"><a href="#3-多元分类" class="headerlink" title="3. 多元分类"></a>3. 多元分类</h2><p>逻辑回归模型可以解决二元分类问题，即 y={0,1}，能不能解决多元分类问题呢？答案是肯定的。针对多元分类问题，y={0,1,2,3,…,n}，总共有n+1个类别。其解决思路是：首先把问题转换为二元分类问题，即y=0是一个类别，y={1,2,3,…,n}作为另外一个类别，然后计算这两个类别的概率；接着，把y=1作为一个类别，把y={0,2,3,…,n}作为另外一个类别，再计算这两个类别的概率。</p><h2 id="4-正则化"><a href="#4-正则化" class="headerlink" title="4. 正则化"></a>4. 正则化</h2><p>我们知道，过拟合是指模型很好地拟合了训练样本，但对新数据预测的准确性很差，这是因为模型太复杂了。解决办法是减少输入特征的个数，或者获取更多的训练样本。这里介绍的正则化也可以用来解决过拟合问题：</p><ul><li><p>保留所有的特征，减少特征的权重 $\theta_{j} $ 的值。确保所有的特征对预测值都有少量的贡献。</p></li><li><p>当每个特征 $x_{j} $ 对预测值y都有少量的贡献时，这样的模型可以良好的工作，这正是正则化的目的，可以用它来解决特征过多时的过拟合问题。</p></li></ul><h3 id="4-1-线性回归模型正则化"><a href="#4-1-线性回归模型正则化" class="headerlink" title="4.1 线性回归模型正则化"></a>4.1 线性回归模型正则化</h3><p>我们先来看线性回归模型的损失函数是如何正则化的：<br>$$<br>J(\theta)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}+\lambda \sum_{j=1}^{n} \theta_{j}^{2}<br>$$<br>公式中前半部分就是原来的线性回归模型的损失函数，也称为预测值与实际值的误差。后半部分为加入的正则项。其中 $\lambda $ 的值有两个目的，即要维持对训练样本的拟合，又要避免对训练样本的过拟合。如果  $\lambda $  的值太大，则能确保不出现过拟合，但可能会导致对现有训练样本出现欠拟合。</p><h3 id="4-2-线性回归模型正则化"><a href="#4-2-线性回归模型正则化" class="headerlink" title="4.2 线性回归模型正则化"></a>4.2 线性回归模型正则化</h3><p>同样，可以对逻辑回归模型的损失函数进行正则化，其方法也是在原来的损失函数的基础上加上正则项：<br>$$<br>J(\theta)=-\frac{1}{m}\left[\sum_{i=1}^{m} y^{(i)} \log \left(h_{\theta}\left(x^{(i)}\right)\right)+\left(1-y^{(i)}\right) \log \left(1-h_{\theta}\left(x^{(i)}\right)\right)\right]+\frac{\lambda}{2 m} \sum_{j=1}^{n} \theta_{j}^{2}<br>$$</p><h2 id="5-算法参数"><a href="#5-算法参数" class="headerlink" title="5. 算法参数"></a>5. 算法参数</h2><p>在 <code>scikit-learn</code>里，逻辑回归模型由类 <code>sklearn.linear_model.LogisticRegression</code>实现。</p><h3 id="5-1-正则项权重"><a href="#5-1-正则项权重" class="headerlink" title="5.1 正则项权重"></a>5.1 正则项权重</h3><p>上面介绍的正则项权重  $\lambda $  ，在<code>LogisticRegression</code>类里有个参数 C 与之对应，但成反比。即 C 值越大，  $\lambda $ 越小，模型容易出现过拟合；C 值越小，  $\lambda $  越大，模型容易出现欠拟合。</p><h3 id="5-2-L1-L2范数"><a href="#5-2-L1-L2范数" class="headerlink" title="5.2 L1/L2范数"></a>5.2 L1/L2范数</h3><p>创建逻辑回归模型时，有个参数penalty（惩罚），其取值有“l1”或“l2”</p><ul><li>L1范数作为正则项，会让模型参数 $\theta$ 稀疏化，即让模型参数向量里的0元素尽可能多，只保留模型参数向量中重要特征的贡献。</li><li>L2范数作为正则项，则让模型参数尽量小，但不会为0，即尽量让每个特征对应预测值都有一些小的贡献。</li></ul><p>假设模型只有两个参数，它们构成一个二维向量 $\theta=\left[\theta_{1}, \theta_{2}\right]$,则L1范数为：</p><p>$|\theta|<em>{1}=\left|\theta</em>{1}\right|+\left|\theta_{2}\right|$</p><p>即L1范数是向量里元素的绝对值之和。L2范数为向量里所有元素的平方和的算术平方根：</p><p>$|\theta|<em>{2}=\sqrt{\theta</em>{1}^{2}+\theta_{2}^{2}}$</p><p>我们知道，梯度下降算法在参数迭代的过程中，实际上是在损失函数的等高线上跳跃，并最终收敛在误差最小的点上。那么正则项的本质是什么？正则项的本质是惩罚。在参数迭代的过程中，如果没有遵循正则项所表达的规则，那么其损失会变大，即受到了惩罚，从而往正则项所表达的规则处收敛。正则化后的模型参数应该收敛在误差等高线与正则项等高线相切的点上。</p><p>作为推论，L1范数作为正则项，有以下几个用途：</p><ul><li>选择重要特征：L1范数会让模型参数向量里的元素为0的点尽量多，这样可以排除掉那些对预测值没有什么影响的特征，从而简化问题。所以L1范数解决过拟合，实际上是减少特征数量。</li><li>模型可解释性好：模型参数向量稀疏化后，只会留下那些对预测值有重要影响的特征。这样我们就容易解释模型的因果关系。比如，针对某种癌症的筛查，如果有100个特征，那么我们无从解释到底哪些特征对阳性呈关键作用。稀疏化后，只留下几个关键的特征，就容易看到因果关系。</li></ul><p>由此可见，L1范数作为正则项，更多的是一个分析工具，而适合用来对模型求解。因为它会把不重要的特征直接去除。大部分的情况下解决过拟合问题，还是选择L2范数作为正则项，这也是 <code>scikit-learn</code> 里的默认值。</p><h2 id="6-示例：乳腺癌检测"><a href="#6-示例：乳腺癌检测" class="headerlink" title="6 示例：乳腺癌检测"></a>6 示例：乳腺癌检测</h2><p>本节来看一个实例，使用逻辑回归算法解决乳腺癌检测问题。我们需要先采集肿瘤病灶造影图片，然后对图片进行分析，从图片中提取特征，再根据特征来训练模型。最终使用模型来检测新采集到的肿瘤病灶造影，以便判断肿瘤是良性的还是恶性的。这是个典型的二元分类问题。</p><h3 id="6-1-数据采集及特征提取"><a href="#6-1-数据采集及特征提取" class="headerlink" title="6.1 数据采集及特征提取"></a>6.1 数据采集及特征提取</h3><p>为了简单起见，直接加载 <code>scikit-learn</code> 自带的一个乳腺癌数据集。这个数据集是已经采集后的数据：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_breast_cancer</span><br><span class="line">cancer = load_breast_cancer()</span><br><span class="line">X = cancer.data</span><br><span class="line">y = cancer.target</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'data shape: {0}; no. positive: {1}; no. negative: {2}'</span></span><br><span class="line">      .<span class="built_in">format</span>(X.shape,y[y==<span class="number">1</span>].shape[<span class="number">0</span>],y[y==<span class="number">0</span>].shape[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(cancer.data[<span class="number">0</span>])</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">data shape: (<span class="number">569</span>, <span class="number">30</span>); no. positive: <span class="number">357</span>; no. negative: <span class="number">212</span></span><br><span class="line">[<span class="number">1.799e+01</span> <span class="number">1.038e+01</span> <span class="number">1.228e+02</span> <span class="number">1.001e+03</span> <span class="number">1.184e-01</span> <span class="number">2.776e-01</span> <span class="number">3.001e-01</span></span><br><span class="line"> <span class="number">1.471e-01</span> <span class="number">2.419e-01</span> <span class="number">7.871e-02</span> <span class="number">1.095e+00</span> <span class="number">9.053e-01</span> <span class="number">8.589e+00</span> <span class="number">1.534e+02</span></span><br><span class="line"> <span class="number">6.399e-03</span> <span class="number">4.904e-02</span> <span class="number">5.373e-02</span> <span class="number">1.587e-02</span> <span class="number">3.003e-02</span> <span class="number">6.193e-03</span> <span class="number">2.538e+01</span></span><br><span class="line"> <span class="number">1.733e+01</span> <span class="number">1.846e+02</span> <span class="number">2.019e+03</span> <span class="number">1.622e-01</span> <span class="number">6.656e-01</span> <span class="number">7.119e-01</span> <span class="number">2.654e-01</span></span><br><span class="line"> <span class="number">4.601e-01</span> <span class="number">1.189e-01</span>]</span><br></pre></td></tr></tbody></table></figure><p>数据集中总共有569个样本，每个样本有30个特征，其中357个阳性（y=1）样本，212个阴性（y=0）样本。同时，还打印出一个样本数据，以便直观地进行观察。</p><p>这30个特征是怎么来的呢？这个数据集总共从病灶造影图片中提取了以下10个关键属性：</p><ul><li>radius：半径，即病灶中心点离边界的平均距离。</li><li>texture：纹理，灰度值的标准偏差。</li><li>perimeter：周长，即病灶的大小。</li><li>area：面积，也是反映病灶大小的一个指标。</li><li>smoothness：平滑度，即半径的变化幅度。</li><li>compactness：密实度，周长的平方除以面积，再减去1</li><li>concavity：凹度，凹陷部分轮廓的严重程度。</li><li>concave points：凹点，凹陷轮廓的数量。</li><li>symmetry：对称性。</li><li>fractal demension：分形维度。</li></ul><p>实际上它只关注10个特征，然后又构造出了每个特征的标准差及最大值，这样每个特征就衍生出了两个特征，所以总共就有了30个特征。可以通过 <code>cancer.feature_names</code> 变量来查看这些特征的名称。</p><h3 id="6-2-模型训练"><a href="#6-2-模型训练" class="headerlink" title="6.2 模型训练"></a>6.2 模型训练</h3><p>首先，把数据集分成训练数据集和测试数据集：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,y_train,y_test = train_test_split(X,y,test_size=<span class="number">0.2</span>)</span><br></pre></td></tr></tbody></table></figure><p>然后使用 <code>LogisticRegression</code> 模型来训练，并计算训练数据集的评分数据和测试数据集的评分数据：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line">model = LogisticRegression()</span><br><span class="line">model.fit(X_train,y_train)</span><br><span class="line">train_score = model.score(X_train,y_train)</span><br><span class="line">test_score = model.score(X_test,y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'train score: {train_score:.6f}; test_score:{test_score:.6f}'</span></span><br><span class="line">      .<span class="built_in">format</span>(train_score=train_score,</span><br><span class="line">             test_score=test_score))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">train score: <span class="number">0.940659</span>; test_score:<span class="number">0.964912</span></span><br></pre></td></tr></tbody></table></figure><p>观察模型在测试样本集的表现：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">y_pred = model.predict(X_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'matchs: {0}/{1}'</span>.<span class="built_in">format</span>(np.equal(y_pred,y_test).shape[<span class="number">0</span>],y_test.shape[<span class="number">0</span>]))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matchs: <span class="number">114</span>/<span class="number">114</span></span><br></pre></td></tr></tbody></table></figure><p>总共114个测试样本，全部预测正确。为什么 <code>testscore</code> 却只有0.973684，而不是1呢？答案是，<code>scikit-learn</code>不是使用这个数据来计算分数，因为这个数据不能完全反映误差情况，而是使用预测概率数据计算模型评分。</p><p>针对二元分类问题，<code>LogisticRegression</code>模型会对每个样本输出两个概率，即为 0 的概率和为 1 的概率，哪个概率高就预测为哪个类别。</p><p>找出测试数据集中预测“自信度”低于90%的样本。这里先计算出测试数据集里的每个样本的预测概率数据，针对每个样本，它会有两个数据，一是预测其为阳性的概率，另外一个是预测其为阴性的概率。接着找出预测为阴性的概率大于0.1且小于0.9的样本（同时也是预测为阳性的概率大于0.1小于0.9），这些样本就是“自信度”不足90%的样本。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预测概率：找出预测概率低于 90% 的样本</span></span><br><span class="line">y_pred_proba = model.predict_proba(X_test)  <span class="comment"># 计算每个测试样本的预测概率</span></span><br><span class="line"><span class="comment"># 找出第一列，即预测为阴性的概率大于 0.1 的样本，保存在 result 里</span></span><br><span class="line">y_pred_proba_0 = y_pred_proba[:, <span class="number">0</span>] &gt; <span class="number">0.1</span></span><br><span class="line">result = y_pred_proba[y_pred_proba_0]</span><br><span class="line"><span class="comment"># 在 result 结果集里，找出第二列，即预测为阳性的概率大于 0.1 的样本</span></span><br><span class="line">y_pred_proba_1 = result[:, <span class="number">1</span>] &gt; <span class="number">0.1</span></span><br><span class="line"><span class="built_in">print</span>(result[y_pred_proba_1])</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">0.29623162</span> <span class="number">0.70376838</span>]</span><br><span class="line"> [<span class="number">0.54660262</span> <span class="number">0.45339738</span>]</span><br><span class="line"> [<span class="number">0.17874247</span> <span class="number">0.82125753</span>]</span><br><span class="line"> [<span class="number">0.20917573</span> <span class="number">0.79082427</span>]</span><br><span class="line"> [<span class="number">0.10943452</span> <span class="number">0.89056548</span>]</span><br><span class="line"> [<span class="number">0.35503614</span> <span class="number">0.64496386</span>]</span><br><span class="line"> [<span class="number">0.23849987</span> <span class="number">0.76150013</span>]</span><br><span class="line"> [<span class="number">0.13634228</span> <span class="number">0.86365772</span>]</span><br><span class="line"> [<span class="number">0.80171734</span> <span class="number">0.19828266</span>]</span><br><span class="line"> [<span class="number">0.21744759</span> <span class="number">0.78255241</span>]</span><br><span class="line"> [<span class="number">0.81346356</span> <span class="number">0.18653644</span>]</span><br><span class="line"> [<span class="number">0.2225791</span>  <span class="number">0.7774209</span> ]</span><br><span class="line"> [<span class="number">0.10788007</span> <span class="number">0.89211993</span>]</span><br><span class="line"> [<span class="number">0.88068005</span> <span class="number">0.11931995</span>]</span><br><span class="line"> [<span class="number">0.18189724</span> <span class="number">0.81810276</span>]]</span><br></pre></td></tr></tbody></table></figure><p>由此可见，计算预测概率使用model.predict_proba()函数，而计算预测分类用model.predict()函数。</p><h3 id="6-3-模型优化"><a href="#6-3-模型优化" class="headerlink" title="6.3 模型优化"></a>6.3 模型优化</h3><p>首先，使用Pipeline来增加多项式特征：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加多项式预处理</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">polynomial_model</span>(<span class="params">degree=<span class="number">1</span>, **kwarg</span>):</span></span><br><span class="line">    polynomial_features = PolynomialFeatures(degree=degree,</span><br><span class="line">                                             include_bias=<span class="literal">False</span>)</span><br><span class="line">    logistic_regression = LogisticRegression(**kwarg)</span><br><span class="line">    pipeline = Pipeline([(<span class="string">"polynomial_features"</span>, polynomial_features),</span><br><span class="line">                         (<span class="string">"logistic_regression"</span>, logistic_regression)])</span><br><span class="line">    <span class="keyword">return</span> pipeline</span><br></pre></td></tr></tbody></table></figure><p>接着，增加二阶多项式特征，创建并训练模型：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">model = polynomial_model(degree=<span class="number">2</span>, penalty=<span class="string">'l1'</span>, solver=<span class="string">'liblinear'</span>)</span><br><span class="line">start = time.process_time()</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line">train_score = model.score(X_train, y_train)</span><br><span class="line">test_score = model.score(X_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'elaspe: {0:.6f}; train_score: {1:0.6f}; cv_score: {2:.6f}'</span>.<span class="built_in">format</span>(</span><br><span class="line">    time.process_time() - start, train_score, test_score))</span><br></pre></td></tr></tbody></table></figure><p>使用L1范数作为正则项（参数penalty=’l1’），输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elaspe: <span class="number">0.156250</span>; train_score: <span class="number">1.000000</span>; cv_score: <span class="number">0.956140</span></span><br></pre></td></tr></tbody></table></figure><p>可以看到，训练数据集评分和测试数据集评分都增加了。为什么使用L1范数作为正则项呢？L1范数作为正则项可以实现参数的稀疏化，即自动选择出那些对模型有关联的重要特征。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logistic_regression = model.named_steps[<span class="string">'logistic_regression'</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'model parameters shape: {0}; count of non-zero element: {1}'</span>.<span class="built_in">format</span>(</span><br><span class="line">    logistic_regression.coef_.shape, </span><br><span class="line">    np.count_nonzero(logistic_regression.coef_)))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model parameters shape: (<span class="number">1</span>, <span class="number">495</span>); count of non-zero element: <span class="number">110</span></span><br></pre></td></tr></tbody></table></figure><p>逻辑回归模型的coef_属性里保存的就是模型参数。从输出结果可以看到，增加二阶多项式特征后，输入特征由原来的30个增加到了495个，最终大多数特征都被丢弃，只保留了110个有效特征。</p><h3 id="6-4-学习曲线"><a href="#6-4-学习曲线" class="headerlink" title="6.4 学习曲线"></a>6.4 学习曲线</h3><p>首先画出使用L1范数作为正则项所对应的一阶和二阶多项式的学习曲线：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> plot_learning_curve</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ShuffleSplit</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">cv = ShuffleSplit(n_splits=<span class="number">10</span>, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line">title = <span class="string">'Learning Curves (degree={0}, penalty={1})'</span></span><br><span class="line">degrees = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">penalty = <span class="string">'l1'</span></span><br><span class="line"></span><br><span class="line">start = time.process_time()</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">4</span>), dpi=<span class="number">144</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(degrees)):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="built_in">len</span>(degrees), i + <span class="number">1</span>)</span><br><span class="line">    plot_learning_curve(plt, polynomial_model(degree=degrees[i], penalty=penalty, solver=<span class="string">'liblinear'</span>, max_iter=<span class="number">300</span>), </span><br><span class="line">                        title.<span class="built_in">format</span>(degrees[i], penalty), X, y, ylim=(<span class="number">0.8</span>, <span class="number">1.01</span>), cv=cv)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'elaspe: {0:.6f}'</span>.<span class="built_in">format</span>(time.process_time()-start))</span><br></pre></td></tr></tbody></table></figure><p>输出的结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l1_elaspe: <span class="number">10.781250</span></span><br></pre></td></tr></tbody></table></figure><p>L1范数学习曲线如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-08d8944e88c2ae64.png" alt="image-20200630141514106"></p><p>接着画出使用L2范数作为正则项所对应的一阶和二阶多项式的学习曲线：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">"ignore"</span>)</span><br><span class="line"></span><br><span class="line">penalty = <span class="string">'l2'</span></span><br><span class="line"></span><br><span class="line">start = time.clock()</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>, <span class="number">4</span>), dpi=<span class="number">144</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(degrees)):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="built_in">len</span>(degrees), i + <span class="number">1</span>)</span><br><span class="line">    plot_learning_curve(plt, polynomial_model(degree=degrees[i], penalty=penalty, solver=<span class="string">'lbfgs'</span>), </span><br><span class="line">                        title.<span class="built_in">format</span>(degrees[i], penalty), X, y, ylim=(<span class="number">0.8</span>, <span class="number">1.01</span>), cv=cv)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">'elaspe: {0:.6f}'</span>.<span class="built_in">format</span>(time.clock()-start))</span><br></pre></td></tr></tbody></table></figure><p>输出的结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">l2_elaspe: <span class="number">2.718750</span></span><br></pre></td></tr></tbody></table></figure><p>L2范数学习曲线如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630141743010.png" alt="image-20200630141743010"></p><p>可以明显地看出，使用二阶多项式并使用L1范数作为正则项的模型最优，因为它的训练样本评分最高，交叉验证样本评分也最高。从图中还可以看出，训练样本评分和交叉验证样本评分之间的间隙还比较大，我们可以采集更多的数据来训练模型，以便进一步优化模型。</p><p>另外从输出的时间可以看出，L1 范数对应的学习曲线，需要花费较长的时间，原因是，<code>scikit-learn</code> 的<code>learning_curve()</code> 函数在画学习曲线的过程中，要对模型进行多次训练，并计算交叉验证样本评分。同时，为了使曲线更平滑，针对每个点还会进行多次计算求平均值。这个就是 <code>ShuffleSplit</code> 类的作用。在我们这个实例里，只有569个训练样本，这是个很小的数据集。如果数据集增加100倍，甚至1000倍，拿出来画学习曲线将是场灾难。</p><p>那么，针对大数据集，怎样高效地画学习曲线？答案很简单，可以从大数据集里选择一小部分数据来画学习曲线，待选择好最优的模型之后，再使用全部的数据集来训练模型。但是要尽量保持选择出来的这部分数据的标签分布与大数据集的标签分布相同，如针对二元分类，阳性和阴性比例要一致。更直观的说就是，抽取出来的样本集为原来数据集的一个缩影，尽可能相似。</p><h2 id="7-拓展阅读"><a href="#7-拓展阅读" class="headerlink" title="7.拓展阅读"></a>7.拓展阅读</h2><p>实际上，我们的预测函数就是写成向量形式的：<br>$$<br>h_{\theta}(x)=g(z)=g\left(\theta^{T} x\right)=\frac{1}{1+e^{-\theta^{T} x}}<br>$$<br>这个预测函数一次只计算一个训练样本的预测值，怎样一次性计算出所有样本的预测值呢？答案是把预测函数的参数写成向量的形式：<br>$$<br>h=g(X \theta)<br>$$<br>其中g(x)为Sigmoid函数。X为m×n的矩阵，即数据集的矩阵表达。损失函数也有对应的矩阵形式：<br>$$<br>J(\theta)=\frac{1}{m}\left(-y^{T} \log (h)-(1-y)^{T} \log (1-h)\right)<br>$$<br>其中，y为目标值向量，h为一次性计算出来的所有样本的预测值。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列三：线性回归</title>
      <link href="/2020/06/30/scikit-learn-xi-lie-san-xian-xing-hui-gui/"/>
      <url>/2020/06/30/scikit-learn-xi-lie-san-xian-xing-hui-gui/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml">传送门</a>，欢迎 star 和 fork ！</h2><h1 id="线性回归算法"><a href="#线性回归算法" class="headerlink" title="线性回归算法"></a>线性回归算法</h1><p>线性回归算法是使用线性方程对数据集拟合的算法，本文从单变量线性回归算法、多变量线性回归算法，其中损失函数以及梯度下降算法的推导过程会用到部分线性代数和偏导数；接着重点介绍了梯度下降算法的求解步骤以及性能优化方面的内容；最后通过一个房价预测模型，介绍了线性回归算法性能优化的一些常用步骤和方法。</p><h2 id="线性回归概述"><a href="#线性回归概述" class="headerlink" title="线性回归概述"></a>线性回归概述</h2><p>说到回归，一般都是指 <code>线性回归(linear regression)</code>。线性回归意味着可以将输入项分别乘以一些常量，再将结果加起来得到输出。回归的目的是预测数值型的目标值，最直接的办法是依据输入写出一个目标值的计算公式。</p><p>假如你想要预测兰博基尼跑车的功率大小，可能会这样计算:</p><blockquote><p>HorsePower = 0.0015 * annualSalary - 0.99 * hoursListeningToPublicRadio</p></blockquote><p>这就是所谓的 <code>回归方程(regression equation)</code>，其中的 0.0015 和 -0.99 称作 <code>回归系数（regression weights）</code>，求这些回归系数的过程就是回归。一旦有了这些回归系数，再给定输入，做预测就非常容易了。具体的做法是用回归系数乘以输入值，再将结果全部加在一起，就得到了预测值。我们这里所说的，回归系数是一个向量，输入也是向量，这些运算也就是求出二者的内积。</p><h2 id="单变量线性回归算法"><a href="#单变量线性回归算法" class="headerlink" title="单变量线性回归算法"></a>单变量线性回归算法</h2><p>先考虑最简单的单变量线性回归算法，即只有一个输入特征。</p><h3 id="预测函数"><a href="#预测函数" class="headerlink" title="预测函数"></a>预测函数</h3><p>针对数据集x和y，预测函数会根据输入特征x来计算输出值h(x)。其输入和输出的函数关系如下：<br>$$<br>h_{\theta}(x)=\theta_{0}+\theta_{1} x<br>$$</p><p>这个方程表达的是一条直线。我们的任务是构造一个 $h_{\theta}$ 函数，来映射数据集中的输入特征x和输出值y，使得预测函数 $h_{\theta}$ 计算出来的值与真实值y的整体误差最小。构造  $h_{\theta}$ 函数的关键就是找到合适的 $\theta_{0}$和 $\theta_{1}$ 的值， 模型参数，也就是所说的模型参数。</p><p>假设有如下的数据集：</p><table><thead><tr><th align="center">输入特征x</th><th align="center">输出y</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">4</td></tr><tr><td align="center">2</td><td align="center">6</td></tr><tr><td align="center">3</td><td align="center">10</td></tr><tr><td align="center">4</td><td align="center">15</td></tr></tbody></table><p>假设模型参数 $\theta_{0}=1,  \theta_{1}=3$ ,  则预测函数为 $h_{\theta}(x)=1+3 x$ 。针对数据集中的第一个样本，输入为1，根据模型函数预测出来的值是4，与输出值y是吻合的。针对第二个样本，输入为2，根据模型函数预测出来的值是7，与实际输出值y相差1。模型的求解过程就是找出一组最合适的模型参数 $\theta_{0}$和 $\theta_{1}$，以便能最好地拟合数据集。</p><p>怎样来判断最好地拟合了数据集呢？没错，就是使用损失函数（也叫损失函数）。当拟合损失最小时，即找到了最好的拟合参数。</p><h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>单变量线性回归算法的损失函数是：</p><p>$$<br>J(\theta)=J\left(\theta_{0}, \theta_{1}\right)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h\left(x^{(i)}\right)-y^{(i)}\right)^{2}<br>$$<br>其中，$h\left(x^{(i)}\right)-y^{(i)}$ 是预测值和真实值之间的误差，故损失就是预测值和真实值之间误差平方的平均值，之所以乘以1/2是为了方便计算。这个函数也称为均方差公式。有了损失函数，就可以精确地测量模型对训练样本拟合的好坏程度。</p><h3 id="梯度下降算法"><a href="#梯度下降算法" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h3><p>有了预测函数，也可以精确地测量预测函数对训练样本的拟合情况。但怎么求解模型参数 $\theta_{0}$和 $\theta_{1}$的值呢？这时梯度下降算法就排上了用场。</p><p>我们的任务是找到合适的 $\theta_{0}$和 $\theta_{1}$ ，使得损失函数 $J\left(\theta_{0}, \theta_{1}\right)$ 最小。为了便于理解，我们切换到三维空间来描述这个任务。在一个三维空间里，以  $\theta_{0}$ 作为 x 轴， 以 $\theta_{1}$ 作为 y 轴，以损失函数 $J\left(\theta_{0}, \theta_{1}\right)$ 作为 z 轴，那么我们的任务就是要找出当 z 轴上的值最小的时候所对应的 x 轴上的值和 y 轴上的值。</p><p><strong>梯度下降算法的原理：</strong>先随机选择一组 $\theta_{0}$ 和 $\theta_{1}$ ，同时选择一个参数 $\alpha$ 作为移动的步长。然后，让x轴上的 $\theta_{0}$ 和 y轴上的  $\theta_{1}$ 别向特定的方向移动一小步，这个步长的大小就由参数  $\alpha$ 决定。经过多次迭代之后，x 轴和 y 轴上的值决定的点就慢慢靠近 z 轴上的最小值处，如图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/u=3721595541,2272727131&amp;fm=26&amp;gp=0.jpg" alt="img"></p><p>那特定的方向怎么确定呢？答案是<strong>偏导数</strong>。</p><p>可以简单地把偏导数理解为斜率。我们要让 $\theta_{j}$ 不停地迭代，由当前  $\theta_{j}$ 的值，根据 $J(\theta)$ 的偏导数函数，算出 $J(\theta)$ 在  $\theta_{j}$ 上的斜率，然后在乘以学习率  $\alpha$ ，就可以让 $\theta_{j}$ 往 $J(\theta)$ 变小的方向迈一小步。</p><p>用数学来描述上述过程，梯度下降的公式为：<br>$$<br>\theta_{j}=\theta_{j}-\alpha \frac{\partial}{\partial \theta_{j}} J(\theta)<br>$$<br>把损失函数 $J(\theta)$ 的定义代入上面的公式中，不难推导出梯度下降算法公式：<br>$$<br>\begin{array}{c}<br>\theta_{0}=\theta_{0}-\frac{\alpha}{m} \sum_{i=1}^{m}\left(h\left(x^{(i)}\right)-y^{(j)}\right) \<br>\<br>\theta_{1}=\theta_{1}-\frac{\alpha}{m} \sum_{i=1}^{m}\left(\left(h\left(x^{(i)}\right)-y^{(i)}\right) x_{i}\right)<br>\end{array}<br>$$<br>公式中， $\alpha$  是学习率；m 是训练样本的个数: $h\left(x^{(i)}\right)-y^{(i)}$ 是模型预测值和真实值的误差。需要注意的是，针对</p><p> $\theta_{0}$ 和 $\theta_{1}$ 分别求出了其迭代公式，在 $\theta_{1}$ 的迭代公式里，累加器中还需要乘以 $x_{i}$, 具体参考扩展部分。</p><h2 id="多变量线性回归算法"><a href="#多变量线性回归算法" class="headerlink" title="多变量线性回归算法"></a>多变量线性回归算法</h2><p>实际应用中往往不止一个输入特征。熟悉了单变量线性回归算法后，我们来探讨一下多变量线性回归算法。</p><h3 id="预测函数-1"><a href="#预测函数-1" class="headerlink" title="预测函数"></a>预测函数</h3><p>上面介绍的单变量线性回归模型里只有一个输入特征，我们推广到更一般的情况，即多个输入特征。此时输出y的值由n个输入特征 $x_{1}, x_{2}, \ldots, x_{n}$ 决定。那么预测函数模型可以改写如下：</p><p>$$<br>h_{\theta}(x)=\theta_{0}+\theta_{1} x_{1}+\theta_{2} x_{2}+\ldots+\theta_{n} x_{n}<br>$$<br>假设 $x_{0}=1$，那么上面的公式可以重写为：<br>$$<br>h_{\theta}(x)=\sum_{j=0}^{n} \theta_{j} x_{j}<br>$$<br>其中，$\theta_{0}, \theta_{1}, \dots, \theta_{n}$ 统称为 $\theta$ , 是预测函数的参数。即一组 $\theta$ 值就决定了一个预测函数，记为 $h_{\theta}(x)$ , 为了简便起见，在不引起误解的情况下可以简写为 $h(x)$ 。理论上，预测函数有无穷多个，我们求解的目标就是找出一个最优的 $\theta$ 值。</p><h4 id="向量形式的预测函数"><a href="#向量形式的预测函数" class="headerlink" title="向量形式的预测函数"></a>向量形式的预测函数</h4><p>根据向量乘法运算法则，损失函数可重写为：</p><p>$$<br>h_{\theta}(x)=\left[\theta_{0}, \theta_{1}, \cdots, \theta_{n}\right]\left[\begin{array}{c}<br>x_{0} \<br>x_{1} \<br>\vdots \<br>x_{n}<br>\end{array}\right]=\theta^{T} x<br>$$<br>此处，依然假设 $x_{0}=1$， $x_{0}$ 称为模型偏置（bias）。</p><p>写成向量形式的预测函数有两个原因。一是因为简洁，二是因为在实现算法时，要用到数值计算里的矩阵运算来提高效率，比如 <code>Numpy</code> 库里的矩阵运算。</p><h4 id="向量形式的训练样本"><a href="#向量形式的训练样本" class="headerlink" title="向量形式的训练样本"></a>向量形式的训练样本</h4><p>假设输入特征的个数是n，即 $x_{1}, x_{2}, \ldots, x_{n}$ , 我们总共有 m 个训练样本，为了书写方便，假设 $x_{0}=1$。这样训练样本可以写成矩阵的形式，即矩阵里每一行都是一个训练样本，总共有 m 行，每行有 n+1 列。</p><blockquote><p>思考：为什么不是n列而是n+1列？答案是：把模型偏置 $x_{0}$也加入了训练样本里。最后把训练样本写成一个矩阵，如下：</p></blockquote><p>$$<br>\boldsymbol{X}=\left[\begin{array}{ccccc}<br>x_{0}^{(1)} &amp; x_{1}^{(1)} &amp; x_{2}^{(1)} &amp; \dots &amp; x_{n}^{(1)} \<br>x_{0}^{(2)} &amp; x_{1}^{(2)} &amp; x_{2}^{(2)} &amp; \dots &amp; x_{n}^{(2)} \<br>\vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>x_{0}^{(m)} &amp; x_{1}^{(m)} &amp; x_{2}^{(m)} &amp; \cdots &amp; x_{n}^{(m)}<br>\end{array}\right], \theta=\left[\begin{array}{c}<br>\theta_{0} \<br>\theta_{1} \<br>\theta_{2} \<br>\vdots \<br>\theta_{n}<br>\end{array}\right]<br>$$</p><p>理解训练样本矩阵的关键在于理解这些上标和下标的含义。其中，带括号的上标表示样本序号，从1到m；下标表示特征序号，从0到n，其中 $x_{0}$ 为常数1。</p><blockquote><p>$x_{j}^{(i)}$ 表示第 i 个训练样本的第 j 个特征的值。而 $x^{(i)}$ 只有上标，则表示第 i 个训练样本所构成的列向量。</p></blockquote><p>综上，训练样本的预测值 $h_{\theta}(X)$ ，可以使用下面的矩阵运算公式：</p><p>$$<br>h_{\theta}(X)=X \theta<br>$$</p><h3 id="损失函数-1"><a href="#损失函数-1" class="headerlink" title="损失函数"></a>损失函数</h3><p>多变量线性回归算法的损失函数：</p><p>$$<br>J(\theta)=\frac{1}{2 m} \sum_{i=1}^{m}\left(h\left(x^{(i)}\right)-y^{(i)}\right)^{2}<br>$$<br>其中，模型参数 $\theta$ 为 n+1 维的向量，$h\left(x^{(i)}\right)-y^{(i)}$ 是预测值和实际值的差，这个形式和单变量线性回归算法的类似。</p><p>损失函数有其对应的矩阵形式：<br>$$<br>J(\theta)=\frac{1}{2 m}(X \theta-\vec{y})^{T}(X \theta-\vec{y})<br>$$<br>其中，X 为 $m \times(n+1)$ 维的训练样本矩阵；上标T表示转置矩阵；$\vec{y}$ 表示由所有的训练样本的输出 $y^{(i)}$ 构成的向量。这个公式的优势是：没有累加器，不需要循环，直接使用矩阵运算，就可以一次性计算出对特定的参数 $\theta$ 下模型的拟合损失。</p><h3 id="梯度下降算法-1"><a href="#梯度下降算法-1" class="headerlink" title="梯度下降算法"></a>梯度下降算法</h3><p>根据单变量线性回归算法的介绍，梯度下降的公式为：<br>$$<br>\theta_{j}=\theta_{j}-\alpha \frac{\partial}{\partial \theta_{j}} J(\theta)<br>$$<br>公式中，下标 j 是参数的序号，其值从 0 到 n； $\alpha$ 为学习率。把损失函数代入上式，利用偏导数计算法则，不难推导出梯度下降算法的参数迭代公式：<br>$$<br>\theta_{j}=\theta_{j}-\frac{\alpha}{m} \sum_{i=1}^{m}\left(\left(h\left(x^{(i)}\right)-y^{(i)}\right) x_{j}^{(i)}\right)<br>$$<br>我们可以对比一下单变量线性回归函数的参数迭代公式。实际上和多变量线性回归函数的参数迭代公式是一模一样的。惟一的区别就是因为 $x_{0}$ 为常数1，在单变量线性回归算法的参数迭代公式中省去了。</p><p>应用这个公式编写机器学习算法，一般步骤如下：</p><ul><li><p>确定学习率： $\alpha$ 太大可能会使损失函数无法收敛，太小则计算太多，机器学习算法效率就比较低。</p></li><li><p>参数初始化：比如让所有的参数都以1作为起始点，$\theta_{0}=1, \theta_{1}=1, \dots, \theta_{n}=1$，根据预测值和损失函数，就可以算出在参数起始位置的损失。需要注意的是，参数起始点可以根据实际情况灵活选择，以便让机器学习算法的性能更高，比如选择比较靠近极点的位置。</p></li><li><p>计算参数的下一组值：据梯度下降参数迭代公式，分别同时计算出新的 $\theta_{j}$ 值，进而得到新的预测函数 $h_{\theta}(x)$ 。再根据新的预测函数，代入损失函数就可以算出新的损失。</p></li><li><p>确定损失函数是否收敛：拿新的和旧的损失进行比较，看损失是不是变得越来越小。如果两次损失之间的差异小于误差范围，即说明已经非常靠近最小损失了，就可以近似地认为我们找到了最小损失。如果两次损失之间的差异在误差范围之外，重复步骤（3）继续计算下一组参数直到找到最优解。</p></li></ul><h2 id="模型优化"><a href="#模型优化" class="headerlink" title="模型优化"></a>模型优化</h2><p>线性回归模型常用的优化方法，包括增加多项式特征以及数据归一化处理等。</p><h3 id="多项式与线性回归"><a href="#多项式与线性回归" class="headerlink" title="多项式与线性回归"></a>多项式与线性回归</h3><p>当线性回归模型太简单导致欠拟合时，我们可以增加特征多项式来让线性回归模型更好地拟合数据。比如有两个特征  $x_{1}$ 和 $x_{2}$ ，可以增加两个特征的乘积 $x_{1} \times x_{2}$ 作为新特征  $x_{3}$ 。同理，我们也可以增加 $x_{1}^{2}$ 和 $x_{2}^{2}$  分别作为新特征  $x_{4}$ 和 $x_{5}$ 。</p><p>在 <code>scikit-learn</code> 里，线性回归是由类 <code>sklearn.learn_model.LinearRegression</code> 实现的，多项式由类<code>sklearn.preprocessing.PolynomialFeatures</code> 实现。那么要怎样添加多项式特征呢？我们需要用一个管道把两个类串起来，即用 <code>sklearn.pipeline.Pipeline</code> 把这两个模型串起来。</p><p>比如下面的函数就可以创建一个多项式拟合：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">polynomial_model</span>(<span class="params">degree=<span class="number">1</span></span>):</span></span><br><span class="line">    polynomial_features = PolynomialFeatures(degree=degree,include_bias=<span class="literal">False</span>)</span><br><span class="line">    linear_regression = LinearRegression(normalize=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment"># 这是一个流水线，先增加多项式阶数，然后再用线性回归算法来拟合数据</span></span><br><span class="line">    pipeline = Pipeline([(<span class="string">"polynomial_features"</span>, polynomial_features),</span><br><span class="line">                         (<span class="string">"linear_regression"</span>, linear_regression)])</span><br><span class="line">    <span class="keyword">return</span> pipeline</span><br></pre></td></tr></tbody></table></figure><p>一个 Pipeline 可以包含多个处理节点，在 scikit-learn 里，除了最后一个节点外，其他的节点都必须实现 fit() 方法和 transform() 方法，最后一个节点只需要实现 fit() 方法即可。当训练样本数据送进 Pipeline 里进行处理时，它会逐个调用节点的 fit() 方法和 transform() 方法，最后调用最后一个节点的 fit() 方法来拟合数据。管道的示意图如下所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630093109778.png" alt="image-20200630090937011"></p><h3 id="数据归一化"><a href="#数据归一化" class="headerlink" title="数据归一化"></a>数据归一化</h3><p>当线性回归模型有多个输入特征时，特别是使用多项式添加特征时，需要对数据进行归一化处理。比如，特征</p><p>$x_{1}$ 的范围在[1,4]之间，特征 $x_{2}$ 的范文在[1,2000]之间，这种情况下，可以让 $x_{1}$除以4来作为新特征 $x_{1}$，同时让 $x_{2}$ </p><p>除以2000来作为新特征 $x_{2}$ ，该过程称为特征缩放（feature scaling）。可以使用特征缩放来对训练样本进行归一化处理，处理后的特征范围在[0,1]之间。</p><ul><li>归一化处理的目的是让算法收敛更快，提升模型拟合过程中的计算效率。</li><li>进行归一化处理后，当有个新的样本需要计算预测值时，也需要先进行归一化处理，再通过模型来计算预测值，计算出来的预测值要再乘以归一化处理的系数，这样得到的数据才是真正的预测数据。</li><li>在 <code>scikit-learn</code> 里，使用 <code>LinearRegression</code> 进行线性回归时，可以指定 <code>normalize=True</code> 来对数据进行归一化处理。</li></ul><h2 id="示例1：使用线性回归算法拟合正弦函数"><a href="#示例1：使用线性回归算法拟合正弦函数" class="headerlink" title="示例1：使用线性回归算法拟合正弦函数"></a>示例1：使用线性回归算法拟合正弦函数</h2><p>首先生成200个在区间 $[2 \pi, 2 \pi]$ 内的正弦函数上的点，并给这些点加上一些随机的噪声。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">n_dots = <span class="number">200</span></span><br><span class="line">X = np.linspace(-<span class="number">2</span> * np.pi, <span class="number">2</span> * np.pi, n_dots)</span><br><span class="line">Y = np.sin(X) + <span class="number">0.2</span> * np.random.rand(n_dots) - <span class="number">0.1</span></span><br><span class="line"><span class="comment"># 把一个n维向量转换成一个n*1维的矩阵</span></span><br><span class="line">X = X.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">Y = Y.reshape(-<span class="number">1</span>, <span class="number">1</span>);</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>PolynomialFeatures</code> 和 <code>Pipeline</code> 创建一个多项式拟合模型</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.pipeline <span class="keyword">import</span> Pipeline</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">polynomial_model</span>(<span class="params">degree=<span class="number">1</span></span>):</span></span><br><span class="line">    polynomial_features = PolynomialFeatures(degree=degree,include_bias=<span class="literal">False</span>)</span><br><span class="line">    linear_regression = LinearRegression(normalize=<span class="literal">True</span>)</span><br><span class="line">    pipeline = Pipeline([(<span class="string">"polynomial_features"</span>, polynomial_features),</span><br><span class="line">                         (<span class="string">"linear_regression"</span>, linear_regression)])</span><br><span class="line">    <span class="keyword">return</span> pipeline</span><br></pre></td></tr></tbody></table></figure><p>分别用2/3/5/10阶多项式来拟合数据集：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error</span><br><span class="line">degrees = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">10</span>]</span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> d <span class="keyword">in</span> degrees:</span><br><span class="line">    model = polynomial_model(degree=d)</span><br><span class="line">    model.fit(X, Y)</span><br><span class="line">    train_score = model.score(X, Y)</span><br><span class="line">    mse = mean_squared_error(Y, model.predict(X))</span><br><span class="line">    results.append({<span class="string">"model"</span>: model, <span class="string">"degree"</span>: d, <span class="string">"score"</span>: train_score, <span class="string">"mse"</span>: mse})</span><br><span class="line"><span class="keyword">for</span> r <span class="keyword">in</span> results:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"degree: {}; train score: {}; mean squared error: {}"</span></span><br><span class="line">          .<span class="built_in">format</span>(r[<span class="string">"degree"</span>], r[<span class="string">"score"</span>], r[<span class="string">"mse"</span>]))</span><br></pre></td></tr></tbody></table></figure><p>算出每个模型拟合的评分，此外，使用 <code>mean_squared_error</code> 算出均方根误差，即实际的点和模型预点之间的距离，均方根误差越小说明模型拟合效果越好——上述代码的输出结果为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">degree: <span class="number">2</span>; train score: <span class="number">0.1543189069883787</span>; mean squared error: <span class="number">0.43058829267318416</span></span><br><span class="line">degree: <span class="number">3</span>; train score: <span class="number">0.2755383996826518</span>; mean squared error: <span class="number">0.3688679883773196</span></span><br><span class="line">degree: <span class="number">5</span>; train score: <span class="number">0.8982707756590037</span>; mean squared error: <span class="number">0.051796609130712795</span></span><br><span class="line">degree: <span class="number">10</span>; train score: <span class="number">0.9935830575581858</span>; mean squared error: <span class="number">0.0032672603337543927</span></span><br></pre></td></tr></tbody></table></figure><p>从输出结果可以看出，多项式阶数越高，拟合评分越高，均方根误差越小，拟合效果越好。</p><p>把不同模型的拟合效果在二维坐标上画出来，可以清楚地看到不同阶数的多项式的拟合效果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib.figure <span class="keyword">import</span> SubplotParams</span><br><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>),dpi=<span class="number">200</span>,subplotpars=SubplotParams(hspace=<span class="number">0.3</span>))</span><br><span class="line"><span class="keyword">for</span> i,r <span class="keyword">in</span> <span class="built_in">enumerate</span>(results):</span><br><span class="line">    fig = plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>)</span><br><span class="line">    plt.xlim(-<span class="number">8</span>,<span class="number">8</span>)</span><br><span class="line">    plt.title(<span class="string">"LinearRegression degree={}"</span>.<span class="built_in">format</span>(r[<span class="string">"degree"</span>]))</span><br><span class="line">    plt.scatter(X,Y,s=<span class="number">5</span>,c=<span class="string">'b'</span>,alpha=<span class="number">0.5</span>)</span><br><span class="line">    plt.plot(X,r[<span class="string">"model"</span>].predict(X),<span class="string">'r-'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>使用 <code>SubplotParam</code>s 调整了子图的竖直间距，并且使用 <code>subplot()</code> 函数把4个模型的拟合情况都画在同一个图形上。上述代码的输出结果如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630090937011.png" alt="image-20200630092742917"></p><p>在[-2π，2π]区间内，10阶多项式对数据拟合得非常好，我们可以试着画出这10阶模型在[-20,20]的区域内的曲线，观察一下该模型的曲线和正弦函数的差异。代码如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">12</span>,<span class="number">6</span>),dpi=<span class="number">200</span>)</span><br><span class="line">X = np.linspace(-<span class="number">20</span>,<span class="number">20</span>,<span class="number">2000</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">Y = np.sin(X).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">model_10 = results[<span class="number">3</span>][<span class="string">"model"</span>]</span><br><span class="line">plt.xlim(-<span class="number">20</span>,<span class="number">20</span>)</span><br><span class="line">plt.ylim(-<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot(X,Y,<span class="string">'b-'</span>)</span><br><span class="line">plt.plot(X,model_10.predict(X),<span class="string">'r-'</span>)</span><br><span class="line">dot1 = [-<span class="number">2</span>*np.pi,<span class="number">0</span>]</span><br><span class="line">dot2 = [<span class="number">2</span>*np.pi,<span class="number">0</span>]</span><br><span class="line">plt.scatter(dot1[<span class="number">0</span>],dot1[<span class="number">1</span>],s=<span class="number">50</span>,c=<span class="string">'r'</span>)</span><br><span class="line">plt.scatter(dot2[<span class="number">0</span>],dot2[<span class="number">1</span>],s=<span class="number">50</span>,c=<span class="string">'r'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>上述代码的输出结果如下图：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630100257358.png" alt="image-20200630093109778"></p><p>从图中可以看出，10阶多项式模型只有在区间[-2π,2π]之间对正弦曲线拟合较好，在此区间以外，两者相差甚远。此案例告诉我们，每个模型都有自己的适用范围，在满足适用范围的基本前提下，要尽可能寻找拟合程度最高的模型来使用。</p><h2 id="示例2：预测房价"><a href="#示例2：预测房价" class="headerlink" title="示例2：预测房价"></a>示例2：预测房价</h2><p>本节使用 <code>scikit-learn</code> 自带的波士顿房价数据来训练模型，然后用模型来预测房价。</p><h3 id="输入特征"><a href="#输入特征" class="headerlink" title="输入特征"></a>输入特征</h3><p>房价和哪些因素有关？很多人可能对这个问题特别敏感，随时可以列出很多，如房子面子、房子地理位置、周边教育资源、周边商业资源、房子朝向、年限、小区情况等。在 <code>scikit-learn</code>的波士顿房价数据集里，它总共收集了13个特征，具体如下：</p><ul><li><p>CRIM：城镇人均犯罪率。</p></li><li><p>ZN：城镇超过25000平方英尺的住宅区域的占地比例。</p></li><li><p>INDUS：城镇非零售用地占地比例。</p></li><li><p>CHAS：是否靠近河边，1为靠近，0为远离。</p></li><li><p>NOX：一氧化氮浓度</p></li><li><p>RM：每套房产的平均房间个数。</p></li><li><p>AGE：在1940年之前就盖好，且业主自住的房子的比例。</p></li><li><p>DIS：与波士顿市中心的距离。</p></li><li><p>RAD：周边高速公路的便利性指数。</p></li><li><p>TAX：每10000美元的财产税率。</p></li><li><p>PTRATIO：小学老师的比例。</p></li><li><p>B：城镇黑人的比例。</p></li><li><p>LSTAT：地位较低的人口比例。</p></li></ul><p>从这些指标里可以看到中美指标的一些差异。当然，这个数据是在1993年之前收集的，可能和现在会有差异。不要小看了这些指标，实际上一个模型的好坏和输入特征的选择关系密切。大家可以思考一下，如果要在中国预测房价，你会收集哪些特征数据？这些特征数据的可获得性如何？收集成本多高？</p><p>先导入数据：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_boston</span><br><span class="line">boston = load_boston()</span><br><span class="line">X = boston.data</span><br><span class="line">y = boston.target</span><br><span class="line"><span class="built_in">print</span>(X.shape)  <span class="comment"># (506, 13)</span></span><br></pre></td></tr></tbody></table></figure><p>表明这个数据集有506个样本，每个样本有13个特征。整个训练样本放在一个506*13的矩阵里。可以通过X[0]来查看一个样本数据：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(X[<span class="number">0</span>])</span><br><span class="line">array([<span class="number">6.320e-03</span>, <span class="number">1.800e+01</span>, <span class="number">2.310e+00</span>, <span class="number">0.000e+00</span>, <span class="number">5.380e-01</span>, <span class="number">6.575e+00</span>,</span><br><span class="line">       <span class="number">6.520e+01</span>, <span class="number">4.090e+00</span>, <span class="number">1.000e+00</span>, <span class="number">2.960e+02</span>, <span class="number">1.530e+01</span>, <span class="number">3.969e+02</span>,</span><br><span class="line">       <span class="number">4.980e+00</span>])</span><br></pre></td></tr></tbody></table></figure><p>还可以通过 <code>boston.features_names</code> 来查看这些特征的标签：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(boston.feature_names)</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array([<span class="string">'CRIM'</span>, <span class="string">'ZN'</span>, <span class="string">'INDUS'</span>, <span class="string">'CHAS'</span>, <span class="string">'NOX'</span>, <span class="string">'RM'</span>, <span class="string">'AGE'</span>, <span class="string">'DIS'</span>, <span class="string">'RAD'</span>,</span><br><span class="line">       <span class="string">'TAX'</span>, <span class="string">'PTRATIO'</span>, <span class="string">'B'</span>, <span class="string">'LSTAT'</span>], dtype=<span class="string">'&lt;U7'</span>)</span><br></pre></td></tr></tbody></table></figure><p>我们可以把特征和数值对应起来，观察一下数据。</p><h3 id="模型训练"><a href="#模型训练" class="headerlink" title="模型训练"></a>模型训练</h3><p>在 <code>scikit-learn</code> 里，<code>LinearRegression</code> 类实现了线性回归算法。在对模型进行训练之前，我们需要先把数据集分成两份，以便评估算法的准确性。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=<span class="number">0.2</span>,random_state=<span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure><p>由于数据量比较小，我们只选了20%的样本来作为测试数据集。接着，训练模型并测试模型的准确性评分：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line">model = LinearRegression()</span><br><span class="line">start = time.process_time()</span><br><span class="line">model.fit(X_train,y_train)</span><br><span class="line">train_score = model.score(X_train,y_train)</span><br><span class="line">test_score = model.score(X_test,y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"elaspe:{0:.6f};train_score:{1:0.6f};test_score:{2:.6f}"</span></span><br><span class="line">      .<span class="built_in">format</span>(time.process_time()-start,train_score,test_score))</span><br></pre></td></tr></tbody></table></figure><p>我们顺便统计了模型的训练时间，除此之外，统计模型对训练样本的准确性得分（即对训练样本拟合的好坏程度）<code>train_score</code>，还测试了模型对测试样本的得分test_score。运行结果如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elaspe:<span class="number">0.000000</span>;train_score:<span class="number">0.723941</span>;test_score:<span class="number">0.795262</span></span><br></pre></td></tr></tbody></table></figure><p>从得分情况来看，模型的拟合效果一般，还有没有办法来优化模型的拟合效果呢？</p><h3 id="模型优化-1"><a href="#模型优化-1" class="headerlink" title="模型优化"></a>模型优化</h3><p>首先观察一下数据，特征数据的范围相差比较大，最小的在$10^{-3}$级别，而最大的在$10^{2}$级别，看来我们需要先把数据进行归一化处理。归一化处理最简单的方式是，创建线性回归模型时增加normalize=True参数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = LinearRegression(normalize=<span class="literal">True</span>)</span><br></pre></td></tr></tbody></table></figure><p>当然，数据归一化处理只会加快算法收敛速度，优化算法训练的效率，无法提升算法的准确性。</p><p>怎么样优化模型的准确性呢？我们回到训练分数上来，可以观察到模型针对训练样本的评分比较低（train_score:0.723941），即模型对训练样本的拟合成本比较高，这是一个典型的欠拟合现象。回忆我们之前介绍的优化欠拟合模型的方法，一是挖掘更多的输入特征，而是增加多项式特征。在我们这个例子里，通过使用低成本的方案——即增加多项式特征来看能否优化模型的性能。增加多项式特征，其实就是增加模型的复杂度。</p><p>我们使用之前创建多项式模型的函数 <code>polynomial_model</code>，接着，我们使用二阶多项式来拟合数据：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">model = polynomial_model(degree=<span class="number">2</span>)</span><br><span class="line">start = time.process_time()</span><br><span class="line">model.fit(X_train, y_train)</span><br><span class="line">train_score = model.score(X_train, y_train)</span><br><span class="line">test_score = model.score(X_test, y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"elaspe:{0:.6f};train_score:{1:0.6f};test_score:{2:.6f}"</span></span><br><span class="line">      .<span class="built_in">format</span>(time.process_time() - start, train_score, test_score))</span><br></pre></td></tr></tbody></table></figure><p>输出结果是：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elaspe:<span class="number">0.078125</span>;train_score:<span class="number">0.930547</span>;test_score:<span class="number">0.860049</span></span><br></pre></td></tr></tbody></table></figure><p>训练样本分数和测试分数都提高了，看来模型确实得到了优化。我们可以把多项式改为3阶看一下效果：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">elaspe:<span class="number">0.093750</span>;train_score:<span class="number">1.000000</span>;test_score:-<span class="number">105.548323</span></span><br></pre></td></tr></tbody></table></figure><p>改为3阶多项式后，针对训练样本的分数达到了1，而针对测试样本的分数确实负数，说明这个模型过拟合了。</p><p>思考：我们总共有13个输入特征，从一阶多项式变为二阶多项式，输入特征个数增加了多少个？<br> 参考：二阶多项式共有：13个单一的特征，$C_{13}^{2}=78$ 个两两配对的特征，13个各自平方的特征，共计104个特征。比一阶多项式的13个特征增加了91个特征。</p><h3 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h3><p>更好的方法是画出学习曲线，这样对模型的状态以及优化的方向就一目了然。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> utils <span class="keyword">import</span> plot_learning_curve</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ShuffleSplit</span><br><span class="line">cv = ShuffleSplit(n_splits=<span class="number">10</span>,test_size=<span class="number">0.2</span>,random_state=<span class="number">0</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">18</span>,<span class="number">4</span>),dpi=<span class="number">200</span>)</span><br><span class="line">title = <span class="string">'Learning Curves (degree={0})'</span></span><br><span class="line">degrees = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">start = time.process_time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(degrees)):</span><br><span class="line">    plt.subplot(<span class="number">1</span>,<span class="number">3</span>,i+<span class="number">1</span>)</span><br><span class="line">    plot_learning_curve(plt,polynomial_model(degrees[i]),title.<span class="built_in">format</span>(degrees[i]),</span><br><span class="line">                        X,y,ylim=(<span class="number">0.01</span>,<span class="number">1.01</span>),cv=cv)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'elaspe:{0:.6f}'</span>.<span class="built_in">format</span>(time.process_time()-start))</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200630092742917.png" alt="image-20200630100257358"></p><p>从学习曲线中可以看出，一阶多项式欠拟合，因为针对训练样本的分数比较低；而三阶多项式过拟合，因为针对训练样本的分数达到1，却看不到交叉验证数据集的分数。针对二阶多项式拟合的情况，虽然比一阶多项式的效果好，但从图中可以明显地看出来，针对训练数据集的分数和针对交叉验证数据集的分数之间的间隔比较大，这说明训练样本数量不够，我们应该去采集更多的数据，以提高模型的准确性。</p><h2 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h2><p>本节内容涉及到较多的数学知识，特别是矩阵和偏导数运算法则。如果阅读起来有困难，可以先跳过。如果有一定数学基础，这些知识对理解算法的实现细节及算法的效率有较大的帮助。</p><h3 id="公式推导的数学基础"><a href="#公式推导的数学基础" class="headerlink" title="公式推导的数学基础"></a>公式推导的数学基础</h3><p>AI的数学基础最主要的是高等数学、线性代数、概率论与数理统计这三门课程。下面是简易的入门文章供参考</p><ul><li>高等数学 <a href="https://zhuanlan.zhihu.com/p/36311622">https://zhuanlan.zhihu.com/p/36311622</a></li><li>线性代数 <a href="https://zhuanlan.zhihu.com/p/36584206">https://zhuanlan.zhihu.com/p/36584206</a></li><li>概率论与数理统计 <a href="https://zhuanlan.zhihu.com/p/36584335">https://zhuanlan.zhihu.com/p/36584335</a></li></ul><h3 id="随机梯度下降算法"><a href="#随机梯度下降算法" class="headerlink" title="随机梯度下降算法"></a>随机梯度下降算法</h3><p>本章介绍的梯度下降算法迭代公式称为批量梯度下降算法（Batch Gradient Descent，简称BGD），用它对参数进行一次迭代运算，需要遍历所有的训练数据集。当训练数据集比较大时，其算法的效率会比较低。考虑另外一个算法：<br>$$<br>\theta_{j}=\theta_{j}-\alpha\left(\left(h\left(x^{(i)}\right)-y^{(i)}\right) x_{j}^{(i)}\right)<br>$$<br> 这个算法的关键点是把累加器去掉，不去遍历所有的数据集，而是改成每次随机地从训练数据集中取一个数据进行参数迭代计算，这就是随机梯度下降算法（Stochastic Gradient Descent，简称SGD）。随机梯度下降算法可以大大提高模型训练的效率。</p><h3 id="正规方程"><a href="#正规方程" class="headerlink" title="正规方程"></a>正规方程</h3><p>梯度下降算法通过不断地迭代，从而不停地逼近成本函数的最小值来求解模型的参数。另外一个方法是直接计算成本函数的微分，令微分算子为0，求解这个方程，即可得到线性回归的解。<br> 线性回归算法的损失函数：<br>$$<br>J(\theta)=\frac{1}{2 m} \sum_{i=0}^{n}\left(h_{\theta}\left(x^{(i)}\right)-y^{(i)}\right)^{2}<br>$$<br>成本函数的“斜率”为0的点，即为模型参数的解。令$\frac{\partial}{\partial \theta} J(\theta)=0$，求解这个方程最终可以得到模型参数：<br>$$<br>\theta=\left(X^{T} X\right)^{-1} X^{T} y<br>$$<br>这就是我们的正规方程。它通过矩阵运算，直接从训练样本里求出参数θ的值。其中X为训练样本的矩阵形式，它是m×n的矩阵，y是训练样本的结果数据，它是个m维列向量。方程求解过程可参阅<a href="https://baike.baidu.com/item/%E6%AD%A3%E8%A7%84%E6%96%B9%E7%A8%8B/10001812?fr=aladdin">百度百科</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列二：K-近邻</title>
      <link href="/2020/06/29/scikit-learn-xi-lie-er-k-jin-lin/"/>
      <url>/2020/06/29/scikit-learn-xi-lie-er-k-jin-lin/</url>
      
        <content type="html"><![CDATA[<h2 id="项目地址传送门，欢迎-star-和-fork-！"><a href="#项目地址传送门，欢迎-star-和-fork-！" class="headerlink" title="项目地址传送门，欢迎 star 和 fork ！"></a>项目地址<a href="https://github.com/DongZhouGu/scikit-learn-ml">传送门</a>，欢迎 star 和 fork ！</h2><h2 id="KNN-概述"><a href="#KNN-概述" class="headerlink" title="KNN 概述"></a>KNN 概述</h2><p>KNN（K-Nearest Neighbor，K-近邻算法）算法是一种<strong>有监督</strong>的机器学习算法，可以解决分类问题，也可以解决回归问题。</p><blockquote><p><strong>一句话总结: 近朱者赤近墨者黑！</strong> </p></blockquote><p>k -近邻算法的输入为实例的特征向量，对应于特征空间的点；输出为实例的类别，可以取多类。k 近邻算法假设给定一个训练数据集，其中的实例类别已定。分类时，对新的实例，根据其 k 个最近邻的训练实例的类别，通过多数表决等方式进行预测。因此，k近邻算法不具有显式的学习过程。</p><h2 id="KNN算法原理"><a href="#KNN算法原理" class="headerlink" title="KNN算法原理"></a>KNN算法原理</h2><p>K-近邻算法的核心思想是未标记样本的类别，由距离其最近的 K 个邻居投票来决定。</p><p>假设，我们有一个已经标记的数据集，即已经知道了数据集中每个样本所属的类别。此时，有一个未标记的数据样本，我们的任务是预测出这个数据样本所属的类别。<strong>K-近邻算法的原理是，计算待标记的数据样本和数据集中每个样本的距离，取距离最近的K个样本。</strong>待标记的数据样本所属的类别，就由这K个距离最近的样本投票产生。</p><blockquote><p>KNN工作原理</p></blockquote><p>假设X_test为待标记的数据样本，X_train为已标记的数据集，算法原理的伪代码如下：</p><ul><li>遍历 X_train 中的所有样本，计算每个样本与 X_test 的距离，并把距离保存在 Distance 数组中。</li><li>对 Distance 数组进行排序，取距离最近的K个点，记为 X_knn 。</li><li>在 X_knn 中统计每个类别的个数，即 class0 在 X_knn 中有几个样本，class1 在 X_knn 中有几个样本等。</li><li>待标记样本的类别，就是在 X_knn 中样本数最多的那个类别。</li></ul><blockquote><p>KNN算法优缺点</p></blockquote><ul><li>优点：准确度高，对异常值和噪声有较高的容忍度。</li><li>缺点：计算复杂度高、空间复杂度高，从算法原理可以看出，每次对一个未标记样本进行分类时，都需要全部计算一遍距离。</li></ul><blockquote><p>KNN算法参数</p></blockquote><p>其算法参数是K，参数选择需要根据数据来决定。K值越大，模型的偏差越大，对噪声数据越不敏感，当K值很大时，可能造成模型欠拟合；K值越小，模型的方差就会越大，当K值太小，就会造成模型过拟合。</p><blockquote><p>KNN算法变种</p></blockquote><p>K-近邻算法有一些变种，其中之一就是可以增加邻居的权重。默认情况下，在计算距离时，都是使用相同的权重。实际上，我们可以针对不同的邻居指定不同的权重，如距离越近权重越高。这个可以通过指定算法的weights参数来实现。</p><p>另外一个变种是，使用一定半径内的点取代距离最近的K个点。在 <code>scikit-learn</code> 里，<code>RadiusNeighborsClassifier</code> 类实现了这个算法的变种。当数据采样不均匀时，该算法变种可以取得更好的性能。</p><h2 id="KNN-项目案例"><a href="#KNN-项目案例" class="headerlink" title="KNN 项目案例"></a>KNN 项目案例</h2><h3 id="案例1-使用KNN算法进行分类"><a href="#案例1-使用KNN算法进行分类" class="headerlink" title="案例1: 使用KNN算法进行分类"></a>案例1: 使用KNN算法进行分类</h3><p>完整代码地址：</p><p>在 <code>scikit-learn</code>里，使用K-近邻算法进行分类处理的是 <code>sklearn.neightbors.KNeightborsClassifier</code> 类。</p><h4 id="rainbow-生成数据集"><a href="#rainbow-生成数据集" class="headerlink" title=":rainbow:   生成数据集"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span>   生成数据集</h4><p>我们使用 <code>sklearn.datasets.samples_generator</code> 包下的 <code>make_blobs()</code> 函数来生成数据集，这里生成60个训练样本，这些样本分布在 <code>centers</code> 参数指定的中心点的周围。<code>cluster_std</code> 是标准差，用来指明生成的点分布的松散程度。生成的训练数据集放在变量X里面，数据集的类别标记放在 y 里面。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"><span class="comment"># 生成数据</span></span><br><span class="line">centers = [[-<span class="number">2</span>,<span class="number">2</span>],[<span class="number">2</span>,<span class="number">2</span>],[<span class="number">0</span>,<span class="number">4</span>]]</span><br><span class="line">X,y = make_blobs(n_samples=<span class="number">60</span>,centers=centers,random_state=<span class="number">0</span>,cluster_std=<span class="number">0.60</span>)</span><br></pre></td></tr></tbody></table></figure><blockquote><p>X:  [[ 1.59652373  1.7842681 ] ,[-1.08033247 2.88161526],…]共60个点的横纵坐标</p><p>y: [1 0 0 1 0 1 1 0 2…1 2 0 1] 共60个点的类别，用0，1，2分别表示以哪个中心聚合</p></blockquote><p>使用 <code>matplotlib</code> 库，它可以很容易地把生成的点画出来：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">10</span>),dpi=<span class="number">144</span>)</span><br><span class="line">c = np.array(centers)</span><br><span class="line"><span class="comment"># cmap就是指matplotlib.colors.Colormap,一个包含三列矩阵的色彩映射表</span></span><br><span class="line"><span class="comment"># 使用c和cmap来映射颜色，s为形状的大小</span></span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],c=y,s=<span class="number">100</span>,cmap=<span class="string">'cool'</span>)</span><br><span class="line">plt.scatter(c[:,<span class="number">0</span>],c[:,<span class="number">1</span>],s=<span class="number">100</span>,marker=<span class="string">'*'</span>,c=<span class="string">'black'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200628191906466.png"><p>这些点的分布情况在坐标轴上一目了然，其中五角星的点即各个类别的中心点。</p><h4 id="rainbow-训练算法"><a href="#rainbow-训练算法" class="headerlink" title=":rainbow: 训练算法"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span> 训练算法</h4><p>使用 <code>KNeighborsClassifier</code> 来对算法进行训练，我们选择的参数是 <code>K=5</code></p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line">k = <span class="number">5</span></span><br><span class="line">clf = KNeighborsClassifier(n_neighbors=k)</span><br><span class="line">clf.fit(X,y)</span><br></pre></td></tr></tbody></table></figure><p><code>KNeighborsClassifier</code>的参数细节为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KNeighborsClassifier(algorithm=<span class="string">'auto'</span>, leaf_size=<span class="number">30</span>, metric=<span class="string">'minkowski'</span>,</span><br><span class="line">           metric_params=<span class="literal">None</span>, n_jobs=<span class="number">1</span>, n_neighbors=<span class="number">5</span>, p=<span class="number">2</span>,</span><br><span class="line">           weights=<span class="string">'uniform'</span>)</span><br></pre></td></tr></tbody></table></figure><h4 id="rainbow-对样本进行预测"><a href="#rainbow-对样本进行预测" class="headerlink" title=":rainbow:  对样本进行预测"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span>  对样本进行预测</h4><p>我们要预测的样本是[0,2]，使用 <code>kneighbors()</code> 方法，把这个样本周围距离最近的5个点取出来。取出来的点是训练样本X里的索引，从0开始计算。<br> 注意：<code>kneighbors()</code>接收一个二维数组作为参数，所以 <code>X_sample</code> 需要变成二维。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X_sample = [<span class="number">0</span>,<span class="number">2</span>]</span><br><span class="line">X_sample = np.array(X_sample).reshape(<span class="number">1</span>, -<span class="number">1</span>)  <span class="comment">#[[0 2]]</span></span><br><span class="line">y_sample = clf.predict(X_sample)</span><br><span class="line">neighbors = clf.kneighbors(X_sample,return_distance=<span class="literal">False</span>) <span class="comment">#[[16 20 48  6 23]]</span></span><br></pre></td></tr></tbody></table></figure><h4 id="rainbow-标记最近的5个点"><a href="#rainbow-标记最近的5个点" class="headerlink" title=":rainbow:  标记最近的5个点"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span>  标记最近的5个点</h4><p>把待预测的样本以及和其最近的5个点标记出来</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">10</span>),dpi=<span class="number">144</span>)</span><br><span class="line">plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, s=<span class="number">100</span>, cmap=<span class="string">'cool'</span>)    <span class="comment"># 样本</span></span><br><span class="line">plt.scatter(c[:, <span class="number">0</span>], c[:, <span class="number">1</span>], s=<span class="number">100</span>, marker=<span class="string">'^'</span>, c=<span class="string">'k'</span>)   <span class="comment"># 中心点</span></span><br><span class="line">plt.scatter(X_sample[<span class="number">0</span>][<span class="number">0</span>],X_sample[<span class="number">0</span>][<span class="number">1</span>],marker=<span class="string">"x"</span>, s=<span class="number">100</span>, cmap=<span class="string">'cool'</span>)  <span class="comment">#待预测的点</span></span><br><span class="line"><span class="comment">#预测点与距离最近的5个样本的连线</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> neighbors[<span class="number">0</span>]:</span><br><span class="line">    plt.plot([X[i][<span class="number">0</span>],X_sample[<span class="number">0</span>][<span class="number">0</span>]],[X[i][<span class="number">1</span>],X_sample[<span class="number">0</span>][<span class="number">1</span>]],<span class="string">'k--'</span>,linewidth=<span class="number">0.6</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200628204257514.png" alt=""></p><h3 id="案例2-使用KNN算法进行回归拟合"><a href="#案例2-使用KNN算法进行回归拟合" class="headerlink" title="案例2: 使用KNN算法进行回归拟合"></a>案例2: 使用KNN算法进行回归拟合</h3><p>分类问题的预测值是离散的，我们也可以使用 KNN 算法对连续区间内的数值进行预测，即进行回归拟合。在<code>scikit-learn</code>里面，使用KNN算法进行回归拟合的实现是 <code>sklearn.neighbors.KNeighborsRegressor</code> 类。</p><h4 id="rainbow-生成数据集-1"><a href="#rainbow-生成数据集-1" class="headerlink" title=":rainbow:  生成数据集"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span>  生成数据集</h4><p>在余弦曲线的基础上加入了噪声：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">n_dots = <span class="number">40</span></span><br><span class="line"><span class="comment"># 生成40行1列的服从“0~5”均匀分布的随机样本</span></span><br><span class="line">X = <span class="number">5</span> * np.random.rand(n_dots, <span class="number">1</span>)</span><br><span class="line">y = np.cos(X).flatten()</span><br><span class="line"><span class="comment"># 生成40行1列的服从“-0.1~0.1”均匀分布的随机误差</span></span><br><span class="line">y += <span class="number">0.2</span> * np.random.rand(n_dots) - <span class="number">0.1</span></span><br></pre></td></tr></tbody></table></figure><h4 id="rainbow-训练算法-1"><a href="#rainbow-训练算法-1" class="headerlink" title=":rainbow:  训练算法"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span>  训练算法</h4><p>使用 <code>KNeighborsRegressor</code> 来训练模型：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsRegressor</span><br><span class="line">k = <span class="number">5</span></span><br><span class="line">knn = KNeighborsRegressor(k)</span><br><span class="line">knn.fit(X,y)</span><br></pre></td></tr></tbody></table></figure><p><code>KNeighborsRegressor</code>方法的参数细节为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">KNeighborsRegressor(algorithm=<span class="string">'auto'</span>, leaf_size=<span class="number">30</span>, metric=<span class="string">'minkowski'</span>,</span><br><span class="line">          metric_params=<span class="literal">None</span>, n_jobs=<span class="number">1</span>, n_neighbors=<span class="number">5</span>, p=<span class="number">2</span>,</span><br><span class="line">          weights=<span class="string">'uniform'</span>)</span><br></pre></td></tr></tbody></table></figure><p>可以使用 <code>score()</code>方法 计算拟合曲线对训练样本的拟合准确性：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">knn.score(X,y)</span><br><span class="line"><span class="number">0.9596828473009764</span></span><br></pre></td></tr></tbody></table></figure><h4 id="rainbow-回归拟合"><a href="#rainbow-回归拟合" class="headerlink" title=":rainbow:  回归拟合"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span>  回归拟合</h4><p> 一个常用的方法是，在X轴上的指定区域生成足够多的点，针对这些足够密集的点，使用训练出来的模型进行预测，得到预测值y_pred，然后在坐标轴上，把所有的预测点连接起来，这样就画出了拟合曲线。<br> 生成足够密集的点并进行预测：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T = np.linspace(<span class="number">0</span>,<span class="number">5</span>,<span class="number">500</span>)[:,np.newaxis]</span><br><span class="line">y_pred = knn.predict(T)</span><br></pre></td></tr></tbody></table></figure><p>把这些预测点连起来，构成拟合曲线：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">16</span>,<span class="number">10</span>),dpi=<span class="number">144</span>)</span><br><span class="line">plt.scatter(X,y,c=<span class="string">'g'</span>,label=<span class="string">'data'</span>,s=<span class="number">100</span>)</span><br><span class="line">plt.plot(T,y_pred,c=<span class="string">'k'</span>,label=<span class="string">'prediction'</span>,lw=<span class="number">4</span>)</span><br><span class="line">plt.axis(<span class="string">'tight'</span>)</span><br><span class="line">plt.title(<span class="string">'KNeighborsRegressor (k = %i)'</span> % k)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><p>最终生成的拟合曲线和训练样本数据如图，拟合出来确实和 cos 曲线相似。</p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200628223010274.png" style="zoom: 67%;"><h3 id="案例3-使用KNN算法预测糖尿病"><a href="#案例3-使用KNN算法预测糖尿病" class="headerlink" title="案例3: 使用KNN算法预测糖尿病"></a>案例3: 使用KNN算法预测糖尿病</h3><p>本节使用KNN算法及其变种，对Pima印第安人的糖尿病进行预测。数据来源<a href="">kaggle.com</a>大家可以自己去下载。也可以使用 <a href="./pima-indians-diabetes/diabetes.csv">仓库文件</a>。</p><h4 id="rainbow-加载数据集"><a href="#rainbow-加载数据集" class="headerlink" title=":rainbow:加载数据集"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span>加载数据集</h4><p>使用Pandas加载数据：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data = pd.read_csv(<span class="string">'./pima-indians-diabetes/diabetes.csv'</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'dataset shape {}'</span>.<span class="built_in">format</span>(data.shape))</span><br><span class="line"><span class="built_in">print</span>(data.head())</span><br></pre></td></tr></tbody></table></figure><p>输出如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dataset shape (<span class="number">768</span>, <span class="number">9</span>)</span><br><span class="line">Out[<span class="number">23</span>]:</span><br><span class="line">Pregnancies Glucose BloodPressure   SkinThickness   Insulin BMI DiabetesPedigreeFunction    Age Outcome</span><br><span class="line"><span class="number">0</span>   <span class="number">6</span>   <span class="number">148</span> <span class="number">72</span>  <span class="number">35</span>  <span class="number">0</span>   <span class="number">33.6</span>    <span class="number">0.627</span>   <span class="number">50</span>  <span class="number">1</span></span><br><span class="line"><span class="number">1</span>   <span class="number">1</span>   <span class="number">85</span>  <span class="number">66</span>  <span class="number">29</span>  <span class="number">0</span>   <span class="number">26.6</span>    <span class="number">0.351</span>   <span class="number">31</span>  <span class="number">0</span></span><br><span class="line"><span class="number">2</span>   <span class="number">8</span>   <span class="number">183</span> <span class="number">64</span>  <span class="number">0</span>   <span class="number">0</span>   <span class="number">23.3</span>    <span class="number">0.672</span>   <span class="number">32</span>  <span class="number">1</span></span><br><span class="line"><span class="number">3</span>   <span class="number">1</span>   <span class="number">89</span>  <span class="number">66</span>  <span class="number">23</span>  <span class="number">94</span>  <span class="number">28.1</span>    <span class="number">0.167</span>   <span class="number">21</span>  <span class="number">0</span></span><br><span class="line"><span class="number">4</span>   <span class="number">0</span>   <span class="number">137</span> <span class="number">40</span>  <span class="number">35</span>  <span class="number">168</span> <span class="number">43.1</span>    <span class="number">2.288</span>   <span class="number">33</span>  <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><p>从打印出的信息可以看到，这个数据集一共有 768 个样本、8 个特征、1 个标签：</p><p><code>Pregnancies</code>：怀孕的次数</p><p><code>Glucose</code>：血浆葡萄糖浓度，采用 2 小时口服葡萄糖耐量试验测得</p><p><code>BloodPressure</code>：舒张压（毫米汞柱）</p><p><code>SkinThickness</code>：肱三头肌皮肤褶皱厚度（毫米）</p><p><code>Insulin</code>：两个小时血清胰岛素（ μU /毫升）</p><p><code>BMI</code>：身体质量指数，体重除以身高的平方</p><p><code>DiabetesPedigreeFunction</code>：糖尿病血统指数，糖尿病和家庭遗传相关</p><p><code>Age</code>：年龄</p><p><code>Outcome</code>：0表示没有糖尿病，1表示有糖尿病</p><p> 我们可以进一步观察数据集里的阳性和阴性样本的个数：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.groupby(<span class="string">'Outcome'</span>).size()</span><br></pre></td></tr></tbody></table></figure><p>输出为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Outcome</span><br><span class="line"><span class="number">0</span>    <span class="number">500</span></span><br><span class="line"><span class="number">1</span>    <span class="number">268</span></span><br><span class="line">dtype: int64</span><br></pre></td></tr></tbody></table></figure><p>其中，阴性样本500例，阳性样本268例。</p><h4 id="rainbow-处理数据集"><a href="#rainbow-处理数据集" class="headerlink" title=":rainbow: 处理数据集"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span> 处理数据集</h4><p> 接着需要对数据集进行简单处理，把8个特征值分离出来，作为训练数据集，把Outcome列分离出来作为目标值。然后，把数据集划分为训练数据集和测试数据集。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X = data.iloc[:,:<span class="number">8</span>]</span><br><span class="line">Y = data.iloc[:,<span class="number">8</span>]</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line">X_train,X_test,Y_train,Y_test=train_test_split(X,Y,test_size=<span class="number">0.2</span>)</span><br><span class="line"><span class="built_in">print</span>(X_train.shape, X_test.shape, Y_train.shape, Y_test.shape)</span><br></pre></td></tr></tbody></table></figure><p>输出：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">614</span>, <span class="number">8</span>) (<span class="number">154</span>, <span class="number">8</span>) (<span class="number">614</span>,) (<span class="number">154</span>,)</span><br></pre></td></tr></tbody></table></figure><h4 id="rainbow-模型比较"><a href="#rainbow-模型比较" class="headerlink" title=":rainbow: 模型比较"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span> 模型比较</h4><p>分别使用普通的KNN算法、带权重的KNN算法和指定半径的KNN算法对数据集进行拟合并计算评分：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier, RadiusNeighborsClassifier</span><br><span class="line"></span><br><span class="line">models = []</span><br><span class="line">models.append((<span class="string">"KNN"</span>, KNeighborsClassifier(n_neighbors=<span class="number">2</span>)))</span><br><span class="line">models.append((<span class="string">"KNN with weights"</span>, KNeighborsClassifier(</span><br><span class="line">    n_neighbors=<span class="number">2</span>, weights=<span class="string">"distance"</span>)))</span><br><span class="line">models.append((<span class="string">"Radius Neighbors"</span>, RadiusNeighborsClassifier(</span><br><span class="line">    n_neighbors=<span class="number">2</span>, radius=<span class="number">500.0</span>)))</span><br><span class="line"></span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span><br><span class="line">    model.fit(X_train, Y_train)</span><br><span class="line">    results.append((name, model.score(X_test, Y_test)))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(results)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"name: {}; score: {}"</span>.<span class="built_in">format</span>(results[i][<span class="number">0</span>],results[i][<span class="number">1</span>]))</span><br></pre></td></tr></tbody></table></figure><p>三种算法的性能如下：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name: KNN; score: <span class="number">0.7467532467532467</span></span><br><span class="line">name: KNN <span class="keyword">with</span> weights; score: <span class="number">0.6818181818181818</span></span><br><span class="line">name: Radius Neighbors; score: <span class="number">0.6558441558441559</span></span><br></pre></td></tr></tbody></table></figure><p>带权重的KNN算法，我们选择了距离越近、权重越高。指定半径的KNN算法的半径选择了500。从上面的输出结果可以看出，普通的KNN算法性能最好。问题来了，这个判断准确么？答案是不准确。因为我们的训练样本和测试样本是随机分配的，不同的训练样本和测试样本组合可能导致计算出来的算法准确性是有差异的。我们可以试着多次运行上面的代码，观察输出值是否有变化。</p><p>怎么样更准确地对比算法准确性呢？一个方法是，多次随机分配训练数据集和交叉验证数据集，然后求模型准确性评分的平均值。所幸，我们不需要从头实现这个过程，<code>scikit-learn</code> 提供了 <code>KFold</code> 和 <code>cross_val_score()</code>函数来处理这种问题：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> cross_val_score</span><br><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span><br><span class="line">    kfold = KFold(n_splits=<span class="number">10</span>)</span><br><span class="line">    cv_result = cross_val_score(model, X, Y, cv=kfold)</span><br><span class="line">    results.append((name, cv_result))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(results)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"name: {}; cross val score: {}"</span>.<span class="built_in">format</span>(</span><br><span class="line">        results[i][<span class="number">0</span>],results[i][<span class="number">1</span>].mean()))</span><br></pre></td></tr></tbody></table></figure><p>上述代码中，我们通过KFold把数据集分成10份，其中1份会作为交叉验证数据集来计算模型准确性，剩余的9份作为训练数据集。cross_val_score()函数总共计算出10次不同训练数据集和交叉验证数据集组合得到的模型准确性评分，最后求平均值。这样的评价结果相对更准确一些。<br> 输出结果为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name: KNN; cross val score: <span class="number">0.7147641831852358</span></span><br><span class="line">name: KNN <span class="keyword">with</span> weights; cross val score: <span class="number">0.6770505809979495</span></span><br><span class="line">name: Radius Neighbors; cross val score: <span class="number">0.6497265892002735</span></span><br></pre></td></tr></tbody></table></figure><h4 id="rainbow-模型训练及分析"><a href="#rainbow-模型训练及分析" class="headerlink" title=":rainbow:模型训练及分析"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span>模型训练及分析</h4><p>通过上面的对比来看，普通的KNN算法性能更优一些。接下来，我们就使用普通的KNN算法模型对数据集进行训练，并查看对训练样本的拟合情况以及对测试样本的预测准确性情况：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">2</span>)</span><br><span class="line">knn.fit(X_train, Y_train)</span><br><span class="line">train_score = knn.score(X_train, Y_train)</span><br><span class="line">test_score = knn.score(X_test, Y_test)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">"train score: {}\ntest score: {}"</span>.<span class="built_in">format</span>(train_score, test_score))</span><br></pre></td></tr></tbody></table></figure><p>输出结果为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">train score: <span class="number">0.8387622149837134</span></span><br><span class="line">test score: <span class="number">0.7337662337662337</span></span><br></pre></td></tr></tbody></table></figure><p>从输出中可以看到两个问题。一是对训练样本的拟合情况不佳，评分才0.82多，这说明算法模型太简单了，无法很好地拟合训练样本。二是模型的准确性欠佳，不到74%的预测准确性。我们可以进一步画出学习曲线，证实结论。</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> ShuffleSplit</span><br><span class="line"><span class="keyword">from</span> common.utils <span class="keyword">import</span> plot_learning_curve</span><br><span class="line">knn = KNeighborsClassifier(n_neighbors=<span class="number">2</span>)</span><br><span class="line">cv = ShuffleSplit(n_splits=<span class="number">10</span>, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plot_learning_curve(plt, knn, <span class="string">"Learn Curve for KNN Diabetes"</span>, </span><br><span class="line">                    X, Y, ylim=(<span class="number">0.0</span>, <span class="number">1.01</span>), cv=cv)</span><br><span class="line">plt.show()</span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200629101150911.png" style="zoom:67%;"><p>从图中可以看出来，训练样本评分较低，且测试样本与训练样本距离较大，这是典型的欠拟合现象。KNN算法没有更好的措施来解决欠拟合问题，我们学完本书的其他章节后，可以试着用其他算法（如逻辑回归算法、支持向量机等）来对比不同模型的准确性情况。</p><h4 id="rainbow-特征选择及数据可视化"><a href="#rainbow-特征选择及数据可视化" class="headerlink" title=":rainbow:特征选择及数据可视化"></a><span class="github-emoji" style="color: transparent;background:no-repeat url(https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8) center/contain" data-src="https://github.githubassets.com/images/icons/emoji/unicode/1f308.png?v8">🌈</span>特征选择及数据可视化</h4><p>那有没有直观的方法，来揭示出为什么KNN算法不是针对这一问题的好模型？一个办法是把数据画出来，可是我们有8个特征，无法在这么高的维度里画出数据，并直观地观察。一个解决办法是特征选择，即只选择2个与输出值相关性最大的特征，这样就可以在二维平面上画出输入特征值与输出值的关系了。</p><p><code>scikit-learn</code>在 <code>sklearn.feature_selection</code> 包里提供了丰富的特征选择方法。我们使用 <code>SelectKBest</code> 来选择相关性最大的两个特征：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_selection <span class="keyword">import</span> SelectKBest</span><br><span class="line">selector = SelectKBest(k=<span class="number">2</span>)</span><br><span class="line">X_new = selector.fit_transform(X, Y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">'X_new.shape {}'</span>.<span class="built_in">format</span>(X_new.shape))</span><br></pre></td></tr></tbody></table></figure><p>把相关性最大的两个特征放在X_new变量里，输出结果为：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_new.shape (<span class="number">768</span>, <span class="number">2</span>)</span><br></pre></td></tr></tbody></table></figure><p>我们可能会好奇，相关性最大的特征到底是哪两个？对比一下本节开头的数据即可知道，它们分别是Glucose（血糖浓度）和BMI（身体质量指数）。血糖浓度和糖尿病的关系自不必说，身体质量指数是反映肥胖程度的指标，从业务角度来看，我们选择出来的2个相关性最高的特征还算合理。那么 <code>SelectKBest</code> 到底使用什么神奇的方法选择出了这两个相关性最高的特征呢？详情参考下一节。</p><p>我们来看看，如果只使用这2个相关性最高的特征的话，3种不同的KNN算法哪个准确性更高：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">results = []</span><br><span class="line"><span class="keyword">for</span> name, model <span class="keyword">in</span> models:</span><br><span class="line">    kfold = KFold(n_splits=<span class="number">10</span>)</span><br><span class="line">    cv_result = cross_val_score(model, X_new, Y, cv=kfold)</span><br><span class="line">    results.append((name, cv_result))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(results)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"name: {}; cross val score: {}"</span>.<span class="built_in">format</span>(</span><br><span class="line">        results[i][<span class="number">0</span>],results[i][<span class="number">1</span>].mean()))</span><br></pre></td></tr></tbody></table></figure><p>这次使用X_new作为输入，输出如下</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name: KNN; cross val score: <span class="number">0.725205058099795</span></span><br><span class="line">name: KNN <span class="keyword">with</span> weights; cross val score: <span class="number">0.6900375939849623</span></span><br><span class="line">name: Radius Neighbors; cross val score: <span class="number">0.6510252904989747</span></span><br></pre></td></tr></tbody></table></figure><p>从输出可以看出来，还是普通的KNN模型准确性较高，其准确性也达到了将近 73 %，与所有特征拿来一块儿训练的准确性差不多。这也侧面证明了 <code>SelectKBest</code> 特征选择的有效性。</p><p>回到目标上来，我们是想看看为什么KNN无法很好地拟合训练样本。现在我们只有 2 个特征，可以很方便地在二维坐标上画出所有的训练样本，观察这些数据的分布情况：</p><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">10</span>, <span class="number">6</span>))</span><br><span class="line">plt.ylabel(<span class="string">"BMI"</span>)</span><br><span class="line">plt.xlabel(<span class="string">"Glucose"</span>)</span><br><span class="line">plt.scatter(X_new[Y==<span class="number">0</span>][:, <span class="number">0</span>], X_new[Y==<span class="number">0</span>][:, <span class="number">1</span>], c=<span class="string">'r'</span>, s=<span class="number">20</span>, marker=<span class="string">'o'</span>);   <span class="comment">#画出样本</span></span><br><span class="line">plt.scatter(X_new[Y==<span class="number">1</span>][:, <span class="number">0</span>], X_new[Y==<span class="number">1</span>][:, <span class="number">1</span>], c=<span class="string">'g'</span>, s=<span class="number">20</span>, marker=<span class="string">'^'</span>);   <span class="comment">#画出样本</span></span><br></pre></td></tr></tbody></table></figure><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/image-20200629102028938.png" style="zoom:67%;"><p>横坐标是血糖值 Glucose，纵坐标是BMI值，反映身体肥胖情况。从图中可以看出，在中间数据集密集的区域，阳性样本和阴性样本几乎重叠在一起了。假设现在有一个待预测的样本在中间密集区域，它的阳性邻居多还是阴性邻居多呢？这真的很难说。这样就可以直观地看到，KNN算法在这个糖尿病预测问题上，无法达到很高的预测准确性。</p><h3 id="拓展阅读"><a href="#拓展阅读" class="headerlink" title="拓展阅读"></a>拓展阅读</h3><p>这里再继续再介绍一下特征选择时，计算相关性大小的 <code>SelectKBest()</code> 函数背后的统计学知识。</p><h4 id="如何提高KNN算法的运算效率"><a href="#如何提高KNN算法的运算效率" class="headerlink" title="如何提高KNN算法的运算效率"></a>如何提高KNN算法的运算效率</h4><p>根据算法原理，每次需要预测一个点时，我们都需要计算训练数据集里每个点到这个点的距离，然后选出距离最近的k个点进行投票。当数据集很大时，这个计算成本非常高。针对$N$个样本，$D$个特征的数据集，其算法复杂度为$O(DN^2)$。</p><p>为了解决这个问题，一种叫<code>K-D Tree</code> 的数据结构被发明出来。为了避免每次都重新计算一遍距离，算法会把距离信息保存在一棵树里，这样在计算之前从树里查询距离信息，尽量避免重新计算。其基本原理是，如果A和B距离很远，B和C距离很近，那么A和C的距离也很远。有了这个信息，就可以在合适的时候跳过距离远的点。这样优化后的算法复杂度可降低到$O(DNlog(N))$。感兴趣的读者可参阅论文：Bentley, J.L., Communications of the ACM (1975)。</p><p>1989年，另外一种称为<code>Ball Tree</code>的算法，在<code>K-D Tree</code>的基础上对性能进一步进行了优化。感兴趣的读者可以搜索Five balltree construction algorithms来了解详细的算法信息。</p><h4 id="相关性测试"><a href="#相关性测试" class="headerlink" title="相关性测试"></a>相关性测试</h4><p>先通过一个简单的例子来看假设检验问题，即判断假设的结论是否成立或成立的概率有多高。假设，在一个城市随机采样到程序员和性别的关系的数据：</p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-0c82f9f4005936fa.png" style="zoom:50%;"><p>假设，我们的结论是程序员和性别无关，这个假设称为原假设（null hypothesis）。问：通过我们随机采样观测到的数据，原假设是否成立，或者说原假设成立的概率有多高？</p><p><code>卡方检验（chi-squared test）</code>是检测假设成立与否的一个常用的工具。它的计算公式是：</p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-3a52b648ce9e2196.png" style="zoom:50%;"><p>其中，卡方检验的值记为 ,  $O$ 是观测值，$E$  是期望值。针对我们的例子，如果原假设成立，即程序员职业和性别无关，那么我们期望的男程序员数量应该为(14/489) * 242=6.928，女程序员数量应该为(14/489) * 247=7.072，同理可得到我们的期望值如下：</p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-9f2c88dc6a7eeb66.png" style="zoom:50%;"><p> 根据卡方检验的公式，可以算出卡方值为：</p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/17634123-bf0dbd2fd6c8db0c.png" style="zoom:50%;"><p> 算出卡方值后，怎么判断原假设成立的概率是多少呢？这里还涉及到自由度和卡方分布的概念。简单地讲，自由度是$(r-1)×(c-1)$，其中 r 是行数，c 是列数，针对我们的问题，其自由度为1。卡方分布是指，若n个相互独立的随机变量均服从正态分布，则这 n 个随机变量的平方和构成一新的随机变量，其分布规律称为卡方分布。卡方分布的密度函数和自由度相关，知道了自由度和目标概率，我们就能求出卡方值。</p><p>针对我们的问题，可以查表得到，自由度为1的卡方分布，在99%处的卡方值为6.63。我们计算出来的卡方值为7.670。由于7.67&gt;6.63，故有99%的把握可以推翻原假设。换个说法，如果原假设成立，即程序员职业和性别无关，那么我们随机采样到的数据出现的概率将低于1%。我们可以搜索<code>“卡方表”</code>或<code>“Chi Squared Table”</code>找到不同自由度对应的卡方值。</p><p>卡方值的大小可以反映变量与目标值的相关性，值越大，相关性越大。利用这一特性，<code>SelectKBest()</code> 函数就可以计算不同特征的卡方值来判断特征与输出值的相关性大小，从而完成特征选择。在<code>scikit-learn</code>里，计算卡方值的函数是 <code>sklearn.feature_selection.chi2()</code>。除了卡方检验外，还有<code>F值检验</code>等算法，也可以用来评估特征与目标值的相关性。<code>SelectKBest</code> 默认使用的就是F值检验算法，在<code>scikit-learn</code>里，使用<code>sklearn.feature_selection.f_classif</code>来计算F值。关于F值相关的资料，感兴趣的读者可以在英文版维基百科上搜索<code>“Fisher’sexact test”</code>，了解更多信息。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scikit-learn系列一：机器学习基础</title>
      <link href="/2020/06/28/scikit-learn-xi-lie-yi-ji-qi-xue-xi-ji-chu/"/>
      <url>/2020/06/28/scikit-learn-xi-lie-yi-ji-qi-xue-xi-ji-chu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自作者: 片刻1998<br>GitHub地址:  <a href="https://github.com/apachecn/AiLearning">https://github.com/apachecn/AiLearning</a></p></blockquote><h2 id="机器学习-概述"><a href="#机器学习-概述" class="headerlink" title="机器学习 概述"></a>机器学习 概述</h2><p><code>机器学习(Machine Learning,ML)</code> 是使用计算机来彰显数据背后的真实含义，它为了把无序的数据转换成有用的信息。是一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、算法复杂度理论等多门学科。专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身的性能。<br>它是人工智能的核心，是使计算机具有智能的根本途径，其应用遍及人工智能的各个领域，它主要使用归纳、综合而不是演绎。</p><ol><li>海量的数据</li><li>获取有用的信息</li></ol><h2 id="机器学习-研究意义"><a href="#机器学习-研究意义" class="headerlink" title="机器学习 研究意义"></a>机器学习 研究意义</h2><p>机器学习是一门人工智能的科学，该领域的主要研究对象是人工智能，特别是如何在经验学习中改善具体算法的性能”。 “机器学习是对能通过经验自动改进的计算机算法的研究”。 “机器学习是用数据或以往的经验，以此优化计算机程序的性能标准。” 一种经常引用的英文定义是: A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.</p><p>机器学习已经有了十分广泛的应用，例如: 数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、医学诊断、检测信用卡欺诈、证券市场分析、DNA序列测序、语音和手写识别、战略游戏和机器人运用。</p><h2 id="机器学习-场景"><a href="#机器学习-场景" class="headerlink" title="机器学习 场景"></a>机器学习 场景</h2><ul><li><p>例如: 识别动物猫</p><ul><li>模式识别（官方标准）: 人们通过大量的经验，得到结论，从而判断它就是猫。</li><li>机器学习（数据学习）: 人们通过阅读进行学习，观察它会叫、小眼睛、两只耳朵、四条腿、一条尾巴，得到结论，从而判断它就是猫。</li><li>深度学习（深入数据）: 人们通过深入了解它，发现它会’喵喵’的叫、与同类的猫科动物很类似，得到结论，从而判断它就是猫。（深度学习常用领域: 语音识别、图像识别）</li></ul></li><li><p>模式识别（pattern recognition）: 模式识别是最古老的（作为一个术语而言，可以说是很过时的）。</p><ul><li>我们把环境与客体统称为“模式”，识别是对模式的一种认知，是如何让一个计算机程序去做一些看起来很“智能”的事情。</li><li>通过融于智慧和直觉后，通过构建程序，识别一些事物，而不是人，例如: 识别数字。</li></ul></li><li><p>机器学习（machine learning）: 机器学习是最基础的（当下初创公司和研究实验室的热点领域之一）。</p><ul><li>在90年代初，人们开始意识到一种可以更有效地构建模式识别算法的方法，那就是用数据（可以通过廉价劳动力采集获得）去替换专家（具有很多图像方面知识的人）。</li><li>“机器学习”强调的是，在给计算机程序（或者机器）输入一些数据后，它必须做一些事情，那就是学习这些数据，而这个学习的步骤是明确的。</li><li>机器学习（Machine Learning）是一门专门研究计算机怎样模拟或实现人类的学习行为，以获取新的知识或技能，重新组织已有的知识结构使之不断改善自身性能的学科。</li></ul></li><li><p>深度学习（deep learning）: 深度学习是非常崭新和有影响力的前沿领域，我们甚至不会去思考-后深度学习时代。</p><ul><li>深度学习是机器学习研究中的一个新的领域，其动机在于建立、模拟人脑进行分析学习的神经网络，它模仿人脑的机制来解释数据，例如图像，声音和文本。</li></ul></li><li><p>参考地址:  </p><ul><li><a href="http://www.csdn.net/article/2015-03-24/2824301">深度学习 vs 机器学习 vs 模式识别</a></li><li><a href="http://baike.baidu.com/link?url=76P-uA4EBrC3G-I__P1tqeO7eoDS709Kp4wYuHxc7GNkz_xn0NxuAtEohbpey7LUa2zUQLJxvIKUx4bnrEfOmsWLKbDmvG1PCoRkJisMTQka6-QReTrIxdYY3v93f55q">深度学习 百科资料</a></li></ul></li></ul><blockquote><p>机器学习已应用于多个领域，远远超出大多数人的想象，横跨: 计算机科学、工程技术和统计学等多个学科。</p></blockquote><ul><li>搜索引擎: 根据你的搜索点击，优化你下次的搜索结果,是机器学习来帮助搜索引擎判断哪个结果更适合你（也判断哪个广告更适合你）。</li><li>垃圾邮件: 会自动的过滤垃圾广告邮件到垃圾箱内。</li><li>超市优惠券: 你会发现，你在购买小孩子尿布的时候，售货员会赠送你一张优惠券可以兑换6罐啤酒。</li><li>邮局邮寄: 手写软件自动识别寄送贺卡的地址。</li><li>申请贷款: 通过你最近的金融活动信息进行综合评定，决定你是否合格。</li></ul><h2 id="机器学习-组成"><a href="#机器学习-组成" class="headerlink" title="机器学习 组成"></a>机器学习 组成</h2><h3 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h3><ul><li>分类（classification）: 将实例数据划分到合适的类别中。<ul><li>应用实例: 判断网站是否被黑客入侵（二分类 ），手写数字的自动识别（多分类）</li></ul></li><li>回归（regression）: 主要用于预测数值型数据。<ul><li>应用实例: 股票价格波动的预测，房屋价格的预测等。</li></ul></li></ul><h3 id="监督学习（supervised-learning）"><a href="#监督学习（supervised-learning）" class="headerlink" title="监督学习（supervised learning）"></a>监督学习（supervised learning）</h3><ul><li>必须确定目标变量的值，以便机器学习算法可以发现特征和目标变量之间的关系。在监督学习中，给定一组数据，我们知道正确的输出结果应该是什么样子，并且知道在输入和输出之间有着一个特定的关系。 (包括: 分类和回归)</li><li>样本集: 训练数据 + 测试数据<ul><li>训练样本 = 特征(feature) + 目标变量(label: 分类-离散值/回归-连续值)</li><li>特征通常是训练样本集的列，它们是独立测量得到的。</li><li>目标变量: 目标变量是机器学习预测算法的测试结果。<ul><li>在分类算法中目标变量的类型通常是标称型(如: 真与假)，而在回归算法中通常是连续型(如: 1~100)。</li></ul></li></ul></li><li>监督学习需要注意的问题: <ul><li>偏置方差权衡</li><li>功能的复杂性和数量的训练数据</li><li>输入空间的维数</li><li>噪声中的输出值</li></ul></li><li><code>知识表示</code>: <ul><li>可以采用规则集的形式【例如: 数学成绩大于90分为优秀】</li><li>可以采用概率分布的形式【例如: 通过统计分布发现，90%的同学数学成绩，在70分以下，那么大于70分定为优秀】</li><li>可以使用训练样本集中的一个实例【例如: 通过样本集合，我们训练出一个模型实例，得出 年轻，数学成绩中高等，谈吐优雅，我们认为是优秀】</li></ul></li></ul><h3 id="非监督学习（unsupervised-learning）"><a href="#非监督学习（unsupervised-learning）" class="headerlink" title="非监督学习（unsupervised learning）"></a>非监督学习（unsupervised learning）</h3><ul><li>在机器学习，无监督学习的问题是，在未加标签的数据中，试图找到隐藏的结构。因为提供给学习者的实例是未标记的，因此没有错误或报酬信号来评估潜在的解决方案。</li><li>无监督学习是密切相关的统计数据密度估计的问题。然而无监督学习还包括寻求，总结和解释数据的主要特点等诸多技术。在无监督学习使用的许多方法是基于用于处理数据的数据挖掘方法。</li><li>数据没有类别信息，也不会给定目标值。</li><li>非监督学习包括的类型: <ul><li>聚类: 在无监督学习中，将数据集分成由类似的对象组成多个类的过程称为聚类。</li><li>密度估计: 通过样本分布的紧密程度，来估计与分组的相似性。</li><li>此外，无监督学习还可以减少数据特征的维度，以便我们可以使用二维或三维图形更加直观地展示数据信息。</li></ul></li></ul><h3 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h3><p>这个算法可以训练程序做出某一决定。程序在某一情况下尝试所有的可能行动，记录不同行动的结果并试着找出最好的一次尝试来做决定。 属于这一类算法的有马尔可夫决策过程。</p><h3 id="训练过程"><a href="#训练过程" class="headerlink" title="训练过程"></a>训练过程</h3><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E8%AE%AD%E7%BB%83%E8%BF%87%E7%A8%8B.jpg" alt="机器学习训练过程图"></p><h3 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h3><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/ml_algorithm.jpg" alt="算法汇总"></p><h2 id="机器学习-使用"><a href="#机器学习-使用" class="headerlink" title="机器学习 使用"></a>机器学习 使用</h2><blockquote><p>选择算法需要考虑的两个问题</p></blockquote><ol><li>算法场景<ul><li>预测明天是否下雨，因为可以用历史的天气情况做预测，所以选择监督学习算法</li><li>给一群陌生的人进行分组，但是我们并没有这些人的类别信息，所以选择无监督学习算法、通过他们身高、体重等特征进行处理。</li></ul></li><li>需要收集或分析的数据是什么</li></ol><blockquote><p>举例</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80-%E9%80%89%E6%8B%A9%E7%AE%97%E6%B3%95.jpg" alt="选择算法图"></p><blockquote><p>机器学习 开发流程</p></blockquote><ol><li>收集数据: 收集样本数据</li><li>准备数据: 注意数据的格式</li><li>分析数据: 为了确保数据集中没有垃圾数据；<ul><li>如果是算法可以处理的数据格式或可信任的数据源，则可以跳过该步骤；</li><li>另外该步骤需要人工干预，会降低自动化系统的价值。</li></ul></li><li>训练算法: [机器学习算法核心]如果使用无监督学习算法，由于不存在目标变量值，则可以跳过该步骤</li><li>测试算法: [机器学习算法核心]评估算法效果</li><li>使用算法: 将机器学习算法转为应用程序</li></ol><h2 id="机器学习-数学基础"><a href="#机器学习-数学基础" class="headerlink" title="机器学习 数学基础"></a>机器学习 数学基础</h2><ul><li>微积分</li><li>统计学/概率论</li><li>线性代数</li></ul><h2 id="机器学习-工具"><a href="#机器学习-工具" class="headerlink" title="机器学习 工具"></a>机器学习 工具</h2><h3 id="Python语言"><a href="#Python语言" class="headerlink" title="Python语言"></a>Python语言</h3><ol><li>可执行伪代码</li><li>Python比较流行: 使用广泛、代码范例多、丰富模块库，开发周期短</li><li>Python语言的特色: 清晰简练、易于理解</li><li>Python语言的缺点: 唯一不足的是性能问题</li><li>Python相关的库<ul><li>科学函数库: <code>SciPy</code>、<code>NumPy</code>(底层语言: C和Fortran)</li><li>绘图工具库: <code>Matplotlib</code></li><li>数据分析库 <code>Pandas</code></li></ul></li></ol><h3 id="数学工具"><a href="#数学工具" class="headerlink" title="数学工具"></a>数学工具</h3><ul><li>Matlab</li></ul><h2 id="附-机器学习专业术语"><a href="#附-机器学习专业术语" class="headerlink" title="附: 机器学习专业术语"></a>附: 机器学习专业术语</h2><ul><li>模型（model）: 计算机层面的认知</li><li>学习算法（learning algorithm），从数据中产生模型的方法</li><li>数据集（data set）: 一组记录的合集</li><li>示例（instance）: 对于某个对象的描述</li><li>样本（sample）: 也叫示例</li><li>属性（attribute）: 对象的某方面表现或特征</li><li>特征（feature）: 同属性</li><li>属性值（attribute value）: 属性上的取值</li><li>属性空间（attribute space）: 属性张成的空间</li><li>样本空间/输入空间（samplespace）: 同属性空间</li><li>特征向量（feature vector）: 在属性空间里每个点对应一个坐标向量，把一个示例称作特征向量</li><li>维数（dimensionality）: 描述样本参数的个数（也就是空间是几维的）</li><li>学习（learning）/训练（training）: 从数据中学得模型</li><li>训练数据（training data）: 训练过程中用到的数据</li><li>训练样本（training sample）:训练用到的每个样本</li><li>训练集（training set）: 训练样本组成的集合</li><li>假设（hypothesis）: 学习模型对应了关于数据的某种潜在规则</li><li>真相（ground-truth）:真正存在的潜在规律</li><li>学习器（learner）: 模型的另一种叫法，把学习算法在给定数据和参数空间的实例化</li><li>预测（prediction）: 判断一个东西的属性</li><li>标记（label）: 关于示例的结果信息，比如我是一个“好人”。</li><li>样例（example）: 拥有标记的示例</li><li>标记空间/输出空间（label space）: 所有标记的集合</li><li>分类（classification）: 预测是离散值，比如把人分为好人和坏人之类的学习任务</li><li>回归（regression）: 预测值是连续值，比如你的好人程度达到了0.9，0.6之类的</li><li>二分类（binary classification）: 只涉及两个类别的分类任务</li><li>正类（positive class）: 二分类里的一个</li><li>反类（negative class）: 二分类里的另外一个</li><li>多分类（multi-class classification）: 涉及多个类别的分类</li><li>测试（testing）: 学习到模型之后对样本进行预测的过程</li><li>测试样本（testing sample）: 被预测的样本</li><li>聚类（clustering）: 把训练集中的对象分为若干组</li><li>簇（cluster）: 每一个组叫簇</li><li>监督学习（supervised learning）: 典范–分类和回归</li><li>无监督学习（unsupervised learning）: 典范–聚类</li><li>未见示例（unseen instance）: “新样本“，没训练过的样本</li><li>泛化（generalization）能力: 学得的模型适用于新样本的能力</li><li>分布（distribution）: 样本空间的全体样本服从的一种规律</li><li>独立同分布（independent and identically distributed，简称i,i,d.）:获得的每个样本都是独立地从这个分布上采样获得的。</li></ul><h2 id="机器学习基础补充"><a href="#机器学习基础补充" class="headerlink" title="机器学习基础补充"></a>机器学习基础补充</h2><h3 id="数据集的划分"><a href="#数据集的划分" class="headerlink" title="数据集的划分"></a>数据集的划分</h3><ul><li>训练集（Training set） —— 学习样本数据集，通过匹配一些参数来建立一个模型，主要用来训练模型。类比考研前做的解题大全。</li><li>验证集（validation set） —— 对学习出来的模型，调整模型的参数，如在神经网络中选择隐藏单元数。验证集还用来确定网络结构或者控制模型复杂程度的参数。类比 考研之前做的模拟考试。</li><li>测试集（Test set） —— 测试训练好的模型的分辨能力。类比 考研。这次真的是一考定终身。</li></ul><h3 id="模型拟合程度"><a href="#模型拟合程度" class="headerlink" title="模型拟合程度"></a>模型拟合程度</h3><ul><li>欠拟合（Underfitting）: 模型没有很好地捕捉到数据特征，不能够很好地拟合数据，对训练样本的一般性质尚未学好。类比，光看书不做题觉得自己什么都会了，上了考场才知道自己啥都不会。</li><li>过拟合（Overfitting）: 模型把训练样本学习“太好了”，可能把一些训练样本自身的特性当做了所有潜在样本都有的一般性质，导致泛化能力下降。类比，做课后题全都做对了，超纲题也都认为是考试必考题目，上了考场还是啥都不会。 </li></ul><p>通俗来说，欠拟合和过拟合都可以用一句话来说，欠拟合就是: “你太天真了！”，过拟合就是: “你想太多了！”。</p><h3 id="常见的模型指标"><a href="#常见的模型指标" class="headerlink" title="常见的模型指标"></a>常见的模型指标</h3><ul><li>正确率 —— 提取出的正确信息条数 / 提取出的信息条数</li><li>召回率 —— 提取出的正确信息条数 / 样本中的信息条数</li><li>F 值 —— 正确率 * 召回率 * 2 / （正确率 + 召回率）（F值即为正确率和召回率的调和平均值）</li></ul><p>举个例子如下: </p><p>举个例子如下:<br>某池塘有 1400 条鲤鱼，300 只虾，300 只乌龟。现在以捕鲤鱼为目的。撒了一张网，逮住了 700 条鲤鱼，200 只<br>虾， 100 只乌龟。那么这些指标分别如下:<br>正确率 = 700 / (700 + 200 + 100) = 70%<br>召回率 = 700 / 1400 = 50%<br>F 值 = 70% * 50% * 2 / (70% + 50%) = 58.3%</p><h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><ul><li>分类问题 —— 说白了就是将一些未知类别的数据分到现在已知的类别中去。比如，根据你的一些信息，判断你是高富帅，还是穷屌丝。评判分类效果好坏的三个指标就是上面介绍的三个指标: 正确率，召回率，F值。</li><li>回归问题 —— 对数值型连续随机变量进行预测和建模的监督学习算法。回归往往会通过计算 误差（Error）来确定模型的精确性。</li><li>聚类问题 —— 聚类是一种无监督学习任务，该算法基于数据的内部结构寻找观察样本的自然族群（即集群）。聚类问题的标准一般基于距离: 簇内距离（Intra-cluster Distance） 和 簇间距离（Inter-cluster Distance） 。簇内距离是越小越好，也就是簇内的元素越相似越好；而簇间距离越大越好，也就是说簇间（不同簇）元素越不相同越好。一般的，衡量聚类问题会给出一个结合簇内距离和簇间距离的公式。</li></ul><p>下面这个图可以比较直观地展示出来: </p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/ml_add_2.jpg" alt=""></p><h3 id="特征工程的一些小东西"><a href="#特征工程的一些小东西" class="headerlink" title="特征工程的一些小东西"></a>特征工程的一些小东西</h3><ul><li><p>特征选择 —— 也叫特征子集选择（FSS，Feature Subset Selection）。是指从已有的 M 个特征（Feature）中选择 N 个特征使得系统的特定指标最优化，是从原始特征中选择出一些最有效特征以降低数据集维度的过程，是提高算法性能的一个重要手段，也是模式识别中关键的数据预处理步骤。</p></li><li><p>特征提取 —— 特征提取是计算机视觉和图像处理中的一个概念。它指的是使用计算机提取图像信息，决定每个图像的点是否属于一个图像特征。特征提取的结果是把图像上的点分为不同的子集，这些子集往往属于孤立的点，连续的曲线或者连续的区域。</p></li></ul><p>下面给出一个特征工程的图: </p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/ml_add_1.jpg" alt=""></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><p>Learning rate —— 学习率，通俗地理解，可以理解为步长，步子大了，很容易错过最佳结果。就是本来目标尽在咫尺，可是因为我迈的步子很大，却一下子走过了。步子小了呢，就是同样的距离，我却要走很多很多步，这样导致训练的耗时费力还不讨好。</p></li><li><p>机器学习的数学基础 : <a href="https://zhuanlan.zhihu.com/p/25197792">https://zhuanlan.zhihu.com/p/25197792</a></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客备份</title>
      <link href="/2020/06/28/hexo-bo-ke-bei-fen/"/>
      <url>/2020/06/28/hexo-bo-ke-bei-fen/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dongzhougu.github.io/2020/06/27/shi-yong-hexo-da-jian-github-bo-ke/">上一篇文章</a>已经具体讲述了博客的搭建与基本使用，接下来记录博客的备份工作。</p><h4 id="初始备份"><a href="#初始备份" class="headerlink" title="初始备份"></a>初始备份</h4><ul><li><p>创建一个仓库用来存放备份文件，我的名字选择 <strong><a href="https://github.com/DongZhouGu/Blog-backup">Blog-backup</a></strong>，勾选README。</p></li><li><p>复制仓库地址，运行Git将仓库clone到本地。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:DongZhouGu/Blog-backup.git</span><br></pre></td></tr></tbody></table></figure></li><li><p>将要备份的文件放到我们刚才clone的文件夹里面。</p></li><li><p>在 clone 的文件夹下运行 Git，依次输入以下命令：</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit  -m  <span class="string">"博客备份"</span>  （注：“backup”里面换成你需要，如“first commit”）</span><br><span class="line">git push -u origin master   （注：此操作目的是把本地仓库push到github上面，如果没有使用密钥此步骤需要你输入帐号和密码）</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="更新备份"><a href="#更新备份" class="headerlink" title="更新备份"></a>更新备份</h4><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit  -m  <span class="string">"博客备份"</span></span><br><span class="line">git push origin master</span><br></pre></td></tr></tbody></table></figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客优化加速</title>
      <link href="/2020/06/27/hexo-bo-ke-you-hua-jia-su/"/>
      <url>/2020/06/27/hexo-bo-ke-you-hua-jia-su/</url>
      
        <content type="html"><![CDATA[<p><a href="https://dongzhougu.github.io/2020/06/27/shi-yong-hexo-da-jian-github-bo-ke/">上一篇文章</a>已经具体讲述了博客的搭建与基本使用，接下来记录一下对博客的优化的工作，从<code>图片加载优化</code>和 <code>PicGo  图床</code>来介绍。</p><h3 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h3><h4 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h4><blockquote><p><code>预加载</code>就是进入项目前提前加载资源，避免在项目中加载缓慢，影响用户体验</p><p><code>懒加载</code>一般是当图片滚动进可视窗口内才加载图片，可视窗口之外的图片则不加载</p></blockquote><p><a href="https://github.com/blinkfox/hexo-theme-matery">matery主题</a>  整体采用预加载模式，这样可以在我们访问其他页面的时候会稍微快点。我们可以在这个基础上对图片进行懒加载，这样做效果就是 html、css、js 加载之后，图片再加载。既保证了网页的打开速度，也不会因图片的庞大体积而拖累了整个页面的加载。</p><h4 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h4><ul><li><p>在 Blog 根目录执行</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></tbody></table></figure></li><li><p>在根目录下的 <code>_config.yml</code> 中添加对应配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lazyload:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span> </span><br><span class="line">  onlypost: <span class="literal">false</span>  <span class="comment"># 是否只对文章的图片做懒加载</span></span><br><span class="line">  loadingImg: <span class="comment"># eg ./images/loading.gif</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="设置插件"><a href="#设置插件" class="headerlink" title="设置插件"></a>设置插件</h4><ul><li><p>修改 <code>/themes/matery/source/js</code> 中的 <code>matery.js</code>文件,在第108行加上：</p><figure class="highlight js"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).find(<span class="string">'img[data-original]'</span>).each(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>{</span><br><span class="line">    $(<span class="built_in">this</span>).parent().attr(<span class="string">"href"</span>, $(<span class="built_in">this</span>).attr(<span class="string">"data-original"</span>));</span><br><span class="line">});</span><br></pre></td></tr></tbody></table></figure></li><li><p>打开 <code>/themes/matery/layout/_partial/header.ejs</code>文件，</p><p>在<code>img</code>和<code>span</code>的两个头加个<code>div</code>：</p><figure class="highlight html"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"brand-logo"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&lt;%- url_for() %&gt;"</span> <span class="attr">class</span>=<span class="string">"waves-effect waves-light"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">            &lt;% if (theme.logo !== undefined &amp;&amp; theme.logo.length &gt; 0) { %&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"&lt;%= theme.logo %&gt;"</span> <span class="attr">class</span>=<span class="string">"logo-img"</span> <span class="attr">alt</span>=<span class="string">"LOGO"</span>&gt;</span></span><br><span class="line">            &lt;% } %&gt;</span><br><span class="line">            <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"logo-span"</span>&gt;</span>&lt;%- config.title %&gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="自定义loading图片"><a href="#自定义loading图片" class="headerlink" title="自定义loading图片"></a>自定义loading图片</h4><p><code>hexo-lazyload-image</code> 插件提供了自定义loading图片的选项，在 <code>loadingImg</code> 后配置图片的路径即可。</p><h3 id="使用PicGo图床"><a href="#使用PicGo图床" class="headerlink" title="使用PicGo图床"></a>使用PicGo图床</h3><p>PicGo 是一款开源的图床软件，该软件与iPic的不分伯仲，文档支持中文，支持插件开发。</p><h4 id="安装-PicGo"><a href="#安装-PicGo" class="headerlink" title="安装 PicGo"></a>安装 PicGo</h4><p>下载地址 <a href="https://github.com/Molunerfinn/PicGo/releases">https://github.com/Molunerfinn/PicGo/releases</a> ，选择下载与系统匹配的安装包，正常安装即可。</p><p>下载速度非常慢。。。备用地址：<a href="https://pan.baidu.com/s/1t3wookLIEE4NSXuaGABGPg">链接</a> 提取码：btzt</p><h4 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h4><p>创建一个用于存放图片的仓库，之后依次点击 <code>Setting</code> —— <code>Developer settings</code> —— <code>Personal access tokens</code>  创建一个token，并复制下来。</p><h4 id="配置-PicGo"><a href="#配置-PicGo" class="headerlink" title="配置 PicGo"></a>配置 PicGo</h4><p>下载完成后进行安装，安装完毕后开始配置，如图：</p><p><img src="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1/20200628130208.png" alt=""></p><p><code>设定仓库名</code> 按照“账户名/仓库名的格式填写”，比如我的是：DongZhouGu/imageuse1</p><p><code>分支名</code>统一填写“master”。</p><p><code>设定Token</code>将之前的Token粘贴在这里。</p><p><code>指定存储路径</code>留空。</p><p><code>自定义域名</code>上传图片后成功后，PicGo会将“自定义域名+上传的图片名”生成的访问链接，放到剪切板上。默认留空也可以正常使用。这里为了使用CDN加快图片的访问速度，自定义域名我们按照这样去填写</p><blockquote><p><em><a href="https://cdn.jsdelivr.net/gh/GitHub用户名/仓库名">https://cdn.jsdelivr.net/gh/GitHub用户名/仓库名</a></em></p><p>我的是：<a href="https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1">https://cdn.jsdelivr.net/gh/dongzhougu/imageuse1</a></p></blockquote><p>之后就可以正常使用了</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo搭建Github博客</title>
      <link href="/2020/06/27/shi-yong-hexo-da-jian-github-bo-ke/"/>
      <url>/2020/06/27/shi-yong-hexo-da-jian-github-bo-ke/</url>
      
        <content type="html"><![CDATA[<p>以下为搭建本博客的教程<strong>(针对windows)</strong>，记录一下自己的过程，也方便想要建站的小伙伴快速上手。</p><blockquote><p><code>Github Pages:</code> 可以被认为是用户编写的、托管在 Github 上的静态网页。使用 Github Pages 可以为你提供一个免费的服务器，免去了自己搭建服务器和写数据库的麻烦。此外还可以绑定自己的域名。</p><p><code>Hexo</code>: 一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>下面从<strong>搭建前的准备工作</strong>，<strong>Github 部署</strong>，<strong>优化设置博客</strong>(使用  <code>matery</code>  主题)三方面详细介绍。</p><h3 id="1-搭建前的准备工作"><a href="#1-搭建前的准备工作" class="headerlink" title="1. 搭建前的准备工作"></a>1. 搭建前的准备工作</h3><h4 id="1-1-环境安装"><a href="#1-1-环境安装" class="headerlink" title="1.1 环境安装"></a>1.1 环境安装</h4><ul><li><p>安装  <a href="https://nodejs.org/en/">Node.js</a>（点击前往官网），请确保勾选  <strong>Add to PATH</strong>  选项（默认已勾选），这里可以参考 Hexo 的官方<a href="https://hexo.io/zh-cn/docs/">参考文档</a>。</p></li><li><p>安装<a href="https://git-scm.com/downloads">Git</a>(点击前往官网)，一路默认安装即可。</p></li><li><p>鼠标右键点击  <code>Git Bash Here</code> ,分别使用  <code>node -v</code>  和  <code>npm -v</code>  来验证安装，显示版本号则安装成功。</p></li></ul><h4 id="1-2-Hexo安装"><a href="#1-2-Hexo安装" class="headerlink" title="1.2 Hexo安装"></a>1.2 Hexo安装</h4><ul><li><p>新建一个存放博客的文件夹，比如  <code>E:\notebook\my_blog</code>，在此文件夹下右键点击  <code>Git Bash Here</code></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></tbody></table></figure><p>安装完成后使用  <code>hexo -v</code>  检测是否安装成功</p></li><li><p>执行初始化并在本地查看效果</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></tbody></table></figure><p>完成后使用</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></tbody></table></figure><p>然后会出来一段 http 开头的网址，我们复制下来然后在浏览器打开，就可以看到初始化的 Hexo 的页面了。</p></li></ul><h3 id="2-Github部署"><a href="#2-Github部署" class="headerlink" title="2. Github部署"></a>2. Github部署</h3><ul><li><p><strong>创建一个仓库</strong>，名字必须是  <code>用户名.github.io</code>  ，然后勾选初始化 README。我第一次访问不了就是因为 github 竟然打错了，打错了，打错了…</p></li><li><p><strong>创建一个git秘钥</strong>，用来在这台电脑上通过 git 操作实现本地代码库与 Github 代码库同步</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C “your_email@youremail.com“</span><br></pre></td></tr></tbody></table></figure><p><code>your_email@youremail.com</code>  为你的 Github 邮箱地址，比如我的是  <code>gdz678@163.com</code></p><p>不管出现什么信息，只需要回车就可以了。接着，运行下面的命令将秘钥复制到剪切板</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ clip &lt; ~/.ssh/id_rsa.pub</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>在 GitHub 账户中添加秘钥</strong>，进入 Github 的设置，点击  <code>Settings–SSH</code>  ——  <code>New SSH Key</code>，添加刚才复制的秘钥即可。</p></li><li><p><strong>测试</strong>，输入以下命令：注意：<code>git@github.com</code>不要做任何更改！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></tbody></table></figure><p>根据返回，输入 <code>yes</code> 会显示成功授权</p></li><li><p><strong>配置 Git 个人信息</strong>，Git 会根据用户的名字和邮箱来记录提交，GitHub 也是用这些信息来做权限的处理，输入以下命令进行个人信息的设置，把名称和邮箱替换成你自己的，名字可以不是 GitHub 的昵称，但为了方便记忆，建议与 GitHub 一致。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"此处填你的用户名"</span>  </span><br><span class="line">$ git config --global user.email  <span class="string">"此处填你的邮箱"</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>将本地的 Hexo 文件更新到 Github 的库中</strong>，登录 Github 打开博客的项目，鼠标移到 <code>Clone or download</code> 按钮，选择 <code>Use SSH</code> 一键复制地址后，打开刚才创建的博客文件夹下的 <code>_config.yaml</code>文件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: 你复制的地址</span><br><span class="line">  branch: master</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>部署到 Github</strong>,首先安装  <code>deployer</code> </p><figure class="highlight plaintext"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure><p>接着执行,博客就部署到 Github 上了</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g -d</span><br></pre></td></tr></tbody></table></figure><p>最后，你的博客地址：https://你的用户名.github.io，比如我的是：<a href="https://dongzhougu.github.io">https://dongzhougu.github.io</a> ,现在每个人都可以通过此链接访问我的博客！</p></li></ul><h3 id="3-优化设置博客"><a href="#3-优化设置博客" class="headerlink" title="3. 优化设置博客"></a>3. 优化设置博客</h3><h4 id="3-1-安装主题"><a href="#3-1-安装主题" class="headerlink" title="3.1 安装主题"></a>3.1 安装主题</h4><ul><li><p>安装 <a href="https://github.com/blinkfox/hexo-theme-matery">Metary</a> 主题。cd 到 Blog 目录下的 <code>Themes</code> 文件夹</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/blinkfox/hexo-theme-matery.git</span><br></pre></td></tr></tbody></table></figure></li><li><p>编辑站点配置文件 <code>_config.yml</code>,修改主题</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: hexo-theme-matery</span><br></pre></td></tr></tbody></table></figure></li></ul><blockquote><p><strong>主题的具体美化和设置可以<a href="http://blinkfox.com/2018/09/28/qian-duan/hexo-bo-ke-zhu-ti-zhi-hexo-theme-matery-de-jie-shao/#toc-heading-19">参考这里</a>。</strong></p></blockquote><h4 id="3-2-安装插件"><a href="#3-2-安装插件" class="headerlink" title="3.2 安装插件"></a>3.2 安装插件</h4><p>cd到博客的根目录，分别运行以下，来安装插件</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save                 <span class="comment">#RSS</span></span><br><span class="line">npm install hexo-generator-search --save               <span class="comment">#搜索</span></span><br><span class="line">npm install hexo-prism-plugin --save                   <span class="comment">#代码高亮     </span></span><br><span class="line">npm install hexo-wordcount --save                      <span class="comment">#文章字数统计</span></span><br><span class="line">npm i hexo-permalink-pinyin --save</span><br><span class="line">npm install hexo-filter-github-emojis --save           <span class="comment">#添加emoji表情支持</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p><strong>RSS</strong> :  在根目录下的 <code>_config.yml</code> 中添加对应配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">feed:</span><br><span class="line">  <span class="built_in">type</span>: atom</span><br><span class="line">  path: atom.xml</span><br><span class="line">  <span class="built_in">limit</span>: 20</span><br><span class="line">  hub:</span><br><span class="line">  content:</span><br><span class="line">  content_limit: 140</span><br><span class="line">  content_limit_delim: <span class="string">' '</span></span><br><span class="line">  order_by: -date</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>搜索</strong> : 在根目录下的 <code>_config.yml</code> 中添加对应配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>代码高亮</strong> ： 修改根目录下 <code>_config.yml</code> 文件中  <code>highlight.enable</code> 的值为 <code>false</code> ，并新增以下配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prism_plugin:</span><br><span class="line">  mode: <span class="string">'preprocess'</span>    <span class="comment"># realtime/preprocess</span></span><br><span class="line">  theme: <span class="string">'tomorrow'</span></span><br><span class="line">  line_number: <span class="literal">false</span>    <span class="comment"># default false</span></span><br><span class="line">  custom_css:</span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>字数统计</strong>：在根目录下的 <code>_config.yml</code> 中添加对应配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postInfo:</span><br><span class="line">  date: <span class="literal">true</span></span><br><span class="line">  update: <span class="literal">false</span></span><br><span class="line">  wordCount: <span class="literal">false</span>  <span class="comment"># 设置文章字数统计为 true.</span></span><br><span class="line">  totalCount: <span class="literal">false</span> <span class="comment"># 设置站点文章总字数统计为 true.</span></span><br><span class="line">  min2read: <span class="literal">false</span>   <span class="comment"># 阅读时长.</span></span><br><span class="line">  readCount: <span class="literal">false</span>  <span class="comment"># 阅读次数.</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>文章链接转静态短地址</strong>：在根目录下的 <code>_config.yml</code> 中添加对应配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">permalink_pinyin:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  separator: <span class="string">'-'</span> <span class="comment"># default: '-'</span></span><br></pre></td></tr></tbody></table></figure></li><li><p><strong>添加emoji表情支持</strong>: 在根目录下的 <code>_config.yml</code> 中添加对应配置</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">githubEmojis:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  className: github-emoji</span><br><span class="line">  inject: <span class="literal">true</span></span><br><span class="line">  styles:</span><br><span class="line">  customEmojis:</span><br></pre></td></tr></tbody></table></figure></li></ul><ul><li><p><strong>评论系统</strong>： </p><ul><li>评论系统采用的是Valine，基于 <a href="https://www.leancloud.cn/">leancloud</a>。注册账号后完成认证，创建应用，名称随意，比如 blog，复制应用的 <code>APPID</code> 和 <code>APPKey</code> ，填入主题配置文件中的 Valine 配置中。</li></ul></li><li><p>需要在 <a href="https://www.leancloud.cn/">leancloud</a> 应用内的“存储”选项中创建<code>class</code>，名称为<code>Comment</code>，否则评论系统无法工作！</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To use it, activate the configuration item and set appId and appKey.</span></span><br><span class="line"><span class="comment"># Valine 评论模块的配置，默认为不激活，如要使用，就请激活该配置项，并设置 appId 和 appKey.</span></span><br><span class="line">valine:</span><br><span class="line">  <span class="built_in">enable</span>: <span class="literal">true</span></span><br><span class="line">  appId: *******</span><br><span class="line">  appKey: *******</span><br><span class="line">  notify: <span class="literal">false</span></span><br><span class="line">  verify: <span class="literal">false</span></span><br><span class="line">  visitor: <span class="literal">true</span></span><br><span class="line">  avatar: <span class="string">'mm'</span> <span class="comment"># Gravatar style : mm/identicon/monsterid/wavatar/retro/hide</span></span><br><span class="line">  pageSize: 10</span><br><span class="line">  placeholder: <span class="string">'快来交流吧'</span></span><br><span class="line">  background: /medias/comment_bg.png</span><br></pre></td></tr></tbody></table></figure></li></ul><h4 id="3-3-代码压缩"><a href="#3-3-代码压缩" class="headerlink" title="3.3 代码压缩"></a>3.3 代码压缩</h4><p>使用gulp来压缩网站的资源，包括js,html,css</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装gulp</span></span><br><span class="line">npm install gulp -g            </span><br><span class="line"><span class="comment"># 安装组件</span></span><br><span class="line">npm install gulp-htmlclean gulp-htmlmin gulp-minify-css gulp-uglify gulp-imagemin --save</span><br><span class="line"><span class="comment"># 额外的功能模块</span></span><br><span class="line">npm install gulp-debug gulp-clean-css gulp-changed gulp-if gulp-plumber gulp-babel babel-preset-es2015 del @babel/core --save</span><br></pre></td></tr></tbody></table></figure><p>在 Blog 根目录新建文件 <code>gulpfile.js</code> ，填入以下内容</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">var gulp = require(<span class="string">"gulp"</span>);</span><br><span class="line">var debug = require(<span class="string">"gulp-debug"</span>);</span><br><span class="line">var cleancss = require(<span class="string">"gulp-clean-css"</span>); //css压缩组件</span><br><span class="line">var uglify = require(<span class="string">"gulp-uglify"</span>); //js压缩组件</span><br><span class="line">var htmlmin = require(<span class="string">"gulp-htmlmin"</span>); //html压缩组件</span><br><span class="line">var htmlclean = require(<span class="string">"gulp-htmlclean"</span>); //html清理组件</span><br><span class="line">var changed = require(<span class="string">"gulp-changed"</span>); //文件更改校验组件</span><br><span class="line">var gulpif = require(<span class="string">"gulp-if"</span>); //任务 帮助调用组件</span><br><span class="line">var plumber = require(<span class="string">"gulp-plumber"</span>); //容错组件（发生错误不跳出任务，并报出错误内容）</span><br><span class="line">var isScriptAll = <span class="literal">true</span>; //是否处理所有文件，(<span class="literal">true</span>|处理所有文件)(<span class="literal">false</span>|只处理有更改的文件)</span><br><span class="line">var isDebug = <span class="literal">true</span>; //是否调试显示 编译通过的文件</span><br><span class="line">var gulpBabel = require(<span class="string">"gulp-babel"</span>);</span><br><span class="line">var es2015Preset = require(<span class="string">"babel-preset-es2015"</span>);</span><br><span class="line">var del = require(<span class="string">"del"</span>);</span><br><span class="line">var Hexo = require(<span class="string">"hexo"</span>);</span><br><span class="line">var hexo = new Hexo(process.cwd(), {}); // 初始化一个hexo对象</span><br><span class="line"></span><br><span class="line">// hexo clean</span><br><span class="line">gulp.task(<span class="string">"clean"</span>, <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    <span class="built_in">return</span> del([<span class="string">"public/**/*"</span>]);</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// hexo generate</span><br><span class="line">gulp.task(<span class="string">"generate"</span>, <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    <span class="built_in">return</span> hexo.init().<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () {</span><br><span class="line">        <span class="built_in">return</span> hexo</span><br><span class="line">            .call(<span class="string">"generate"</span>, {</span><br><span class="line">                watch: <span class="literal">false</span></span><br><span class="line">            })</span><br><span class="line">            .<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () {</span><br><span class="line">                <span class="built_in">return</span> hexo.exit();</span><br><span class="line">            })</span><br><span class="line">            .catch(<span class="keyword">function</span> (err) {</span><br><span class="line">                <span class="built_in">return</span> hexo.exit(err);</span><br><span class="line">            });</span><br><span class="line">    });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// Hexo s</span><br><span class="line">gulp.task(<span class="string">"server"</span>, <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    <span class="built_in">return</span> hexo</span><br><span class="line">        .init()</span><br><span class="line">        .<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span> () {</span><br><span class="line">            <span class="built_in">return</span> hexo.call(<span class="string">"server"</span>, {});</span><br><span class="line">        })</span><br><span class="line">        .catch(<span class="keyword">function</span> (err) {</span><br><span class="line">            console.log(err);</span><br><span class="line">        });</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 压缩public目录下的js文件</span><br><span class="line">gulp.task(<span class="string">"compressJs"</span>, <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    <span class="built_in">return</span> gulp</span><br><span class="line">        .src([<span class="string">"./public/**/*.js"</span>, <span class="string">"!./public/libs/**"</span>]) //排除的js</span><br><span class="line">        .pipe(gulpif(!isScriptAll, changed(<span class="string">"./public"</span>)))</span><br><span class="line">        .pipe(gulpif(isDebug, debug({ title: <span class="string">"Compress JS:"</span> })))</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(</span><br><span class="line">            gulpBabel({</span><br><span class="line">                presets: [es2015Preset] // es5检查机制</span><br><span class="line">            })</span><br><span class="line">        )</span><br><span class="line">        .pipe(uglify()) //调用压缩组件方法uglify(),对合并的文件进行压缩</span><br><span class="line">        .pipe(gulp.dest(<span class="string">"./public"</span>)); //输出到目标目录</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 压缩public目录下的css文件</span><br><span class="line">gulp.task(<span class="string">"compressCss"</span>, <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    var option = {</span><br><span class="line">        rebase: <span class="literal">false</span>,</span><br><span class="line">        //advanced: <span class="literal">true</span>, //类型：Boolean 默认：<span class="literal">true</span> [是否开启高级优化（合并选择器等）]</span><br><span class="line">        compatibility: <span class="string">"ie7"</span> //保留ie7及以下兼容写法 类型：String 默认：<span class="string">''</span>or<span class="string">'*'</span> [启用兼容模式； <span class="string">'ie7'</span>：IE7兼容模式，<span class="string">'ie8'</span>：IE8兼容模式，<span class="string">'*'</span>：IE9+兼容模式]</span><br><span class="line">        //keepBreaks: <span class="literal">true</span>, //类型：Boolean 默认：<span class="literal">false</span> [是否保留换行]</span><br><span class="line">        //keepSpecialComments: <span class="string">'*'</span> //保留所有特殊前缀 当你用autoprefixer生成的浏览器前缀，如果不加这个参数，有可能将会删除你的部分前缀</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">return</span> gulp</span><br><span class="line">        .src([<span class="string">"./public/**/*.css"</span>, <span class="string">"!./public/**/*.min.css"</span>]) //排除的css</span><br><span class="line">        .pipe(gulpif(!isScriptAll, changed(<span class="string">"./public"</span>)))</span><br><span class="line">        .pipe(gulpif(isDebug, debug({ title: <span class="string">"Compress CSS:"</span> })))</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(cleancss(option))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">"./public"</span>));</span><br><span class="line">});</span><br><span class="line"></span><br><span class="line">// 压缩public目录下的html文件</span><br><span class="line">gulp.task(<span class="string">"compressHtml"</span>, <span class="function"><span class="title">function</span></span> () {</span><br><span class="line">    var cleanOptions = {</span><br><span class="line">        protect: /&lt;\!--%fooTemplate\b.*?%--&gt;/g, //忽略处理</span><br><span class="line">        unprotect: /&lt;script [^&gt;]*\btype=<span class="string">"text\/x-handlebars-template"</span>[\s\S]+?&lt;\/script&gt;/gi //特殊处理</span><br><span class="line">    };</span><br><span class="line">    var minOption = {</span><br><span class="line">        collapseWhitespace: <span class="literal">true</span>, //压缩HTML</span><br><span class="line">        collapseBooleanAttributes: <span class="literal">true</span>, //省略布尔属性的值 &lt;input checked=<span class="string">"true"</span>/&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">        removeEmptyAttributes: <span class="literal">true</span>, //删除所有空格作属性值 &lt;input id=<span class="string">""</span> /&gt; ==&gt; &lt;input /&gt;</span><br><span class="line">        removeScriptTypeAttributes: <span class="literal">true</span>, //删除&lt;script&gt;的<span class="built_in">type</span>=<span class="string">"text/javascript"</span></span><br><span class="line">        removeStyleLinkTypeAttributes: <span class="literal">true</span>, //删除&lt;style&gt;和&lt;link&gt;的<span class="built_in">type</span>=<span class="string">"text/css"</span></span><br><span class="line">        removeComments: <span class="literal">true</span>, //清除HTML注释</span><br><span class="line">        minifyJS: <span class="literal">true</span>, //压缩页面JS</span><br><span class="line">        minifyCSS: <span class="literal">true</span>, //压缩页面CSS</span><br><span class="line">        minifyURLs: <span class="literal">true</span> //替换页面URL</span><br><span class="line">    };</span><br><span class="line">    <span class="built_in">return</span> gulp</span><br><span class="line">        .src(<span class="string">"./public/**/*.html"</span>)</span><br><span class="line">        .pipe(gulpif(isDebug, debug({ title: <span class="string">"Compress HTML:"</span> })))</span><br><span class="line">        .pipe(plumber())</span><br><span class="line">        .pipe(htmlclean(cleanOptions))</span><br><span class="line">        .pipe(htmlmin(minOption))</span><br><span class="line">        .pipe(gulp.dest(<span class="string">"./public"</span>));</span><br><span class="line">});</span><br><span class="line">// 默认任务</span><br><span class="line">gulp.task(</span><br><span class="line">    <span class="string">"default"</span>,</span><br><span class="line">    gulp.series(</span><br><span class="line">        <span class="string">"clean"</span>,</span><br><span class="line">        <span class="string">"generate"</span>,</span><br><span class="line">        gulp.parallel(<span class="string">"compressHtml"</span>, <span class="string">"compressCss"</span>, <span class="string">"compressJs"</span>)</span><br><span class="line">    )</span><br><span class="line">);</span><br></pre></td></tr></tbody></table></figure><p>根目录下执行 <code>gulp</code> 就相当于<code>hexo clean &amp;&amp; hexo g</code>，再把代码压缩。</p><p>再使用 <code>hexo d</code>即可部署到 Github</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 博客搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
